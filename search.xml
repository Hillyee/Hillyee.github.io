<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise面试题(持续更新~)</title>
      <link href="/2022/04/22/Promise%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2022/04/22/Promise%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise面试题">Promise面试题</h2><h3 id="几道打印的基础题">几道打印的基础题</h3><h4 id="题1">题1</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1 2 4 3</p></blockquote><h4 id="题2">题2</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>, promise2)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751fd1862f5d45da84fd5c78be97f7b6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="题3">题3</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1<br>2<br>success</p></blockquote><h4 id="题4">题4</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>2<br>1<br>success</p></blockquote><h3 id="Promise结合setTimeout">Promise结合setTimeout</h3><h4 id="题1-2">题1</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1432</p></blockquote><h4 id="题2-2">题2</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>14523success</p></blockquote><h4 id="题3-2">题3</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>51342</p></blockquote><h4 id="题4-2">题4</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88748175c2814348aa8e523c251bbee9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 😣面试题-js篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写promise</title>
      <link href="/2022/04/17/%E6%89%8B%E5%86%99promise/"/>
      <url>/2022/04/17/%E6%89%8B%E5%86%99promise/</url>
      
        <content type="html"><![CDATA[<h2 id="手写Promise">手写Promise</h2><h3 id="Promise规范">Promise规范</h3><blockquote><p><a href="https://promisesaplus.com/">https://promisesaplus.com/</a>  PromiseA+规范</p><p>A+规范只有then方法</p></blockquote><h3 id="Promise-类设计">Promise 类设计</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种方式，我选第一种</p></blockquote><h3 id="构造函数constructor设计">构造函数constructor设计</h3><p>实现：</p><ol><li>让executor函数执行起来</li><li>定义状态常量</li><li>定义resolve，reject回调，执行的时候改变状态</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUE_PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUE_FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUS_REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存状态与值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_PENDING</span>  </span><br><span class="line">    <span class="comment">// 由于后面的then方法可能会用到这些参数值，需要保存起来</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义resolve回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 改变状态并保存值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve执行&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 定义reject回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 改变状态并保存值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject执行&quot;</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>为了不让resolve，reject回调可以同时执行，我们需要加一个判断，只有状态为pending的时候才执行回调</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;  <span class="comment">// 加一个判断</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve执行&quot;</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123; <span class="comment">// 加一个判断</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject执行&quot;</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then-方法的实现">then 方法的实现</h3><h4 id="简单实现">简单实现</h4><ol><li>then方法接收两个参数，分别是成功时的回调onFulfilled，失败时的回调onRejected</li><li>把回调保存到当前的promise实例，并在对应的resolve，reject回调时执行</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve执行&quot;</span>, value);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>) <span class="comment">// 在这里执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject执行&quot;</span>, reason);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)  <span class="comment">// 在这里执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilled</span> = onFulfilled  <span class="comment">// 保存方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejected</span> = onRejected <span class="comment">// 保存方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候我们会发现，报错了：this.onFulfilled is not a function</p><p>为什么？？</p><p>我们捋一捋代码的执行过程就可以发现，当执行<code>resolve(&quot;111&quot;)</code> 的时候，都还没有到then那一步，也就是说还没执行then方法，那么怎么可能会有 <code>onFulfilled, onRejected</code> 方法呢！</p><p>这时候我们就用到了一个方法：<code>queueMicrotask()</code></p><blockquote><p>MDN：<a href="https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask">https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask</a></p><p>简单来说，这个方法可以把我们传入的方法加入到微任务队列，让它延迟到当前主线程的任务执行完之后再执行</p></blockquote><p>所以可以在resolve方法执行的时候，先不执行onFulfilled，把它加入到微任务队列，接着就会继续执行下面的then方法，这时候就有<code>onFulfilled, onRejected</code> 方法了，最后主线程任务执行完，再执行微任务队列中的 onFulfilled，，（reject同理）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;   <span class="comment">// 加入到微任务队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 加入到微任务队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个时候又出现了一个问题，resolve和reject可以同时调用了</p><p>因为我们执行resolve的实现，加入到微任务队列，因此状态没有被改变，依然是pending</p><p>接着执行reject，判断状态是pending，所以也加入到微任务队列了</p><p>解决：在执行微任务的代码一开始加入一个判断，如果状态已经不是pending了，直接return出去，停止执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span>  <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span> <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，有人可能会说把状态改变放到微任务外面不就行了吗？</p><p>不行！！这样在后面实现链式调用会出现问题</p><p>你后面可以试一下，多个then执行和链式调用一起的时候，执行顺序是有问题的</p><p>至于为什么，那就自己捋一捋整个代码的执行顺序叭</p></blockquote><h4 id="同时调用多个then的实现">同时调用多个then的实现</h4><p>上面的实现是不能同时调用多个then的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res2: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err2: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>后面的then会覆盖前面的，因此只会执行 res2 或者 err2</p><p>实现思路：我们需要把then传入的回调保存到一个数组，到时候一起执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = [] <span class="comment">// 定义数组存放成功的回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [] <span class="comment">// 定义数组存放失败的回调</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;   <span class="comment">// 加入到微任务队列</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">          <span class="comment">// 用forEach遍历执行数组中的回调 </span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;  </span><br><span class="line">            <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 加入到微任务队列</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">          <span class="comment">// 用forEach遍历执行数组中的回调</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled)  <span class="comment">// 保存到数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res2: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err2: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="延迟调用then">延迟调用then</h4><p>还有一种情况：resolve或reject执行完之后，延迟执行then</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res3: &quot;</span>, res);</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err3: &quot;</span>, err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>setTimeout 会在主线程的任务执行完，并且微任务队列也执行完后才执行</p><p>捋一捋执行顺序：</p><ol><li><p>首先主线程 <code>resolve(&quot;111&quot;)</code>执行，先<strong>改变状态为fulfilled</strong>，保存value，然后在微任务队列中加入一个任务</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7c758c4c8fc4368951ba935c8a4ea75~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li><li><p>然后继续往下，<strong>setTimeout</strong> 被加入到宏任务队列，并未执行then</p></li><li><p>主线程任务执行完，执行微任务队列中的任务，<strong>遍历数组中的函数并执行</strong>，但我们可以看到，前面then没有执行，数组中并没有对应回调，所以没有执行</p></li><li><p>接着执行宏任务队列中setTimeout，也就是then方法被执行，</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc271dd9a1d84d3c8defab59010b4b35~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p><strong>这个时候才把回调加入数组</strong>。。。任务结束</p></li></ol><p>因此可以想到实现思路：在then方法中加入判断，如果当前状态是确定的，（fulfilled或rejected），那么直接执行这个回调，不用添加到数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式调用then">链式调用then</h4><p>then需要返回一个promise，后面才能继续调用then</p><p>并且下一次的then是在上次回调执行完之后才执行的，而且需要拿到上次onFulfilled/onRejected 执行完之后的结果，再去执行resolve，reject</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>() <span class="comment">// 这里需要拿到上次回调的结果并且传进去</span></span><br><span class="line">    <span class="title function_">reject</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有个问题，就是怎么拿到上次执行的结果值？</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0042b6e0559549e1b91351eb795be282~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>思路：把上面那一坨代码放到new里面执行，这样就让里边具备了拿到返回结果的能力</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="comment">// 比如这里就可以拿到结果</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="comment">// 然后再执行(这里已经是下一个promise的resolve了)</span></span><br><span class="line">      <span class="title function_">resolve</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">      <span class="comment">// 注意这里调用的应该是resolve，除非上一次的错误回调函数抛出了错误</span></span><br><span class="line">      <span class="title function_">resolve</span>(reason)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为即使我们不链式调用，里面的代码还是会执行的，我们只是想拿到想要的结果，并且在某个时机调用 resolve, reject</p><p>两种情况都调用resolve？那什么时候调用reject呢？</p><p>我们知道，只有在上次的then中抛出异常了，下次才会执行reject</p><p>所以我们再改进一下：使用try…catch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(reason)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面都是在状态已经确定之后的情况，我们知道在状态为pending的时候，我们是把回调保存到数组，然后在上面的resolve、reject中遍历数组执行的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">let</span> value = <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">value</span>)  <span class="comment">// 在这里执行的</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那这个执行结果怎么拿到呢然后传给下面的resolve、reject呢？</p><p>解决方案：改进我们添加到数组的方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>()</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>()</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不直接把回调添加到数组，而是使用一个函数包裹起来，那么到时上面遍历执行的就是这个包裹的函数，然后我们在这里内部执行onFulfilled，就可以在这里拿到onFulfilled的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(value)</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(reason)</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，try…catch改进一下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(reason)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候发现，有一种情况我们没有处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="comment">// resolve(&quot;111&quot;)</span></span><br><span class="line">  <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改进，在 <strong>executor</strong> 那里加try…catch，如果抛出了异常直接执行reject</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err); <span class="comment">// 执行这里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bbb&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res2: &quot;</span>, res); <span class="comment">// 然后来到这里</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err2: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/076b7b8527004ff7b91edd5f07a20ddd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>测试没问题！！</p><h4 id="工具函数">工具函数</h4><p>到这里then方法基本就实现完了，但是我们发现很多 try…catch的重复代码</p><p>我们可以做一个抽取，定义一个工具函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">execFunctionWithCatchError</span>(<span class="params">exeFn, value, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title function_">exeFn</span>(value)</span><br><span class="line">    <span class="title function_">resolve</span>(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后优化then方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="comment">// try &#123;</span></span><br><span class="line">      <span class="comment">//   const value = onFulfilled(this.value)</span></span><br><span class="line">      <span class="comment">//   resolve(value)</span></span><br><span class="line">      <span class="comment">// &#125; catch (err) &#123;</span></span><br><span class="line">      <span class="comment">//   reject(err)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="catch-方法的实现">catch 方法的实现</h3><p>catch接收一个参数，也就是失败的回调，因为catch实际上就相当于语法糖，而且也是返回一个新的promise，所以我们可以直接调用then</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="comment">// resolve(111)  </span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>额，报错了</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b877817e3a7c4cc093ddafaea55b641a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>别急，分析原因。</p><p>我们可以观察一下，本来我们的失败回调应该是在第一个then中传入的，是作为第一个promise的失败的回调的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);</span><br><span class="line">&#125;).<span class="title function_">catch</span>()</span><br></pre></td></tr></table></figure><p>但是现在我们写到catch里面，意味着这个catch传入的回调是被加入到一个新的promise中，作为新的promise的失败的回调了，所以执行不到这个回调了</p><blockquote><p>promise1 -&gt; undefined</p><p>promise2 -&gt; err ={}</p></blockquote><p>那么我们怎么样让promise1执行到err ={} 呢？？</p><p>实现思路：假如说promise1的失败回调没有值，我们直接抛出去，这样就会来到promise2中失败的回调了</p><blockquote><p>promise1 -&gt; err =&gt; {throw err} // 抛出去</p><p>promise2 -&gt; err ={} // 就会执行到这里</p></blockquote><p>还有一个地方是，既然onFulfilled或onRejected可能会传进来undefined，那么我们最好加上一个判断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">defaultOnRejected</span> = err =&gt; &#123; <span class="keyword">throw</span> err &#125;  <span class="comment">// 添加部分</span></span><br><span class="line">  onRejected = onRejected || defaultOnRejected</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onFulfilled) <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">if</span> (onRejected) <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally-方法的实现">finally 方法的实现</h3><p>接收一个参数，无论成功或失败，最后都会执行</p><p>也就是说，成功与失败的回调都是你传入的那个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finally</span></span><br><span class="line"><span class="title function_">finally</span>(<span class="params">onFinally</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFinally</span>()</span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFinally</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还会有一个问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">111</span>)  <span class="comment">// 调用resolve有问题</span></span><br><span class="line">  <span class="comment">// reject(222) 调用reject没问题</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res); <span class="comment">// 圈1</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);<span class="comment">// 圈2</span></span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>); <span class="comment">// 圈3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分析：捋一捋</p><blockquote><p>如果上面是resolve的话，那么就会执行圈1，然后来到promise2的成功回调</p><p>promise1：成功回调是 圈1，失败回调是我们默认的reject</p><p>promise2：没有成功回调，失败回调是圈2，</p><p>​没有成功回调，这时候就会出错了，后面也不会继续执行了，因此要给默认的成功回调 value =&gt; { return value }</p><p>然后才会执行finally的第一个回调</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">defaultOnRejected</span> = err =&gt; &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">  onRejected = onRejected || defaultOnRejected</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加部分</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">defaultOnFulfilled</span> = value =&gt; &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">  onFulfilled = onFulfilled || defaultOnFulfilled</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 来到这里就可以保证 onRejected，onFulfilled 是有值的了，所以下面的判断也可以不要了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span>) &#123;  <span class="comment">// 改了这里</span></span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span>) &#123; <span class="comment">// 改了这里</span></span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onFulfilled) <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">if</span> (onRejected) <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-reject-类方法的实现">resolve reject 类方法的实现</h3><p>resolve 类方法本质就是new了一个 promise，然后直接调用resolve</p><p>reject同理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">123</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="all-方法的实现">all 方法的实现</h3><p>all方法接收一个promise数组，同样返回一个promise</p><p>关键思路：什么时候要执行resolve, 什么时候要执行reject</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> values = [] <span class="comment">// 定义结果数组</span></span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        values.<span class="title function_">push</span>(res)</span><br><span class="line"><span class="comment">// 当结果的个数等于传入promise个数的时候，表示已经执行完了，然后再回调resolve</span></span><br><span class="line">        <span class="keyword">if</span> (values.<span class="property">length</span> === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(values)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err) <span class="comment">// 失败直接执行回调reject</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">    <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [&#x27;111&#x27;, &#x27;222&#x27;, &#x27;333&#x27;]</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// 如果p2调用reject，就会执行这里，输出 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="allSettled-方法的实现">allSettled 方法的实现</h3><p>与all类型，区别就是无论成功与否都会把结果保存到数组</p><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">    <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c6ab0512854961862eb9db477b1e1e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="race-方法的实现">race 方法的实现</h3><p>只要状态改变就执行回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// promise.then(res =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//   resolve(res)</span></span><br><span class="line">      <span class="comment">// &#125;, err =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//   reject(err)</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">      <span class="comment">// 也可以这么写</span></span><br><span class="line">      promise.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="any-方法的实现">any 方法的实现</h3><p>等到第一个fulfilled状态，才执行resolve回调</p><p>如果全都是rejected状态，那么抛出异常</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> reasons = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res)</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reasons.<span class="title function_">push</span>(err)</span><br><span class="line">        <span class="comment">// 当全部promise执行完之后</span></span><br><span class="line">        <span class="keyword">if</span> (reasons.<span class="property">length</span> === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(reasons))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试全都是reject的情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">any</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err, err.<span class="property">errors</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c3b3d01b0fd4086a807b8896d97ac16~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>到此，手写promise就差不多大功告成啦！</p>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise详解</title>
      <link href="/2022/04/17/promise%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/17/promise%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise详解">Promise详解</h2><blockquote><p>ES6 新增 Promise</p></blockquote><h3 id="介绍">介绍</h3><p>Promise 是异步编程的一种解决方案：</p><p>从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</p><p>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p><p>1.为什么需要有Promise？</p><p>promise主要解决的问题：</p><ul><li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li><li>promise可以支持多个并发的请求，获取并发请求中的数据</li><li>这个promise可以解决异步的问题，本身不能说promise是异步的</li></ul><blockquote><p>补充一下，什么是回调函数？</p><p>就是我给你传一个函数，你反过来调用我</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78475af436354b338af3be4b9a9083da~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></blockquote><p>一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当参数a大于10且参数fn2是一个方法时 执行fn2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a, fn2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">10</span> &amp;&amp; <span class="keyword">typeof</span> fn2 == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">fn2</span>() <span class="comment">// 回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">11</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is a callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.Promise是什么？怎么使用？</p><ul><li><p>Promise 是一个类，字面意思：承诺、期约</p></li><li><p>通过 new 可以创建一个 Promise 对象，并且需要传入回调函数（executor）</p><p>这个回调函数会被<strong>立即执行</strong>，并且会传入另外两个回调函数 resolve、reject</p><p>当我们调用resolve回调函数时，会执行Promise对象的then方法传入的第一个回调函数，当调用reject的时候，会执行第二个回调</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success message&quot;</span>)</span><br><span class="line">  <span class="comment">// reject(&quot;failure&quot;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise的三种状态">Promise的三种状态</h3><p>Promise使用过程，我们可以将它划分成三个状态：</p><p><strong>pending</strong>：待定，初始状态，既没有被兑现，也没有被拒绝；当执行executor中的代码时，处于该状态；</p><p><strong>fulfilled</strong>：已兑现， 意味着操作成功完成；执行了resolve时，处于该状态； （也有的地方叫resolved状态）</p><p><strong>rejected</strong>：已拒绝，意味着操作失败； 执行了reject时，处于该状态；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// pending待定</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>() <span class="comment">// fulfilled(已完成)</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">reject</span>() <span class="comment">// rejected(已拒绝)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：Promise的状态一旦确定，就不可更改，只有两种状态改变：</p><p><code>pending</code> -&gt;<code> fulfilled</code>             <code>pending</code> -&gt;<code> rejected</code></p><blockquote><p>另外我们如果抛出异常，状态也是rejected，会回调then的第二个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;异常&quot;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// Error: 异常</span></span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure></blockquote><h3 id="resolve不同值的区别">resolve不同值的区别</h3><p><strong>resolve(参数)</strong>：resolve的参数，三种情况</p><ol><li><p>参数是普通值(数值/字符串/普通对象/undefined)，状态变化 pending -&gt; fulfilled</p></li><li><p>参数又是一个Promise对象，那么这个新Promise会决定原Promise的状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hahhaha&quot;</span>)</span><br><span class="line">  <span class="comment">// reject()</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(newPromise) <span class="comment">// 状态由newPromise决定</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// hahhaha</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>参数是一个对象，并且这个对象有实现then方法，那么会执行该then方法，并且根据 then方法的结果来决定Promise的状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;resolve message&quot;</span>)</span><br><span class="line">      <span class="comment">// reject()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(obj)</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Promise对象方法">Promise对象方法</h3><blockquote><p>then，catch，finally</p></blockquote><h4 id="then方法">then方法</h4><p><strong>1. 两个参数</strong></p><p>then方法是Promise对象上的方法，实际上是放在Promise的原型上的：Promise.prototype.then</p><p>then方法接收两个参数：</p><ul><li>fulfilled的回调函数：当状态变成fulfilled时会回调的函数</li><li>reject的回调函数：当状态变成reject时会回调的函数</li></ul><p><strong>2. 多次调用</strong></p><p>同一个Promise是可以被多次调用then方法的，当resolve方法被回调时，所有的then方法传入的回调函数都会被调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这不是链式调用</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res3); <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3. then的返回值</strong></p><p>then方法本身是有返回值的，它的返回值是Promise</p><ul><li>如果我们then的第一个回调返回的是一个普通值(数值/字符串/普通对象/undefined), 那么这个普通的值会被作为一个新的Promise的resolve值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newPromise = promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPromise); </span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c95c82ce3e094f79a428d32429a89591~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>所以我们可以进行<strong>链式调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span> </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bbb&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果返回的是一个Promise</li></ul><p>那么这个Promise会决定下一个then返回的promise的状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1111</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">    <span class="comment">// reject(&#x27;err&#x27;)</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 3秒后打印 1111</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果返回的是一个对象, 并且该对象实现了then方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">2222</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>其实一样的，既然then返回一个promise，那就跟前面一样的处理，也就是可以继续链式调用then去处理，自己多尝试各种情况看看就都可以理解了</p></blockquote><h4 id="catch方法">catch方法</h4><p>catch方法也是Promise对象上的一个方法：它也是放在Promise的原型上的 Promise.prototype.catch()</p><ul><li>catch方法传入错误（拒绝）捕获的回调函数</li><li>catch也可以多次调用</li><li>我们可以把catch方法理解为 then 方法的语法糖</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;reject message&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意下面两种情况，catch的处理</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;err message&quot;</span>) </span><br><span class="line">    <span class="comment">// 如果这里调用reject,也就是这个promise的状态是rejected</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;reject2 message&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// err message</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// 如果这里调用resolve,fulfilled状态</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;   <span class="comment">// 先调用 then 的第一个回调</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;reject2 message&quot;</span>)  </span><br><span class="line">      <span class="comment">// then返回的promise的状态是rejected</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// reject2 message   catch可以捕获到</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以说catch会处理首次出现拒绝状态的Promise</p><ul><li>catch方法也是会返回一个Promise对象的，所以catch方法后面我们可以继续调用then方法或者catch方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// &quot;111&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;222&quot;</span>  <span class="comment">// 这个catch返回的promise的状态为 fulfilled</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 222</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="finally方法">finally方法</h4><p>finally是在ES9（ES2018）中新增的一个特性：无论Promise对象变成fulfilled还是reject状态，最终都会被执行，所以finally也不需要接收参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); </span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally&quot;</span>); <span class="comment">// &quot;finally&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>finally 也会返回一个promise，但是一般我们不会继续再后面做处理了</p></blockquote><h3 id="Promise类方法">Promise类方法</h3><blockquote><p>也就是直接通过Promise调用的方法，不需要创建实例</p></blockquote><h4 id="Promise-resolve">Promise.resolve</h4><p>直接把某个内容转成Promise来使用</p><p>Promise.resolve的用法相当于new Promise，并且执行resolve操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>resolve的参数跟前面一样的三种，普通的值，Promise，有then方法的obj</p><h4 id="Promise-reject">Promise.reject</h4><p>会将Promise对象的状态设置为reject状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：Promise.reject无论传入的参数是什么形态，都是会直接作为reject状态的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err) <span class="comment">// err: Promise &#123;&lt;fulfilled&gt;: &#x27;123&#x27;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-all">Promise.all</h4><p>将多个Promise包裹在一起形成一个新的Promise，新的Promise状态由包裹的所有Promise共同决定：</p><ul><li><p>当所有的Promise状态变成 fulfilled 状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">333</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [ 111, 222, 333 ]</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-allSettled-2">Promise.allSettled</h4><p>ES11（ES2022）新增</p><p>该方法会在所有的Promise都有结果（无论是fulfilled还是reject）后才会有最终的状态，并且返回的Promise的状态一定是fulfilled</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">333</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res); <span class="comment">// 执行的是这里</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a3fc81e9e0645de87394ad13d3bc9cd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>打印的结果是一个数组，存放每一个Promise的结果</p><p>status：状态，value：值</p><h4 id="Promise-race">Promise.race</h4><blockquote><p>race：竞赛，这个方法可以理解为Promise的竞赛</p></blockquote><p>只要有一个Promise变成fulfilled状态, 那么就结束，并使用这个promise的结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)  <span class="comment">// 先执行完</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">333</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err); <span class="comment">// err: 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-any">Promise.any</h4><p>ES12新增，和race方法类似</p><p>any方法会等到第一个fulfilled状态，才会决定新Promise的状态</p><p>如果所有的Promise都是reject的，那么会报一个AggregateError的错误</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([p1, p2]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err); <span class="comment">// err: 222</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// err: AggregateError: All promises were rejected</span></span><br><span class="line"><span class="comment">// err.errors可以拿到全部错误信息</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题—JS篇之代码输出结果是什么</title>
      <link href="/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>包含类型判断、作用域、this指向、原型、事件循环等知识点</p></blockquote><h1>请问下面的代码输出结果是什么？</h1><h2 id="第1题">第1题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">b</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>答案：2  1</p></blockquote><h2 id="第2题">第2题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> (b = c, c = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><blockquote><p>报错：Cannot access ‘c’ before initialization</p></blockquote><h2 id="第3题">第3题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = b = <span class="number">10</span></span><br><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="keyword">let</span> a = b = <span class="number">20</span> </span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure><blockquote><p>答案：10、20</p></blockquote><h2 id="第4题">第4题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a.<span class="property">x</span> = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>)</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined、{n: 2}</p></blockquote><h2 id="第5题">第5题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x === <span class="literal">undefined</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><blockquote><p>答案：[ ]</p></blockquote><h2 id="第6题">第6题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World&#x27;</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Goodbye &#x27;</span> + name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>答案：Goodbye Jack</p></blockquote><h2 id="第7题">第7题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="title class_">NaN</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span> + <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="literal">undefined</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + &#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + [])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] + &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>答案：NaN、13、NaN、1、1[object Object]、1、[object Object]</p></blockquote><h2 id="第8题">第8题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,</span><br><span class="line">    b=&#123;<span class="attr">key</span>:<span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    c=&#123;<span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">a[b]=<span class="number">123</span></span><br><span class="line">a[c]=<span class="number">456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])</span><br></pre></td></tr></table></figure><blockquote><p>答案：456</p></blockquote><h2 id="第9题">第9题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> inner = &#123;</span><br><span class="line">  <span class="attr">out</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">out</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((inner.<span class="property">func</span>, inner.<span class="property">func</span>)())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inner.<span class="title function_">func</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((inner.<span class="property">func</span>)())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((inner.<span class="property">func</span> = inner.<span class="property">func</span>)())</span><br></pre></td></tr></table></figure><blockquote><p>答案：25、20、20、25</p></blockquote><h2 id="第10题">第10题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125; = &#123; <span class="attr">c</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br></pre></td></tr></table></figure><blockquote><p>答案：1、2、3</p></blockquote><h2 id="第11题">第11题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>[4, 5, 3]</p></blockquote><h2 id="第12题">第12题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span>(x++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: ++x</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: ++x</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: ++x</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>答案：4</p></blockquote><h2 id="第13题">第13题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span> == <span class="keyword">typeof</span> <span class="variable constant_">NULL</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; == <span class="keyword">typeof</span> <span class="keyword">class</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>答案：true、true</p></blockquote><h2 id="第14题">第14题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> count === <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="keyword">typeof</span> count === <span class="string">&quot;number&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>答案：true、false</p></blockquote><h2 id="第15题">第15题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>答案：2、2</p></blockquote><h2 id="第16题">第16题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：1</p></blockquote><h2 id="第17题">第17题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;bcd&#x27;</span></span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined</p></blockquote><h2 id="第18题">第18题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, obj1))</span><br></pre></td></tr></table></figure><blockquote><p>答案：{a: {b: 1}}</p></blockquote><h2 id="第19题">第19题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> getNum = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="title function_">getNum</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined、1、2</p></blockquote><h2 id="第20题">第20题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()()</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined</p></blockquote><h2 id="第21题">第21题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> ()&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [fn]</span><br><span class="line">arr[<span class="number">0</span>]()</span><br></pre></td></tr></table></figure><blockquote><p>答案：打印出arr数组本身</p></blockquote><h2 id="第22题">第22题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure><blockquote><p>答案：1、b函数本身、b函数本身</p></blockquote><h2 id="第23题">第23题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>()</span><br><span class="line"><span class="title function_">getName</span>()</span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>()</span><br><span class="line"><span class="title function_">getName</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：2、4、1、1、2、3、3</p></blockquote><h2 id="第24题">第24题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line"> <span class="attr">address</span>: &#123;</span><br><span class="line">  <span class="attr">country</span>:<span class="string">&quot;china&quot;</span>,</span><br><span class="line">  <span class="attr">city</span>:<span class="string">&quot;hangzhou&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`it&#x27;s <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, from <span class="subst">$&#123;<span class="variable language_">this</span>.address.country&#125;</span>`</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">setCountry</span>:<span class="keyword">function</span> (<span class="params">country</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">address</span>.<span class="property">country</span>=country</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;Matthew&quot;</span></span><br><span class="line">p1.<span class="title function_">setCountry</span>(<span class="string">&quot;American&quot;</span>)</span><br><span class="line"></span><br><span class="line">p2.<span class="property">name</span> = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">p2.<span class="title function_">setCountry</span>(<span class="string">&quot;England&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">say</span>()</span><br><span class="line">p2.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：it’s Matthew, from England</p><p>it’s Bob, from England</p></blockquote><h2 id="第25题">第25题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>答案：2、3、5、4、1</p></blockquote><h2 id="第26题">第26题</h2><p>注：process是Node.js提供的一个对象，它代表当前Node.js进程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>答案：1、7、6、8、2、4、3、5、9、11、10、12</p></blockquote><blockquote><p>1-26 来源：<a href="https://mp.weixin.qq.com/s/fks9SuTSY0ivUfPn6G-TOw">https://mp.weixin.qq.com/s/fks9SuTSY0ivUfPn6G-TOw</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 😣面试题-js篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习TypeScript</title>
      <link href="/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/"/>
      <url>/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript初识">TypeScript初识</h2><blockquote><p>JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题</p></blockquote><h3 id="TS简介">TS简介</h3><p>Typescript是拥有类型的JavaScript超集</p><p>JavaScript所拥有的特性，TS全部都支持，并且在语言层面上添加了类型约束，还加上一些语法的扩展</p><h3 id="TS的编译环境">TS的编译环境</h3><p>TS最终还是会被编译成JS代码运行，所以我们需要搭建对应的环境</p><p>在电脑上安装Typescript，这样就可以通过TypeScript的Compiler将其编译成JavaScript</p><p>全局安装：<code>npm install typescript -g</code></p><p>查看版本：<code>tsc --version</code></p><h3 id="TS的运行环境">TS的运行环境</h3><p>运行的两个步骤：</p><ol><li><code>tsc xxx.ts</code> 把ts文件编译成JS代码</li><li>在浏览器或Node环境下运行JS代码</li></ol><p>如果每次都要做这两个步骤，那就太麻烦了</p><p>有什么简化的方式呢？</p><p>第一种：通过webpack，配置本地的TS编译环境和开启一个本地服务，可以直接运行在浏览器上</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f81ce51bbcd4d06b0e99f3148f0056f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" /><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d656d7ffb32e46f4b65292186998a1cf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>第二种：通过ts-node库，为TS的运行提供执行环境</p><ul><li><p>安装 ts-node：<code>npm install ts-node -g</code></p></li><li><p>另外 ts-node需要安装依赖 tslib 和 @types/node 两个包</p><p><code>npm install tslib @types/node -g</code></p></li><li><p>然后可以直接通过 ts-node 来运行 TS 的代码：</p><p><code>ts-node xxx.ts</code></p></li></ul><h2 id="变量的声明">变量的声明</h2><ul><li><p>定义的时候给标识符加类型：  var/let/const 标识符: 数据类型 = 赋值</p><p>但是 var 不推荐使用</p><p>另外注意 string 和 String 的区别</p><p>string是TypeScript中定义的字符串类型，String是ECMAScript中定义的一个包装类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: string = <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>类型推断（推导），就是说我们第一次给变量赋值的时候，会根据这个赋值的内容，自动推断变量的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span> <span class="comment">// 自动类型推断为number类型</span></span><br><span class="line">num = <span class="string">&quot;123&quot;</span>  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>推荐：如果可以自动推导出变量的类型的时候，不加类型</p><p>不确定类型的时候，要自己加上类型</p></blockquote><h2 id="数据类型">数据类型</h2><p>我们常说TS是JS的一个超集</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cbda679e37349e98f0c39d0213cfef9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="JS类型">JS类型</h3><blockquote><p>TS和JS都有的数据类型</p></blockquote><ol><li><strong>number类型</strong></li></ol><p>TS 和 JS一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: number = <span class="number">123</span></span><br><span class="line">num = <span class="number">222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// num = &quot;123&quot; // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TS 也支持进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num1</span>: number = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: number = <span class="number">0b100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num3</span>: number = <span class="number">0o100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num4</span>: number = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4); <span class="comment">// 100 4 64 256</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>boolean类型</strong></li></ol><p>true、false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: boolean = truelet <span class="attr">flag</span>: boolean = <span class="literal">true</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">flag = <span class="number">20</span> &gt; <span class="number">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>string类型</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;hello&quot;</span></span><br><span class="line">message = <span class="string">&#x27;hello ts&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样也支持ES6的模板字符串</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`hi <span class="subst">$&#123;message&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// hi hello ts</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Array类型</strong></li></ol><p>固定数组里面存放的数据类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">name1</span>: string[] = [] <span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// name1.push(1) // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name2</span>: <span class="title class_">Array</span>&lt;string&gt; = [] <span class="comment">// 不推荐(react jsx中是有冲突)   </span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Object类型</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>:object = &#123;  <span class="comment">// 在这里设置了object类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;kkk&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[<span class="string">&quot;age&quot;</span>]);</span><br></pre></td></tr></table></figure><p>设置了object类型不能获取数据也不能设置数据<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/688374ddd57d49b89dd0ebe6506e3ec1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></p><p>如果去掉了:object就可以获取，并且里面的属性类型也有推断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[<span class="string">&quot;age&quot;</span>]) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>Symbol类型</strong></li></ol><blockquote><p>跟 JS 一样，主要用于设置唯一属性名</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">title1</span>: symbol = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"><span class="comment">// title1 = 2 // number赋值给symbol类型,报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title2 = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>) <span class="comment">// 推断</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [title1]: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  [title2]: <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>Null 和 Undefined类型</strong></li></ol><p>null：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n1</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">n1 = <span class="number">123</span> <span class="comment">// number -&gt; null 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="literal">null</span>  <span class="comment">// 推断是 any类型</span></span><br><span class="line">n2 = <span class="number">123</span> <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>同理：undefined：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n3</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line">n3 = <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n4 = <span class="literal">undefined</span></span><br><span class="line">n4 = <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="TypeScript类型">TypeScript类型</h2><h3 id="any类型">any类型</h3><p>any表示任意类型</p><p>在不确定变量类型的时候，可以使用any类型，但是一旦使用了，意味着我们可以对any类型的变量进行任何的操作，包括赋值任何类型的值；获取不存在的属性、方法</p><p>非常不安全，不推荐使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: any = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">message = <span class="number">123</span></span><br><span class="line">message = <span class="literal">true</span></span><br><span class="line">message = &#123;&#125;</span><br><span class="line"></span><br><span class="line">message.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="unknown类型">unknown类型</h3><p>用于描述类型不确定的变量</p><p>unknown类型只能赋值给any和unknown类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: unknown  <span class="comment">// 如果使用any就不会报错了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  result = <span class="title function_">foo</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免拿到结果之后乱用</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = result </span><br><span class="line"><span class="comment">// 不能将类型“unknown”分配给类型“string”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h3 id="void类型">void类型</h3><p>void通常来指定一个函数没有返回值的，那么它的返回值就是void类型</p><p>另外，这个函数可以返回 null，undefined</p><blockquote><p>一般都不写的，因为没有返回值默认推断就是void</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);         <span class="comment">// 这里写不写void都一样的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="never类型">never类型</h3><p>表示永远不会发生值的类型</p><blockquote><p>never表示函数用于执行不到返回值那一步（抛出异常或死循环）的返回值类型</p><p>而void是函数没有返回值，可以返回null，undefined</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>() <span class="comment">// 抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>never 有什么应用场景？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function handleMessage(message: string | number ) &#123;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: string | number | boolean </span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> message) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;number方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;boolean方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      <span class="comment">// 默认不会执行到返回值那一步,所以如果你没有对应的处理逻辑,就会报错</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">check</span>: never = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候有人想要传入 boolean类型</span></span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 但发现报错了, 然后就给函数参数加上boolean类型</span></span><br><span class="line"><span class="comment">// 然后就不报错了,但是函数里面并没有处理boolean参数的逻辑,他并不知道</span></span><br><span class="line"><span class="comment">// 如果, 加上default那一段,就会报错</span></span><br><span class="line"><span class="comment">// 这时候这个人就知道里面需要有boolean的处理逻辑,然后就去加上</span></span><br></pre></td></tr></table></figure><h3 id="tuple类型">tuple类型</h3><p>tuple 是<strong>元组</strong>类型，元组中每个元素都有自己特定的类型，根据索引值获取到的值可以确定对应的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: [string, number, number] = [<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = info[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">length</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>而数组通常建议存放相同类型的值</p></blockquote><p>tuple应用场景</p><p>tuple通常可以作为返回的值，在使用的时候会非常的方便</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> useState&lt;T&gt;(<span class="attr">state</span>: T) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeState</span> = (<span class="params">newState: T</span>) =&gt; &#123;</span><br><span class="line">    currentState = newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">info</span>: [string, number] = [<span class="string">&#x27;xxx&#x27;</span>, <span class="number">18</span>]</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">tuple</span>: [T, <span class="function">(<span class="params">newState: T</span>) =&gt;</span> <span class="keyword">void</span>] = [currentState, changeState]</span><br><span class="line">  <span class="keyword">return</span> tuple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">setCounter</span>(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">const</span> [title, setTitle] = <span class="title function_">useState</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = <span class="title function_">useState</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="函数的参数和返回值类型">函数的参数和返回值类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般可以不写返回值的类型，会自动推断</span></span><br><span class="line"><span class="comment">// function sum(num1: number, num2: number): number &#123;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>, <span class="number">321</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>]</span><br><span class="line"><span class="comment">// 我们并没有指定item的类型</span></span><br><span class="line"><span class="comment">// 但是TypeScript会根据forEach函数的类型以及数组的类型推断出item的类型, 这个时候可以不添加的类型注解</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象类型">对象类型</h3><p>如果我们希望限定一个函数接收的参数是一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123;x: number, y: number&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(&#123;<span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">321</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="联合类型">联合类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: number | string</span>) &#123;</span><br><span class="line"><span class="comment">// id 可以是number 也可以是 string类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用联合类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: number | string</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用联合类型的值时，需要特别的小心</span></span><br><span class="line">  <span class="comment">// narrow：缩小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定id是string类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选类型">可选类型</h3><p>对象类型也可以指定哪些属性是可选的，可以在属性后面加一个?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123;x: number, y:number, z?:number&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个属性可传可不传</p><p>另外，可选类型可以看做是类型和undefined的联合类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message?: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 什么都不传实际上就是代表undefined</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><h3 id="类型别名">类型别名</h3><p>我们可以给对象类型起一个别名，方面我们后续使用</p><p>用到了关键字 <strong>type</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">IDType</span> = string | number</span><br><span class="line">type <span class="title class_">PointType</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">  z?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: PointType</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言-as">类型断言 as</h3><p>将类型转换为更具体的类型</p><p>本来不加类型断言的话，TS只会把el推断为HTMLElement类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;xxx&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br><span class="line">el.<span class="property">src</span> = <span class="string">&quot;url地址&quot;</span></span><br></pre></td></tr></table></figure><p>案例2：Person 是 Student 的父类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">p: Person</span>) &#123;</span><br><span class="line">  <span class="comment">// 不断言的话会报错：类型“Person”上不存在属性“studying”</span></span><br><span class="line">  (p <span class="keyword">as</span> <span class="title class_">Student</span>).<span class="title function_">studying</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非空类型断言">非空类型断言!</h3><p>! 用于确定某个标识符是有值的，跳过 ts 在编译阶段时对它的检测</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message 可以是string/undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message?: string</span>) &#123;</span><br><span class="line">  <span class="comment">// 当然可以直接if判断</span></span><br><span class="line">  <span class="comment">// if(message) &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是！更简洁</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message!.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链">可选链</h3><blockquote><p>实际上是 ES11 增加的特性</p></blockquote><p><code>?.</code> 操作符，作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  friend?: &#123;</span><br><span class="line">    f1?: &#123;</span><br><span class="line">      <span class="attr">name</span>: string</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(info.friend.f1); // friend不存在,取不到f1,报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">f1</span>); <span class="comment">// undefined, 不报错</span></span><br><span class="line"><span class="comment">// info.friend存在吗？存在再继续取f1</span></span><br></pre></td></tr></table></figure><h3 id="和-运算符">?? 和 !! 运算符</h3><blockquote><p>?? 是 ES11新增的特性</p></blockquote><p>**空值合并操作符 ?? **，是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> res = message ?? <span class="string">&quot;123&quot;</span>  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure><p><strong>!!操作符</strong>，将一个其他类型转换成boolean类型，类型Boolean(变量)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> flag1 = <span class="title class_">Boolean</span>(message)</span><br><span class="line"><span class="keyword">let</span> flag2 = !!message</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag1); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字面量类型">字面量类型</h3><p>字面量也可以当做类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">msg</span>:<span class="string">&quot;hello&quot;</span> = <span class="string">&quot;hello&quot;</span> <span class="comment">// 但是msg的值只能是&quot;hello&quot;</span></span><br><span class="line">msg = <span class="string">&quot;asd&quot;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>那有什么意义呢？可以将多个类型联合在一起</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Alignment</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;center&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAlign</span>(<span class="params">align: Alignment</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改方向:&#x27;</span>, align);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeAlign</span>(<span class="string">&quot;center&quot;</span>) <span class="comment">// 只能传入定义的三个字面量类型</span></span><br></pre></td></tr></table></figure><h3 id="字面量推理">字面量推理</h3><p>下面的代码，默认情况下info 进行类型推断的时候，method是string类型</p><p>加上as const 后，methods就是&quot;GET&quot;字面量类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;https://hillyee.github.io&quot;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">&#125;  <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// 加上as const 后，methods就是&quot;GET&quot;字面量类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: string, method: <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">request</span>(info.<span class="property">url</span>, info.<span class="property">method</span>) <span class="comment">// https://hillyee.github.io GET</span></span><br><span class="line"><span class="comment">// 默认：类型“string”的参数不能赋给类型“&quot;GET&quot; | &quot;POST&quot;”的参数。</span></span><br></pre></td></tr></table></figure><h3 id="类型缩小">类型缩小</h3><p>Type Narrowing 类型缩小</p><p>可以通过类似于 typeof padding === “number” 的判断语句，来改变TypeScript的执行路径</p><p>在给定的执行路径中，缩小比声明时更小的类型，这个过程称之为 缩小</p><p>而我们编写的<code>typeof padding === &quot;number</code> 可以称之为类型保护</p><p>常见的类型保护：</p><ul><li><p>typeof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">IDType</span> = number | string</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;</span><br><span class="line">  <span class="comment">// 这外面使用id是 IDtype 类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里面确认id是string类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 确认是number类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>平等缩小（=== == !== !=/switch）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;top&quot;</span> | <span class="string">&quot;bottom&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.if判断</span></span><br><span class="line">  <span class="comment">// if (direction === &#x27;left&#x27;) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(direction)</span></span><br><span class="line">  <span class="comment">// &#125; else if ()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.switch判断</span></span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//  case ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>instanceof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params">p: Student | Teacher</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p <span class="keyword">instanceof</span> <span class="title class_">Student</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>in</p><blockquote><p>属性是否存在某对象上</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">animal: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;swimming&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">running</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fish</span>:<span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">walk</span>(fish)</span><br></pre></td></tr></table></figure></li></ul><h2 id="TS函数类型">TS函数类型</h2><ol><li><p>定义常量时，编写函数的类型</p><p>(num1: number, num2: number) =&gt; number 就是一个函数类型，并接收两个参数num1，num2，并且都是number类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number</span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">a1: number, a2: number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数作为参数时，在参数中如何编写类型？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">FooFnType</span> = <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn: FooFnType</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(foo)</span><br></pre></td></tr></table></figure></li><li><p>参数的可选类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: number, y?: number</span>) &#123;&#125; <span class="comment">// y可选</span></span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: number, y: number = <span class="number">6</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩余参数</p><p>将一个不定数量的参数放到一个数组中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: number[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    total += num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="this类型">this类型</h2><p>当this不确定的时候，通常TS会要求我们明确的指定this的类型</p><p>如果不指定的话，非常不安全，因为有可能直接调用函数或者通过别的对象来调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type thisType = &#123; <span class="attr">name</span>: string &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"><span class="variable language_">this</span>: thisType, message: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">eating</span>: eating</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">info.<span class="title function_">eating</span>(<span class="string">&quot;asd&quot;</span>) <span class="comment">// this是info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定</span></span><br><span class="line">eating.<span class="title function_">call</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;kkk&quot;</span>&#125;, <span class="string">&quot;hehehe&quot;</span>)</span><br><span class="line"><span class="comment">// &#123; name: &#x27;kkk&#x27; &#125;</span></span><br><span class="line"><span class="comment">// kkk eating hehehe</span></span><br></pre></td></tr></table></figure><h2 id="函数的重载">函数的重载</h2><blockquote><p>函数的重载在实际开发也不是必须要用的，如果本来可以用联合类型简单实现的话，优先选择联合类型</p></blockquote><p>例如有一个需求，希望对字符串和数字类型进行相加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: number | string, a2: number | string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a1 + a2</span></span><br><span class="line">  <span class="comment">// TS 会把 string | number 当做是一个类型</span></span><br><span class="line">  <span class="comment">// 运算符“+”不能应用于类型“string | number”和“string | number”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>以上通过联合类型的方式实现有两个缺点：</p><ul><li>进行很多的逻辑判断（类型缩小）</li><li>返回值的类型依然不确定</li></ul><p><strong>函数的重载是什么？</strong></p><p>函数的名称相同，但是参数不同的几个函数就是函数的重载，并且是没有函数执行体的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构成函数重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: number, num2: number</span>):number</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: string, num2: string</span>):string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line"><span class="comment">// 如果有函数重载，执行体是不能直接被调用的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: any, num2: any</span>): any &#123;</span><br><span class="line">  <span class="comment">// 如果是 string 就返回长度相加</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> num2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1.<span class="property">length</span> + num2.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 先找到函数的声明 再找执行体</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">add</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add(&#123;name: &quot;xxx&quot;&#125;, &#123;age: 18&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>以上案例确实使用函数重载实现更方便，所以可以选择函数重载</p></blockquote><h2 id="TS类的使用">TS类的使用</h2><blockquote><p>这部分，实际开发中相对用的少一点，所以笔记暂时记的比较粗糙</p></blockquote><p><strong>类的定义</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的继承</strong>   extends super 关键字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number, sno: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的多态</strong></p><blockquote><p>不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现</p></blockquote><p><strong>类的成员修饰符</strong></p><ol><li><p>public</p><p>共有的，默认编写的属性就是public</p></li><li><p>private</p><p>仅在同一类中可见</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  private <span class="attr">_name</span>: string = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问器setter/getter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 setter/getter 是访问器属性，这样外界就可以存储</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">p.<span class="property">name</span> <span class="comment">// 会调用get访问器</span></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;kkk&quot;</span> <span class="comment">// set</span></span><br></pre></td></tr></table></figure></li><li><p>protected</p><p>仅在类自身<strong>及子类</strong>中可见、受保护的属性和方法</p></li></ol><p><strong>只读属性readonly</strong></p><p>只读属性是可以在构造器中赋值, 赋值之后就不可以修改</p><p>属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string</span><br><span class="line">  age?: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>静态成员</strong></p><p>通过关键字<strong>static</strong>来定义，直接通过类调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">time</span>: string = <span class="string">&quot;20:00&quot;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">attendClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;去上课&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property">time</span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">attendClass</span>()</span><br></pre></td></tr></table></figure><p><strong>抽象类abstract</strong></p><p>抽象类：</p><ul><li>以abstract 声明的类是抽象类</li><li>抽象类和其他类区别不大，但是不能被实例化（不能通过new调用）</li><li>抽象类就是专门用来被继承的类</li></ul><p>抽象方法：没有具体实现（没有方法体），抽象方法必须存在于抽象类中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shape.<span class="title function_">getArea</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  abstract <span class="title function_">getArea</span>(): number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  private <span class="attr">width</span>: number</span><br><span class="line">  private <span class="attr">height</span>: number</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: number, height: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写方法</span></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">20</span>, <span class="number">30</span>) </span><br><span class="line"><span class="title function_">makeArea</span>(rectangle)</span><br></pre></td></tr></table></figure><p><strong>类的类型</strong></p><p>类本身可以作为一个类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = &#123;  <span class="comment">// p1的类型是Person类，所以必须要传name</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS接口的使用">TS接口的使用</h2><p>除了可以通过type开声明一个对象类型，还可以通过接口来声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，接口中也可以定义可选属性，只读属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string</span><br><span class="line">  age?: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>索引类型</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IndexLanguage</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: number]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">frontLanguage</span>: <span class="title class_">IndexLanguage</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;HTML&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;CSS&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&quot;Vue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数类型</strong></p><p>用过接口interface来定义函数类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">CalcFunc</span> &#123;</span><br><span class="line">  (<span class="attr">num1</span>: number, <span class="attr">num2</span>: number):number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然还是推荐使用类型别名来定义函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number</span><br></pre></td></tr></table></figure><p><strong>接口继承</strong></p><p>接口和类一样可以进行继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IRunning</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IPerson</span> <span class="keyword">extends</span> <span class="title class_">ISwim</span>, <span class="title class_">IRunning</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">action</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的实现</strong></p><p><strong>implements</strong> 用于指定 class 满足某个接口，而且类可以实现多个接口</p><blockquote><p>不是很懂</p><p>面向接口开发</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> implements <span class="title class_">ISwim</span>, <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swim</span>(<span class="params">swimmer: ISwim</span>) &#123;</span><br><span class="line">  swimmer.<span class="title function_">swimming</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title function_">swim</span>(p)</span><br></pre></td></tr></table></figure><p><strong>交叉类型</strong></p><p>一种类型合并，表示需要满足多个类型的条件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">MyType</span> = number &amp; string</span><br></pre></td></tr></table></figure><p><strong>interface 和 type 区别</strong></p><p>interface可以重复对某个接口来定义属性和方法</p><p>而type定义的是别名，别名是不能重复的</p><p><strong>字面量赋值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="attr">height</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">person: IPerson</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printInfo(&#123;</span></span><br><span class="line"><span class="comment">//   name: &quot;xxx&quot;,</span></span><br><span class="line"><span class="comment">//   age: 18,</span></span><br><span class="line"><span class="comment">//   height: 1.88,</span></span><br><span class="line"><span class="comment">//   address: &quot;广州市&quot;  // 报错</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="comment">// 定义字面量</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printInfo</span>(info) <span class="comment">// 再赋值就不会报错</span></span><br></pre></td></tr></table></figure><p>这是因为TypeScript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。</p><p>但是之后如果我们是将一个 变量标识符赋值给其他的变量时，会进行freshness擦除操作</p><h2 id="TS枚举类型">TS枚举类型</h2><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型</p><p>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</p><p>定义枚举类型的关键字：<strong>enum</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">turnDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">LEFT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向左&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">RIGHT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向右&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">TOP</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向上&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">BOTTOM</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向下&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">foo</span>: never = direction;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS泛型">TS泛型</h2><blockquote><p>非常重要！</p></blockquote><h3 id="基本使用">基本使用</h3><p>简单来说就是，类型参数化</p><p>类型决定在调用函数的时候</p><p>基本使用：多加一个<code>&lt;Type&gt;</code>参数来接收类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> sum&lt;<span class="title class_">Type</span>&gt;(<span class="attr">num1</span>: <span class="title class_">Type</span>):<span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum&lt;number&gt;(<span class="number">10</span>)</span><br><span class="line">sum&lt;string&gt;(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">sum&lt;&#123;<span class="attr">name</span>: string&#125;&gt;(&#123;<span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>还有一种调用方式，类型推导</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sum</span>(<span class="number">50</span>) <span class="comment">// 那么类型Type就是字面量50</span></span><br></pre></td></tr></table></figure><p>另外，还可以传入多个类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> foo&lt;T, E, O&gt;(<span class="attr">arg1</span>: T, <span class="attr">arg2</span>: E, <span class="attr">arg3</span>: O, ...<span class="attr">args</span>: T[]) &#123;</span><br><span class="line"><span class="comment">// ...args: T[] 是剩余参数,放到一个数组，只能选择前面&lt;&gt;定义的类型,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo&lt;number, string, boolean&gt;(<span class="number">10</span>, <span class="string">&quot;aaa&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>开发时常用的名称：</p><p>T：Type的缩写，类型</p><p>K、V：key和value的缩写，键值对</p><p>E：Element的缩写，元素</p><p>O：Object的缩写，对象</p><h3 id="泛型接口">泛型接口</h3><p>定义接口中使用泛型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">IPerson</span>&lt;string&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类">泛型类</h3><p>定义类使用泛型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;<span class="variable constant_">T1</span>, <span class="variable constant_">T2</span>&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable constant_">T1</span></span><br><span class="line">  <span class="attr">age</span>: <span class="variable constant_">T2</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: T1, age: T2</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kkk&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己定义类型</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;string, number&gt;(<span class="string">&#x27;xxx&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>:<span class="title class_">Person</span>&lt;string, number&gt; = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><h3 id="泛型约束">泛型约束</h3><blockquote><p>给类型参数一点约束</p></blockquote><p>关键字 <strong>extends</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的参数必须有length属性</span></span><br><span class="line"><span class="title function_">getLength</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="title function_">getLength</span>([<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>])</span><br><span class="line"><span class="title function_">getLength</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="TS其他内容">TS其他内容</h2><h3 id="模块化开发">模块化开发</h3><p>TS有两种方式控制作用域</p><h4 id="模块化">模块化</h4><p>支持ES Module，CommonJS</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ebf34f36dc4e0299f70e0bfb5cf699~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><h4 id="命名空间namespace">命名空间namespace</h4><p>是将一个模块内部再进行作用域的划分，防止一些命名 冲突的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了其他文件能使用，这里还要导出</span></span><br><span class="line"><span class="keyword">export</span> namespace time &#123;</span><br><span class="line">  <span class="comment">// 内部要export导出，才能在这个ts模块中使用</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">time: string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2022-4-13&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他的逻辑</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">name</span>: string = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> namespace price &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">price: number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;99.99&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TS早期的东西，个人还是选择模块化</p></blockquote><h3 id="类型的查找">类型的查找</h3><p>在之前，我们除了自己编写类型，还有用到一些其他的类型，比如说</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;image&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br></pre></td></tr></table></figure><p>HTMLImageElement 类型来自哪里呢？</p><p>首先我们需要知道一种ts文件：<code>.d.ts</code>为后缀名的文件</p><ul><li>这种文件是用来做类型的声明的（declare）。它仅仅用来做类型检测，告诉typescript我们有哪些类型</li><li>这种文件是不需要转成js文件来运行的</li></ul><p>那么typescript会在哪里查找我们的类型声明呢？</p><p>有三种：</p><ul><li><p>内置类型声明</p><p>typescript自带的，帮助我们内置了JS运行时的一些标准化API的声明文件</p><p>比如如Math、Date等内置类型，也包括DOM API，比如Window、Document等</p><p>内置类型声明通常在我们安装typescript环境中会带有</p><blockquote><p>github:<a href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></p></blockquote></li><li><p>外部定义类型声明</p><p>通常是我们使用一些库时，需要的一些类型声明</p><p>这些库有两种类型声明方式</p><ol><li>在自己库中进行类型声明（编写.d.ts文件），比如axios</li><li>通过社区的一个公有库DefinitelyTyped存放类型声明文件</li></ol><blockquote><p>github链接：</p><p>该库的GitHub地址：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></p><p>该库查找声明安装方式的地址：<a href="https://www.typescriptlang.org/dt/search?search=">https://www.typescriptlang.org/dt/search?search=</a></p><p>比如我们需要安装react的类型声明，就可以去查找安装方式</p></blockquote></li><li><p>自定义类型声明</p><p>比如我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p><p>这时候我们要自己声明类型文件：</p><p>任意一个项目文件夹下定义<code>.d.ts</code> 文件，ts会自己找到的</p><p>声明模块关键字：<strong>declare</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明模块</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: any[]</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>声明变量-函数-类</strong></p><p>在<code>.d.ts</code> 文件中声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="keyword">let</span> <span class="attr">myName</span>: string</span><br><span class="line">declare <span class="keyword">let</span> <span class="attr">myAge</span>: number</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是声明类型, 不需要执行体</span></span><br><span class="line">declare <span class="keyword">function</span> <span class="title function_">myFoo</span>(<span class="params"></span>): <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">declare <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他地方使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFoo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>声明模块</strong></p><p>声明模块的语法: declare module ‘模块名’ {}。</p><p>在声明模块的内部，可以通过export导出对应库的类、函数等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: any[]</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明文件</strong></p><blockquote><p>文件会被当成模块使用，然后就可以引入</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jepg&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span></span><br></pre></td></tr></table></figure><p>在别的地方<code>import</code>使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">&#x27;./img/xxx.jpg&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>声明命名空间</strong></p><p>比如在index.html中直接引入jQuery</p><p>然后在声明文件中（<code>.d.ts</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare namespace $ &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">settings: any</span>):any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在别的文件使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;...&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深入Vue3+Typescript学习⚡ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题—JS手写篇</title>
      <link href="/2022/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E6%89%8B%E5%86%99%E7%AF%87/"/>
      <url>/2022/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E6%89%8B%E5%86%99%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="实现instanceof">实现instanceof</h3><blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><p>Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）</p><p>要懂原型和原型链</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">target, origin</span>) &#123;</span><br><span class="line">  <span class="comment">// 基本数据类型直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 拿到 target 的__proto__</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(target)</span><br><span class="line">  <span class="comment">// proto不为null就继续</span></span><br><span class="line">  <span class="keyword">while</span>(proto) &#123;</span><br><span class="line">    <span class="comment">// 找到相同的原型对象</span></span><br><span class="line">    <span class="keyword">if</span> (proto == origin.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 继续沿着原型链找</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(<span class="string">&quot;111&quot;</span>, <span class="title class_">String</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;111&quot;</span>), <span class="title class_">String</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">People</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="JS如何实现继承？">JS如何实现继承？</h3><h4 id="方式1：借助原型链">方式1：借助原型链</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;pName&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 获得Person类的属性方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们让Student的原型指向p</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>); <span class="comment">// pName</span></span><br><span class="line">stu.<span class="title function_">sayHello</span>() <span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 可见我们已经拿到了父类的属性和方法</span></span><br></pre></td></tr></table></figure><p>这种实现方法存在的问题：</p><p>1.当我们打印实例stu的时候，继承的属性不能直观看到，只能在<code>__proto__</code>属性中看到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu)<span class="comment">// Student &#123;height: 1.88&#125;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b22630e56f0f4495b46de38b9142b383~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" /><p>2.另外，如果我们创建两个实例对象，并改变friends属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>); <span class="comment">// [&#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure><p>明明改变的是stu1的属性，为什么stu2也变了？</p><p>因为我们它们的隐式原型指向的是同一个对象，p</p><p>3.前面实现的过程都没有传递参数</p><h4 id="方式2：借助构造函数">方式2：借助构造函数</h4><p>使用call调用构造函数，传入的this为当前实例，并且可以把参数传给父类处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age) <span class="comment">// 这里可以获得父类的属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 依然需要这里来获得方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="number">18</span>, <span class="number">1.78</span>)</span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;bbb&#x27;</span>, <span class="number">20</span>, <span class="number">1.88</span>)</span><br><span class="line"></span><br><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2);</span><br><span class="line">stu1.<span class="title function_">sayHello</span>() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>构造函数的方法可以解决原型链方式的问题，但是依然存在弊端</p><ol><li>Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person）</li><li>stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的）</li></ol><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d55255c9445464c9e38514c08dd0d4c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="方式3：寄生组合式继承-最终方案">方式3：寄生组合式继承(最终方案)</h4><blockquote><p>**<code>Object.create()</code>**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p><p>Object.create(XXX) 也就是传入的对象XXX，作为新对象的原型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, friends</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = friends</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, friends, height</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取父类中的属性和方法</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, friends)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再获取一份父类的prototype中的属性和方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="number">18</span>, [<span class="string">&#x27;fre1&#x27;</span>], <span class="number">1.88</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9029791227bd4b56903a268afb40c68d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>当然，我们也可以封装一个方法来继承父类prototype中的属性和方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">SubType, SuperType</span>) &#123;</span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当然子类的prototype还需要有constructor指向子构造函数本身</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">SubType</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure><h3 id="JS柯里化实现">JS柯里化实现</h3><blockquote><p>要求，传入一个函数，返回一个柯里化的函数</p><p>思路：当已经传入的参数 大于等于 所需要的参数时，就执行函数</p><p>没有达到个数时，需要返回一个新的函数，继续来收集参数，接收到参数后，递归调用curried来检查函数的个数是否达到</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurrying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 当已经传入的参数 大于等于 需要的参数时, 就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// fn()</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有达到个数时, 需要返回一个新的函数,继续来接收参数</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">curried2</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收到参数后, 需要递归调用curried来检查函数的个数是否达到</span></span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args, ...args2])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> curried2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个柯里化的函数</span></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryAdd = <span class="title function_">myCurrying</span>(add1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 😣面试题-js篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy-Reflect-响应式原理</title>
      <link href="/2022/04/11/Proxy-Reflect-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/11/Proxy-Reflect-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>Proxy</h1><h2 id="监听对象的操作">监听对象的操作</h2><p>如果我们希望监听一个对象中的属性被设置或获取的过程</p><p>在之前，我们可以通过 <code>Object.defineProperty</code> 的存储属性描述符（get set）来监听到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[key]</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到obj对象的<span class="subst">$&#123;key&#125;</span>属性被访问了`</span>);</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到obj对象的<span class="subst">$&#123;key&#125;</span>属性被设置值`</span>);</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;asd&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>但是如果我们想要监听更加丰富的操作，比如说新增属性、删除属性，那么这个方法是无能为力的</p><p>而且我们要知道，这个方法的存储描述符设计的初衷也不是为了监听一个完整的对象的</p><h2 id="Proxy的基本使用">Proxy的基本使用</h2><blockquote><p>这也是我们监听对象操作的第二种方式</p></blockquote><p>在 ES6 中，新增了Proxy<strong>类</strong>，用于帮助我们创建一个代理</p><p>如果我们希望监听一个对象的相关操作，我们可以先根据这个对象创建一个代理对象（Proxy对象）。</p><p>然后对该对象的所有操作，我们都通过代理对象完成，因为这个代理对象可以帮我们监听我们对原对象进行的操作</p><p>怎么来使用这个Proxy代理呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 获取值时的捕获器</span></span><br><span class="line">  <span class="comment">// target:原对象, key:属性</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性被访问了`</span>, target);</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置值的捕获器</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性被设置值`</span>, target);</span><br><span class="line">    target[key] = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听in的捕获器</span></span><br><span class="line">  <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性in操作`</span>, target);</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听delete的捕获器</span></span><br><span class="line">  <span class="attr">deleteProperty</span>: <span class="keyword">function</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性delete操作`</span>, target);</span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// 监听到对象的name属性被访问了 &#123;name: &#x27;xxx&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 监听到对象的name属性被设置值 &#123;name: &#x27;xxx&#x27;, age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// kkk</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> objProxy); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> objProxy.<span class="property">name</span> </span><br></pre></td></tr></table></figure><blockquote><p>为什么我们对代理对象做出的改变，原对象也是会变的？</p><p>因为我们设置值的时候，就是直接对原对象设置的，target[key] = newValue</p></blockquote><h2 id="Proxy所有捕获器">Proxy所有捕获器</h2><p>有13个捕获器</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ced0dad1f1e422c8187a8e27703ebcb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddc940ec5cdc479b83241f9bf53894ae~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>Proxy 对函数的监听：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(foo, &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span>(<span class="params">target, thisArg, arrArray</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;对foo函数进行了apply调用&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">apply</span>(thisArg, arrArray)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, arrArray, newTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;对foo函数进行了new调用&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...arrArray)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fooProxy.<span class="title function_">apply</span>(&#123;&#125;, [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>])</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">fooProxy</span>(<span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;fff&quot;</span>)</span><br></pre></td></tr></table></figure><h1>Reflect</h1><h2 id="简单介绍">简单介绍</h2><ul><li><p><strong>Reflect是什么？</strong></p><p>ES6 新增的一个API，它是一个<strong>对象</strong>，字面意思是反射</p></li><li><p><strong>有什么用呢？</strong></p><p>主要是提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法</p><p>比如：Reflect.getPrototype(target) 类似于 Object.getPrototype(target)</p></li><li><p>那有Object可以做这些操作，为什么还要新增 Reflect 对象呢？</p><p>因为在早期的 ECMA 规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范，所以将这些API放在 Object 上</p><p>但是Object作为一个构造函数，这些操作放到它身上并不合适</p><p>另外还包含一些类似于 in、delete操作符，Reflect让原本的命令式变成函数式 .has ()等</p><p>所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上</p></li><li><p>Object和Reflect对象之间的API关系</p><blockquote><p>MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods</a></p></blockquote></li></ul><h2 id="Reflect常见方法">Reflect常见方法</h2><blockquote><p>跟Proxy一一对应的，也是13个</p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1901525696149e1981fe1941c906f4c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>Reflect 和 Proxy 一起使用</p><p>我们可以对前面Proxy案例中，对原对象的操作都修改为Reflect来操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get---------&quot;</span>)</span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">    <span class="comment">// 不直接修改原对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set---------&quot;</span>)</span><br><span class="line">    <span class="comment">// target[key] = newValue</span></span><br><span class="line">    <span class="comment">// 可以拿到设置成功与否的结果,一个布尔值</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后就可以根据结果做一些操作</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>); <span class="comment">// kkk</span></span><br></pre></td></tr></table></figure><h2 id="Receiver参数的作用">Receiver参数的作用</h2><p>访问器还有一个参数 receiver</p><p>作用：如果我们的源对象有setter，getter的访问器属性，那么可以通过receiver来改变里面的this</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>  <span class="comment">// 改变这里的this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// receiver是创建出来的代理对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(receiver === objProxy);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get方法被访问&#x27;</span>, key, receiver);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set成功&#x27;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>改变this，让它指向代理对象 又对代理对象有操作，所以捕获了两次</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9c67d9919194a99b3e95124be862853~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h2 id="Reflect中的construct">Reflect中的construct</h2><blockquote><p>很少很少用到叭，ryfES6文档：</p><p><strong>Reflect.construct(target, args)</strong></p><p>等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p></blockquote><p>应用场景，直接看例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行Student函数中的内容，但是创建出来的对象是Teacher对象</span></span><br><span class="line"><span class="keyword">const</span> teacher = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Student</span>, [<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>], <span class="title class_">Teacher</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(teacher);</span><br><span class="line"><span class="comment">// Teacher &#123;name: &#x27;xxx&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(teacher.<span class="property">__proto__</span> === <span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1>响应式原理</h1><h2 id="什么是响应式">什么是响应式</h2><p>先看一段代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">m = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>当 m 发生改变的时候，上面依赖m的一段代码自动重新执行</p><p>这种可以自动响应数据变量的代码机制，我们就称之为<strong>响应式</strong>的</p><h2 id="实现响应式">实现响应式</h2><h3 id="响应式函数设计与封装">响应式函数设计与封装</h3><p>首先，需要重新执行的代码可能有很多行，因此我们可以将这些代码放到一个函数中</p><p>当数据发生变化的时候，我们让这个函数执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖obj的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj变了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 当数据发生变化的时候,函数再次执行</span></span><br><span class="line"><span class="title function_">objFn</span>()</span><br></pre></td></tr></table></figure><p>这是我们简单的思想，如果我们有多个响应式函数需要再次执行呢？</p><p>那么我们可以封装一个函数，把这些响应式函数都收集起来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="comment">// 把响应式函数收集到数组中   // 改</span></span><br><span class="line"><span class="keyword">let</span> reactiveFns = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  reactiveFns.<span class="title function_">push</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们把需要响应式的函数传入watchFn</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;           <span class="comment">// 改</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj变了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 当数据发生变化的时候,执行收集的响应式函数</span></span><br><span class="line">reactiveFns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;   <span class="comment">// 改</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="响应式依赖的收集">响应式依赖的收集</h3><p>目前我们收集的依赖全都放到一个数组来保存，这存在很大的问题。</p><p>实际开发中我们需要监听很多对象的响应式，这些对象需要监听的属性也不止一个，它们都会有对应的响应式函数</p><p>所以我们要设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123; <span class="comment">// 改</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()  <span class="comment">// 改</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  depend.<span class="title function_">addDepend</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name变了&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 当数据发生变化的时候,执行收集的响应式函数</span></span><br><span class="line">depend.<span class="title function_">notify</span>()      <span class="comment">// 改</span></span><br></pre></td></tr></table></figure><h3 id="自动监听对象变化">自动监听对象变化</h3><p>现在我们有一个问题，数据发生改变的时候，我们是手动去调用notify()让依赖函数执行的</p><p>我们需要自动监听对象变化</p><blockquote><p>注意，我们创建了代理对象之后，对原对象的操作都通过代理对象完成了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  depend.<span class="title function_">addDepend</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  <span class="comment">// 改</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对代理对象操作</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span>   <span class="comment">// 改</span></span><br></pre></td></tr></table></figure><blockquote><p>Vue3 用的Proxy，Vue2用Object.defineProperty() 监听</p></blockquote><h3 id="依赖收集的管理">依赖收集的管理</h3><p>我们可以看出来，上面只创建了一个depend对象来管理obj.name变化需要监听的响应式函数</p><p>如果我们有多个对象，需要监听不同的属性，那么我们可以怎么样来管理不同对象的不同依赖关系呢？</p><p>依赖收集的数据结构，这里必须要理清楚这种结构的设计，我们用到了 Map，WeakMap</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8aee3bb829143a296f7142a54ffe103~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>伪代码：结构大概就是这样子</p><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name的所有depend&quot;</span>)</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;age的所有depend&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj2Map.<span class="title function_">set</span>(<span class="string">&quot;height&quot;</span>, <span class="string">&quot;height的所有depend&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">targetMap</span>(obj1, obj1Map)</span><br><span class="line"><span class="title function_">targetMap</span>(obj2, obj2Map)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当数据变化</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到obj1的name属性的所有依赖</span></span><br><span class="line"><span class="comment">// 根据对象拿对应的map,再根据属性拿依赖函数</span></span><br><span class="line"><span class="keyword">const</span> depend = targetMap.<span class="title function_">get</span>(obj).<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>具体代码实现：</p><p>先创建一个weakMap，并封装一个获取depend的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数      </span></span><br><span class="line"><span class="keyword">const</span> depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  depend.<span class="title function_">addDepend</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数       // 改</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象获取map</span></span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果没有获取到map,说明这个对象是第一次添加依赖</span></span><br><span class="line">  <span class="comment">// 我们要给这个对象新建一个map</span></span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  </span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获获取值的操作,获取依赖,然后执行</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)   <span class="comment">// 改</span></span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对代理对象操作</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span>  </span><br></pre></td></tr></table></figure><p>现在我们执行会发现，根本没有实现响应式，为什么？</p><p>因为我们在watchFn添加依赖函数的时候，不管三七二十一，全都添加到一个depend里面了</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/799b1477919d4463ac9a400d2069f5c0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>所以当我们获取依赖的时候，根本无法根据对象，key来正确的获取对应key的依赖函数</p><ul><li><p>那么正确的依赖应该在哪里收集呢？</p><p>应该在我们调用Proxy的get捕获器的时候。当我们第一次获取属性值的时候，我们就应该对这个key收集它自己的依赖</p></li><li><p>另外，当我们在get里面添加依赖的时候出现一个问题，我们怎么拿到这个响应函数呢？</p><p>定义一个全局的变量 activeReactiveFn</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="keyword">let</span> activeReactiveFn = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;       <span class="comment">// 改！！</span></span><br><span class="line">  activeReactiveFn = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 用原数据先执行一次函数, 收集依赖</span></span><br><span class="line">  activeReactiveFn = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象获取map</span></span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果没有获取到map,说明这个对象是第一次添加依赖</span></span><br><span class="line">  <span class="comment">// 我们要给这个对象新建一个map</span></span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;    </span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据target,key获取对应的depend    // 改！</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)  </span><br><span class="line">    <span class="comment">// 给depend对象中添加响应式函数</span></span><br><span class="line">    depend.<span class="title function_">addDepend</span>(activeReactiveFn)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获获取值的操作,获取依赖,然后执行</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age&#x27;</span>, objProxy.<span class="property">age</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----------修改前---&#x27;</span>);</span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// objProxy.age = 20</span></span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8653f4e8dbab4f4da63aa84f402c1530~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><blockquote><p>一个注意的地方：在watchFn()函数里面，我们会先调用一次传入的函数，为什么呢？</p><p>因为这个函数如果有对某个属性有get的操作的话，我们就能捕获到，而我们在get里面进行收集依赖的操作，就可以收集到这个属性的依赖了</p></blockquote><h3 id="对-Depend-重构">对 Depend 重构</h3><p>现在依然存在问题：</p><ul><li><p>如果函数中用到了两次key，那么我们这个函数就会被收集两次，即重复收集了依赖，后面我们执行depend里面的函数的时候，就会重复执行这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name22&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----------修改前---&#x27;</span>);</span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da09599720c465c84d5d07174a4fcfd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li></ul><p>​解决方法：使用Set来保存依赖函数（Set元素不重复）</p><ul><li>还有一个可以优化的地方：我们并不希望将添加 activeReactiveFn 方法放在get里面，因为这是属于 Depend 类的行为</li></ul><p>修改后：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前需要收集的响应式函数</span></span><br><span class="line"><span class="keyword">let</span> activeReactiveFn = <span class="literal">null</span>   <span class="comment">// 改！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()   <span class="comment">// 改！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeReactiveFn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">add</span>(activeReactiveFn) <span class="comment">// 改！</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeReactiveFn = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 用原数据先执行一次函数, 收集依赖</span></span><br><span class="line">  activeReactiveFn = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; </span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据target,key获取对应的depend</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">    <span class="comment">// 给depend对象中添加响应式函数</span></span><br><span class="line">    depend.<span class="title function_">depend</span>()     <span class="comment">// 改！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name22&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----------修改前---&#x27;</span>);</span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ebfc7d446f4a39a043c616e3785e3f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="对象的响应式操作">对象的响应式操作</h3><p>最后一个问题，前面我们都是对一个对象（obj）实现响应式，那么如果是多个对象呢？</p><p>所以我们要创建一个函数<code>reactive</code>，针对所有的对象都可以变成响应式对象</p><p>也就是实现多个对象的响应式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前需要收集的响应式函数</span></span><br><span class="line"><span class="keyword">let</span> activeReactiveFn = <span class="literal">null</span>   </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeReactiveFn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">add</span>(activeReactiveFn) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeReactiveFn = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 用原数据先执行一次函数, 收集依赖</span></span><br><span class="line">  activeReactiveFn = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个对象，返回一个响应式对象  // 改！！！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  </span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据target,key获取对应的depend</span></span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">      <span class="comment">// 给depend对象中添加响应式函数</span></span><br><span class="line">      depend.<span class="title function_">depend</span>()     <span class="comment">// 改！</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">      depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把需要响应式的对象传到reactive函数</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">reactive</span>(&#123;     <span class="comment">// 改！！</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = <span class="title function_">reactive</span>(&#123;    <span class="comment">// 改！！</span></span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;     </span><br><span class="line">  <span class="comment">// 注意这里 因为reactive返回的就是代理对象，我们用obj接收，obj就是响应式的了,所以直接对obj操作</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name22&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;height&#x27;</span>, info.<span class="property">height</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------修改前---&#x27;</span>);</span><br><span class="line"></span><br><span class="line">info.<span class="property">height</span> = <span class="number">1.78</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ce8b15ee6e64351b51a599174ab05ce~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>到此！我们的响应式就实现完成了</p><h3 id="Vue2响应式原理">Vue2响应式原理</h3><p>前面所实现的响应式的代码，其实是Vue3中的响应式原理</p><p>Vue3主要是通过Proxy来监听数据的变化以及收集相关 的依赖的</p><p>而Vue2是通过Object.defineProerty 的方式来实现对象属性的监听</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = obj[key]</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(obj, key)</span><br><span class="line">        depend.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(obj, key) </span><br><span class="line">        value = newValue</span><br><span class="line">        depend.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在传入对象的时候，遍历所有的key，并且通过属性存储描述符来监听属性的获取和修改，</p><p>其他的逻辑和前面Vue3的响应式实现是一致的</p>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_ES6-ES12知识点</title>
      <link href="/2022/04/10/10_ES6-ES12%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/10/10_ES6-ES12%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6">ES6</h2><h3 id="字面量的增强">字面量的增强</h3><p>属性（Property Shorthand）、方法（Method Shorthand）的简写，计算属性名（Computed Property Names）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;fks&#x27;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 1. 属性的简写</span></span><br><span class="line">  <span class="comment">// name: name</span></span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  <span class="comment">// 2. 方法的简写</span></span><br><span class="line">  <span class="comment">// foo: function() &#123;&#125;,</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;, <span class="comment">// obj.foo() this是obj</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 这是不一样的</span></span><br><span class="line">  <span class="comment">// foo: () =&gt; &#123;&#125; // this是全局</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.计算属性名</span></span><br><span class="line">  [name + <span class="number">123</span>]: <span class="string">&#x27;hahahah&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;fks&#x27;, age: 20, foo: [Function: foo], fks123: &#x27;hahahah&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="解构Destructuring">解构Destructuring</h3><ul><li>解构数组</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;asd&quot;</span>, <span class="string">&#x27;fgd&#x27;</span>, <span class="string">&#x27;dkb&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本来根据索引拿值</span></span><br><span class="line"><span class="comment">// var item1 = names[0]</span></span><br><span class="line"><span class="comment">// var item2 = names[1]</span></span><br><span class="line"><span class="comment">// var item3 = names[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">var</span> [item1, item2, item3] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item1, item2, item3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构后面的元素</span></span><br><span class="line"><span class="keyword">var</span> [ , , itemz] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构一个元素，后面的元素放到一个新数组</span></span><br><span class="line"><span class="keyword">var</span> [itemx, ...newNames] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemx, newNames) <span class="comment">// asd [ &#x27;fgd&#x27;, &#x27;dkb&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构的默认值</span></span><br><span class="line"><span class="keyword">var</span> [itema, itemb, itemc, itemd = <span class="string">&quot;ddd&quot;</span>] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemd);</span><br></pre></td></tr></table></figure><ul><li><p>解构对象</p><p>根据key解构</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不规定顺序，只根据key来解构</span></span><br><span class="line"><span class="keyword">var</span> &#123;age, name&#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age, name); <span class="comment">// 20 asd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对key新命名</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: newName &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值,如果属性不存在,会使用默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">address</span>: newAddress = <span class="string">&#x27;广州&#x27;</span> &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newAddress); <span class="comment">// 广州</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数参数中解构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;name, age&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(obj) <span class="comment">// asd 20</span></span><br></pre></td></tr></table></figure><h3 id="let-const">let/const</h3><h4 id="let-const使用">let/const使用</h4><p>let 声明一个变量</p><p>const 声明一个常量、衡量（constant）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span> <span class="comment">//定义变量</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span> <span class="comment">// 常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意1：const 本质上是传递的值不可以修改，如果传递的是一个引用类型（内存地址），是可以通过引用找到对应的对象去修改内部的属性值的</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;bbb&#x27;</span> <span class="comment">//可以改</span></span><br><span class="line">obj = &#123;&#125; <span class="comment">// 不可以改 TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let / const 定义的变量名是不可以重复定义的</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo2&#x27;</span> <span class="comment">// Identifier &#x27;foo&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h4 id="let-const作用域提升">let/const作用域提升</h4><ul><li><p>使用let声明的变量，在声明之前访问会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 声明之前访问会报错</span></span><br><span class="line"><span class="comment">// 在这里bar已经被创建出来了</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span> <span class="comment">// Reference(引用)Error: Cannot access &#x27;bar&#x27; before initialization</span></span><br></pre></td></tr></table></figure></li><li><p>那么是不是意味着foo变量只有在代码执行阶段才会创建呢？</p><ul><li>事实上并不是，我们可以看一下ECMA262对 let 和 const 的描述</li></ul><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0603965a6f6f4d9fb8e842bcb0f1e7f4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><ul><li>这些变量会被创建在包含他们的词法环境被实例化的时候，但是是不可以访问它们的，直到词法绑定被求值</li></ul></li><li><p>那 let/const有没有作用域提升呢？</p><p>作用域提升：在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升</p><p>所以被创建出来了，但不能被访问，不能称之为作用域提升</p><p>总结：let、const没有进行作用域提升，但是会在解析阶段被创建出来、</p></li></ul><h4 id="let-const变量保存">let/const变量保存</h4><p>let / const 在全局声明变量保存在哪里了？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">foo</span>); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">bar</span>); <span class="comment">// undefined 所以不在window</span></span><br></pre></td></tr></table></figure><ul><li>let, const 是不会给window添加任何属性的</li><li>最新的ECMA标准中对执行上下文的描述</li></ul><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cef4d8ab524242eb92e470879b79e1cd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>也就是说我们声明的变量和环境记录是被添加到变量环境中的（在一个对象保存）</p><ul><li><p>但是标准没有规定这个对象是 window对象或者是其他对象</p></li><li><p>所以JS引擎在解析的时候，会有自己的实现</p></li><li><p>比如v8中其实是通过VariableMap的一个hashmap来实现它们的存储的</p></li><li><p>那么window对象呢？</p><p>window对象是早起的GO对象，在最新的实现中其实是浏览器添加的全局对象，并且 一直保持了window和var之间值的相等性</p></li></ul><h3 id="块级作用域">块级作用域</h3><h4 id="var-没有块级作用域">var 没有块级作用域</h4><ul><li><p>ES5中，JS只会形成两个作用域：<strong>全局作用域</strong>和<strong>函数作用域</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff3d4f044c04d0784db93893047e23d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li><li><p>var 没有块级作用域</p><p>ES5中放到一个代码中定义的变量，外面是可以访问的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="let-const-的块级作用域">let / const 的块级作用域</h4><p>ES6中新增了块级作用域，通过let、const、function、class 声明的标识符是具备块级作用域的限制的</p><p>注意函数，某些引擎会对函数的声明进行特殊处理，允许像var那样提升</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;demo function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(foo); // ReferenceError: foo is not defined\</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于函数,不同的浏览器有不同实现,(大部分浏览器为了兼容以前的代码.让function没有块级作用域) 所以这里可以访问demo</span></span><br><span class="line"><span class="comment">// demo() // demo function 可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// ReferenceError: Person is not defined</span></span><br></pre></td></tr></table></figure><ul><li>if/switch/for 语句的代码就是块级作用域</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if语句的代码就是块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">switch</span> (color) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>: </span><br><span class="line">    <span class="keyword">let</span> bar = <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环执行结束, 全局中 i 是 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 6 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用let</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束后, 全局中并不能访问j</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// j is not defined</span></span><br></pre></td></tr></table></figure><h4 id="块级作用域的应用场景">块级作用域的应用场景</h4><p>一个循环打印的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意setTimeout是宏任务,循环结束后才执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 打印 6 个 6,打印的是全局的 i</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种解决方法，立即执行函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="comment">// 打印的时候往上层作用域查找,找这里的i</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用let,一次循环一个块,互不影响</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// 0 1 2 3 4 5 </span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const注意的地方</strong></p><p>因为有 i++，第二次循环需要用到第一次循环的i去++，const定义的是常量，是不可以改变的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>但是ES6新增的 for…of可以</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> names) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都会有一个新的const item，在不同的块级作用域中</p><h4 id="暂时性死区">暂时性死区</h4><p>在一个代码中，使用let、const声明的变量，在声明之前都是不可以访问的</p><p>这种现象称之为暂时性死区</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 不可访问</span></span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><h3 id="关于字符串">关于字符串</h3><h4 id="模板字符串">模板字符串</h4><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;sfa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// my name is sfa, age is 18</span></span><br></pre></td></tr></table></figure><p>${}里面也可以是表达式，也可以是函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`age is <span class="subst">$&#123;age * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">`double age is <span class="subst">$&#123;doubleAge()&#125;</span>`</span></span><br></pre></td></tr></table></figure><h4 id="标签字符串">标签字符串</h4><blockquote><p>应该很少用到</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是模块字符串中的整个字符串，但是被切成多块放到一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m, n, x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n, x);</span><br><span class="line">  <span class="comment">// [ &#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;aaa&#x27; ] yuzi 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这样去调用一个函数</span></span><br><span class="line"><span class="comment">// foo``</span></span><br><span class="line"><span class="comment">// 当然也可以传参</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;yuzi&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line">foo<span class="string">`Hello<span class="subst">$&#123;name&#125;</span>World<span class="subst">$&#123;age&#125;</span>aaa`</span></span><br></pre></td></tr></table></figure><h3 id="关于函数">关于函数</h3><h4 id="函数的默认参数">函数的默认参数</h4><p>如果没有传参，就会用默认参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m = <span class="string">&#x27;aaa&#x27;</span>, n = <span class="string">&#x27;bbb&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数也可以是对象，并且可以对对象解构，有两种解构方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;name, age&#125; = &#123;name: <span class="string">&#x27;asd&#x27;</span>, age: <span class="number">18</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">&#123;name = <span class="string">&#x27;asd&#x27;</span>, age = <span class="number">18</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外注意：默认形参最好放到最后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">x, y, z = <span class="number">30</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 获取 函数的length值的时候，只获取默认形参之前的参数个数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="函数的剩余参数">函数的剩余参数</h4><p>剩余参数必须放到最后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, args); <span class="comment">// 1 2 [ 3, 4, 5, 6 ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="箭头函数的补充">箭头函数的补充</h4><p>没有自己的this，没有arguments</p><p>没有显式原型，所以不能作为构造函数，不能使用new创建对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">bar</span>() <span class="comment">// TypeError: bar is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="展开语法…">展开语法…</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> name2 = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 函数调用时使用</span></span><br><span class="line"><span class="title function_">foo</span>(...names) <span class="comment">// aaa bbb ccc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构造数组时</span></span><br><span class="line"><span class="keyword">const</span> newNames = [...names, ...name2]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames);</span><br><span class="line"><span class="comment">// [ &#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;k&#x27;, &#x27;k&#x27;, &#x27;k&#x27; ]</span></span><br><span class="line"><span class="comment">// 注意这里把字符串展开了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.构建对象字面量时 ES2018(ES9)</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;<span class="attr">name</span>: <span class="string">&#x27;ggg&#x27;</span>, <span class="attr">height</span>: <span class="number">1.88</span>&#125;</span><br><span class="line"><span class="comment">// 拷贝info的属性，并且可以添加新的属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;...info, <span class="attr">address</span>: <span class="string">&#x27;广州市&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// &#123; name: &#x27;ggg&#x27;, height: 1.88, address: &#x27;广州市&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>注意：展开运算符其实是一种浅拷贝</p><blockquote><p>简单来说就是，拷贝的地址，指向的是同一个对象</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;fff&#x27;</span>,</span><br><span class="line">  <span class="attr">hobby</span>: &#123;</span><br><span class="line">    <span class="attr">h1</span>: <span class="string">&#x27;study&#x27;</span>,</span><br><span class="line">    <span class="attr">h2</span>: <span class="string">&#x27;swim&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newInfo = &#123;...info&#125;</span><br><span class="line">newInfo.<span class="property">hobby</span>.<span class="property">h1</span> = <span class="string">&#x27;sss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">hobby</span>.<span class="property">h1</span>); <span class="comment">// sss 原来的info也改了</span></span><br></pre></td></tr></table></figure><h3 id="表示数值的方法-进制">表示数值的方法(进制)</h3><p>ob开头(binary)：二进制，0o开头(octonary)：八进制，0x开头(hexadecimal)：十六进制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">100</span> <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">0b100</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">const</span> num3 = <span class="number">0o100</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">const</span> num4 = <span class="number">0x100</span> <span class="comment">// 十六进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4); <span class="comment">// 100 4 64 256</span></span><br></pre></td></tr></table></figure><p>另外，大的数值有一个连接符，便于阅读(ES2021 ES12)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10_000_000_000_000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 10000000000000</span></span><br></pre></td></tr></table></figure><h3 id="Symbol的使用">Symbol的使用</h3><blockquote><p>主要是用来创建独一无二的key值，注意使用的时候不要用new</p></blockquote><p>创建Symbol</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>() <span class="comment">// s1,s2是不一样的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2019(ES10)中, Symbol还有一个描述(description)</span></span><br><span class="line"><span class="comment">// 便于标记是哪个symbol，就像是标签</span></span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3); <span class="comment">// Symbol(aaa)</span></span><br><span class="line"><span class="comment">// 可以拿到这个描述</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">description</span>); <span class="comment">// &#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure><p>在对象中作为key使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;yyy&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;mmm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[s1]); <span class="comment">// &#x27;yyy&#x27;</span></span><br><span class="line"><span class="comment">// 新增属性值</span></span><br><span class="line">obj[s3] = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 也可以Object.defineProperty()方法添加属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, s4, &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：获取属性值的时候不能通过 . 语法获取，因为 . 后面的是会被当做字符串</p><p>obj.s1，那么就会去找obj上key为’s1’这个属性值</p></blockquote><p>使用Symbol作为key的属性名，在遍历的时候是获取不到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果想要获取的话可以使用 Object.getOwnPropertySymbols()方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sKeys); <span class="comment">// [ Symbol(), Symbol(), Symbol(aaa) ]</span></span><br></pre></td></tr></table></figure><p>怎么让两个Symbol相等？</p><blockquote><p><code>Symbol.for(key)</code> 方法会根据给定的键 <code>key</code>，来从运行时的 symbol 注册表中找到对应的 symbol</p><p>注意这跟 Symbol(‘aaa’) 标签是不一样的哦</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也就是给symbol一个key</span></span><br><span class="line"><span class="keyword">const</span> sa = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> sb = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sa === sb); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据 symbol值获取key</p><blockquote><p><code>Symbol.keyFor(sym)</code> 方法用来获取全局symbol 注册表中与某个 symbol 关联的键</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sa)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure><h3 id="Set">Set</h3><blockquote><p>新增的一种数据结构（存储数据的方式）</p><p>是集合，里面的元素不重复</p></blockquote><ul><li>创建set和添加元素</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">10</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">20</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">30</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set(3) &#123; 10, 20, 30 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不重复</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set);<span class="comment">// Set(3) &#123; 10, 20, 30 &#125;</span></span><br></pre></td></tr></table></figure><p>注意添加对象时候的一种情况，因为添加的对象的地址是不一样的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">set.<span class="title function_">add</span>(&#123;&#125;)</span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// &#123; &#123;&#125;, &#123;&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下添加的才是同一个对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">set.<span class="title function_">add</span>(obj)</span><br><span class="line">set.<span class="title function_">add</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// &#123; &#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>最常见的应用：对数组去重</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去重(把数组放进集合)</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">const</span> arrSet = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet); <span class="comment">// Set(4) &#123; 10, 20, 30, 40 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>Set的属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">set.<span class="property">size</span> 返回元素个数</span><br></pre></td></tr></table></figure><ul><li>Set的方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">add</span>() 添加元素</span><br><span class="line"><span class="title function_">clear</span>() 清空集合元素</span><br><span class="line"><span class="title function_">delete</span>(x) 删除某元素</span><br><span class="line"><span class="title function_">has</span>(x) 是否包含x元素</span><br><span class="line"></span><br><span class="line">遍历：forEach</span><br><span class="line">arrSet.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arrSet) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WeakSet">WeakSet</h4><blockquote><p>用的很少，对于WeakSet的应用我就不纠结了</p></blockquote><p>WeakSet跟set的区别：WeakSet只能存放对象类型</p><p>WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收</p><p>另外，WeakSet不能遍历，因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素那么有可能造成对象不能正常销毁，所以存储到WeakSet中的对象是没办法获取的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"></span><br><span class="line">weakSet.<span class="title function_">add</span>(<span class="params">&#123;name: <span class="string">&#x27;asd&#x27;</span>&#125;, &#123;&#125;</span>)  &#123; 地址<span class="number">1</span>, 地址<span class="number">2</span> &#125;  弱引用</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet); <span class="comment">// WeakSet &#123; &lt;items unknown&gt; &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>我对弱引用的理解</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18a83978d3d642d1b3d403b13968fb58~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /></blockquote><blockquote><p>关于强引用弱引用的一篇文章：<a href="https://juejin.cn/post/6993101968545677319#heading-21">https://juejin.cn/post/6993101968545677319#heading-21</a></p></blockquote><h3 id="Map">Map</h3><blockquote><p>一种数据结构，键值对的形式，并且键可以是对象</p></blockquote><p>普通对象的键不能是对象？不能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [obj1]: <span class="string">&#x27;qqq&#x27;</span>,</span><br><span class="line">  [obj2]: <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info);</span><br><span class="line"><span class="comment">// &#123; &#x27;[object Object]&#x27;: &#x27;kkk&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 这下懂了吧，这个键会被转成字符串&#x27;[object Object]&#x27;,key重复了，值覆盖了</span></span><br></pre></td></tr></table></figure><p>怎么使用Map？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="comment">// 添加键值</span></span><br><span class="line">map.<span class="title function_">set</span>(obj1, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(obj2, <span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map);</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// Map(3) &#123;</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;aaa&#x27; &#125; =&gt; &#x27;aaa&#x27;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;bbb&#x27; &#125; =&gt; &#x27;bbb&#x27;,</span></span><br><span class="line"><span class="comment">//   1 =&gt; &#x27;ccc&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种添加,把键值对放到数组</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[obj1, <span class="string">&#x27;aaa&#x27;</span>], [obj2, <span class="string">&#x27;bbb&#x27;</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2);</span><br><span class="line"><span class="comment">// Map(2) &#123; &#123; name: &#x27;aaa&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;bbb&#x27; &#125; =&gt; &#x27;bbb&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>有什么属性和方法？</p><p>属性：size：返回map对象的成员数量</p><p>方法：</p><ul><li><p>set(key, value) ：添加，设置键值，返回整个Map对象</p></li><li><p>get(key)：根据key获取值</p></li><li><p>has(key)：是否存在某一个key，返回布尔值</p></li><li><p>delete(key)：删除一个键值对，返回布尔值</p></li><li><p>clear()：清空元素</p></li><li><p>遍历 forEach()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item, key);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for..of遍历注意</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// console.log(item); // 这里把一个键值对放到一个数组了</span></span><br><span class="line">  <span class="comment">// [ &#123; name: &#x27;bbb&#x27; &#125;, &#x27;bbb&#x27; ]</span></span><br><span class="line">  <span class="comment">// 所以可以根据索引值分别拿 key, value</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者进行解构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="WeakMap">WeakMap</h4><p>和Map有什么区别呢？</p><ul><li>WeakMap的key只能使用对象</li><li>WeakMap的key对对象的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收</li></ul><p>常见方法：</p><ul><li>set(key, value)：添加键值，返回整个对象</li><li>get(key)：根据key获取值</li><li>has(key)：是否包含某个key，返回布尔值</li><li>delete(key)：根据key删除键值对，返回布尔值</li></ul><p>WeakMap不能遍历</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakMap); <span class="comment">// WeakMap &#123; &lt;items unknown&gt; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>响应式原理中的WeakMap使用</strong></p><blockquote><p>可以看看Vue3的响应式原理，之前实现mini-vue的时候实现过响应式系统</p></blockquote><blockquote><p>简单的思想就是：</p><p>创建一个WeakMap, key是obj1，值是一个Map结构,</p><p>这个Map，键是对象的属性，值是有依赖这个属性的函数，</p><p>当这个属性发生什么改变的时候，就执行这个属性所有依赖的函数</p></blockquote><p>一个简单的响应式模拟实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用场景（vue3响应式原理）</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;qwe&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1NameFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1NameFn1被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1NameFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1NameFn2被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1AgeFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1AgeFn1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1AgeFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1AgeFn2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建WeakMap</span></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 2.收集依赖结构</span></span><br><span class="line"><span class="comment">// 2.1.对obj1收集的数据结构</span></span><br><span class="line"><span class="keyword">const</span> obj1Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, [obj1NameFn1, obj1NameFn2])</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, [obj1AgeFn1, obj1AgeFn2])</span><br><span class="line"></span><br><span class="line">weakMap.<span class="title function_">set</span>(obj1, obj1Map)</span><br><span class="line"><span class="comment">// 如果obj1.name发生改变</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;ggg&#x27;</span></span><br><span class="line"><span class="keyword">const</span> targetMap = weakMap.<span class="title function_">get</span>(obj1)</span><br><span class="line"><span class="keyword">const</span> fns = targetMap.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ES7">ES7</h2><h3 id="Array-Includes">Array Includes</h3><p>判断数组中是否包含某个元素</p><p>在之前我们经常使用 indexOf() 判断，该方法返回元素所在的索引值，没有就返回-1</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (names.<span class="title function_">indexOf</span>(<span class="string">&#x27;bbb&#x27;</span>) !== -<span class="number">1</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;包含bbb元素&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES7 新增 Includes 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (names.<span class="title function_">includes</span>(<span class="string">&#x27;bbb&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;包含bbb元素&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 NaN的处理，indexOf()不能判断，includes可以</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>, <span class="title class_">NaN</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names.<span class="title function_">includes</span>(<span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="指数的运算方法">指数的运算方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在之前,指数运算通过 Math.pow()</span></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, <span class="number">3</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// ES7新增：**</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="number">3</span> ** <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1, res2); <span class="comment">// 27 27</span></span><br></pre></td></tr></table></figure><h2 id="ES8">ES8</h2><h3 id="Object-values">Object.values</h3><p>之前我们可以通过 Object.keys()来获取一个对象的所有key，ES8提供Object.values() 获取所有值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)); <span class="comment">// [ &#x27;aaa&#x27;, 18 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用的非常少</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>([<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;asd&#x27;</span>)); <span class="comment">// [ &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries">Object.entries</h3><p>获取到一个数组，数组中存放可枚举属性的键值对数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;asdf&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objEntries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objEntries); <span class="comment">// [ [ &#x27;name&#x27;, &#x27;asdf&#x27; ], [ &#x27;age&#x27;, 20 ] ]</span></span><br><span class="line"><span class="comment">// 然后可以继续遍历这个数组，获得属性,值</span></span><br><span class="line">objEntries.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>([<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]));</span><br><span class="line"><span class="comment">// [ [ &#x27;0&#x27;, &#x27;aaa&#x27; ], [ &#x27;1&#x27;, &#x27;bbb&#x27; ], [ &#x27;2&#x27;, &#x27;ccc&#x27; ] ]  索引值当做key了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="string">&#x27;sdf&#x27;</span>)); <span class="comment">// [ [ &#x27;0&#x27;, &#x27;s&#x27; ], [ &#x27;1&#x27;, &#x27;d&#x27; ], [ &#x27;2&#x27;, &#x27;f&#x27; ] ]</span></span><br></pre></td></tr></table></figure><h3 id="padStart和padEnd">padStart和padEnd</h3><p>根据所给长度,和填充元素来往前或往后填充数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newMessage = message.<span class="title function_">padStart</span>(<span class="number">15</span>, <span class="string">&quot;*&quot;</span>).<span class="title function_">padEnd</span>(<span class="number">20</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage); <span class="comment">// ****hello world-----</span></span><br></pre></td></tr></table></figure><p>小案例：假设要对银行卡号用*隐藏</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="keyword">const</span> cardNumber = <span class="string">&quot;123456781231548564321&quot;</span></span><br><span class="line"><span class="keyword">const</span> lastFourCard = cardNumber.<span class="title function_">slice</span>(-<span class="number">4</span>) </span><br><span class="line"><span class="keyword">const</span> finalCard = lastFourCard.<span class="title function_">padStart</span>(cardNumber.<span class="property">length</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(finalCard); <span class="comment">// *****************4321</span></span><br></pre></td></tr></table></figure><blockquote><p>slice 可以传入负数的哦，-4，倒数4位</p></blockquote><h3 id="Trailing-Commas">Trailing-Commas</h3><p>ES8，允许在函数定义和调用时多加一个逗号</p><blockquote><p>没什么，反正我们平时也不会加。trailing：后面的，commas：逗号</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b,</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>,)</span><br></pre></td></tr></table></figure><h3 id="Object-Descriptors">Object Descriptors</h3><p>ES8中新增对对象的操作，<strong>Object.getOwnPropertyDescriptors()</strong></p><p>获取一个对象的所有<strong>自身属性</strong>的描述符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">age</span>: &#123; <span class="attr">value</span>: <span class="number">18</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,      </span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ES8 新增async await 的函数使用，后面另外记</p></blockquote><h2 id="ES9">ES9</h2><blockquote><p>Async iterators：迭代器，后续另外笔记</p><p>Object spread operators：对象展开运算符 <code>const newObj = &#123;...obj, age:18&#125;</code></p><p>Promise finally：后续Promise统一记</p></blockquote><h2 id="ES10">ES10</h2><h3 id="flat-flatMap">flat flatMap</h3><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flat</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>],[[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>]]]</span><br><span class="line"><span class="keyword">const</span> newNums = nums.<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// 默认深度为1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums); <span class="comment">// [ 10, 20, 30, 40, [ 1, 2 ], [ 3, 4 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newNums2 = nums.<span class="title function_">flat</span>(<span class="number">2</span>) <span class="comment">//</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums2); <span class="comment">// [10, 20, 30, 40,1,  2,  3,  4]</span></span><br></pre></td></tr></table></figure><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组</p><blockquote><p>先进行map，再flat，并且flat的<strong>深度为1</strong></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newNums2 = nums2.<span class="title function_">flatMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums2); <span class="comment">// [ 2, 4, 6, 8, 10 ]</span></span><br></pre></td></tr></table></figure><p>这样看起来跟map没什么区别呀？那flatMap有什么应用场景吗？</p><blockquote><p>处理这样的字符串数组，把字符串分成一个个放到数组</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = [<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;hello kk&quot;</span>, <span class="string">&quot;my name is xxx&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words = message.<span class="title function_">flatMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words);</span><br><span class="line"><span class="comment">// [&#x27;Hello&#x27;, &#x27;World&#x27;,&#x27;hello&#x27;, &#x27;kk&#x27;,&#x27;my&#x27;,&#x27;name&#x27;,&#x27;is&#x27;,&#x27;xxx&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries">Object fromEntries</h3><p>ES8有Object.entries将一个对象转换成entries</p><p>ES10有Object.fromEntries 将entries转换成对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;qws&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES8 entries</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries); <span class="comment">// [ [ &#x27;name&#x27;, &#x27;qws&#x27; ], [ &#x27;age&#x27;, 18 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; name: &#x27;qws&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure><p>有什么应用场景吗？</p><p>可以处理query参数，最终转换成对象使用</p><blockquote><p>看到键值对的数组可以想到这个方法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="string">&#x27;name=xxx&amp;age=18&amp;height=1.88&#x27;</span></span><br><span class="line"><span class="keyword">const</span> queryParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(queryString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queryParams);</span><br><span class="line"><span class="comment">// URLSearchParams &#123; &#x27;name&#x27; =&gt; &#x27;xxx&#x27;, &#x27;age&#x27; =&gt; &#x27;18&#x27;, &#x27;height&#x27; =&gt; &#x27;1.88&#x27; &#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> param <span class="keyword">of</span> queryParams) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// [ &#x27;name&#x27;, &#x27;xxx&#x27; ]</span></span><br><span class="line"><span class="comment">// [ &#x27;age&#x27;, &#x27;18&#x27; ]</span></span><br><span class="line"><span class="comment">// [ &#x27;height&#x27;, &#x27;1.88&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就可以利用fromEntries转成对象</span></span><br><span class="line"><span class="keyword">const</span> paramObj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(queryParams)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(paramObj);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;xxx&#x27;, age: &#x27;18&#x27;, height: &#x27;1.88&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="trimStart-trimEnd">trimStart trimEnd</h3><p>单独去除前面或后面的空格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;  hello world   &#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>()); <span class="comment">// 去除前后的空格</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trimStart</span>()); <span class="comment">// 去除前面的空格</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trimEnd</span>()); <span class="comment">// 去除后面的空格</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-description">Symbol description</h3><blockquote><p>s1.description 这个属性可以获取symbol的描述（标签），前面symbol的笔记有写到</p></blockquote><h3 id="Optional-catch-binding">Optional catch binding</h3><blockquote><p>后续在try catch部分笔记</p></blockquote><h2 id="ES11">ES11</h2><h3 id="BigInt">BigInt</h3><p>ES11引入的新的数据类型，用于表示大的整数</p><p>使用：加个n，或者 BigInt(num)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES11前 最大的安全整数</span></span><br><span class="line"><span class="keyword">const</span> maxInt = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxInt); <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="comment">// 超过这个安全整数就可能出现表示错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxInt + <span class="number">1</span>); <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxInt + <span class="number">2</span>); <span class="comment">// 9007199254740992 (错了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES11之后: BigInt</span></span><br><span class="line"><span class="keyword">const</span> bigInt = <span class="number">900719925474099100n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigInt + <span class="number">10n</span>); <span class="comment">// 900719925474099110n</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(<span class="number">100</span>)); <span class="comment">// 100n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigInt + <span class="title class_">BigInt</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以把bigInt类型转Number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(bigInt)); <span class="comment">// 900719925474099100</span></span><br></pre></td></tr></table></figure><h3 id="Nullish-Coalescing-Operator">Nullish Coalescing Operator</h3><p>空值 合并 运算</p><p>新增的操作符：??</p><blockquote><p>处理如果为空，那么使用默认值的判断</p><p>之前的 || 不能很好的处理空字符串，空串转为false，执行后面的语句</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">const</span> res1 = foo || <span class="string">&#x27;default value&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res2 = foo ?? <span class="string">&#x27;default value&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// default value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Optional-Chaining">Optional Chaining</h3><p>可选链：让我们的代码在进行 null 和 undefined 判断时更加清晰和简洁</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="comment">// friend: &#123;</span></span><br><span class="line">  <span class="comment">//   f1: &#123;</span></span><br><span class="line">  <span class="comment">//     name: &#x27;mm&#x27;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在之前，如果获取不存在的属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>.<span class="property">friend</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 我们会做这样的判断</span></span><br><span class="line"><span class="keyword">if</span> (info &amp;&amp; info.<span class="property">friend</span> &amp;&amp; info.<span class="property">friend</span>.<span class="property">f1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>.<span class="property">f1</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES11的可选链</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">f1</span>?.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// info.friend存在吗?存在再继续 .f1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;其他代码逻辑&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Global-This">Global This</h3><p>在之前我们想获取JS环境的全局对象，不同环境获取的方式又不一样</p><p>比如在浏览器中，通过 this，window来获取</p><p>Node中，通过global获取</p><p>所以 ES11 中对获取全局对象进行统一的规范：globalThis</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器下</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node下</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES11 各种环境获取全局对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalThis);</span><br></pre></td></tr></table></figure><h3 id="for…in标准化">for…in标准化</h3><p>在ES11之前，虽然很多浏览器支持 for…in 来遍历对象，但是并没有被ECMA标准化</p><p>ES11中，对其进行标准化，for…in 用于遍历对象的 key</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name // age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dynamic-Import">Dynamic Import</h3><blockquote><p>后续在 ES Module 模块化中笔记</p></blockquote><h3 id="Promise-allSettled">Promise.allSettled</h3><blockquote><p>后续Promise中笔记</p></blockquote><h3 id="import-meta">import meta</h3><blockquote><p>后续在 ES Module 模块化中笔记</p></blockquote><h2 id="ES12">ES12</h2><h3 id="FinalizationRegistry">FinalizationRegistry</h3><p>FinalizationRegistry对象可以让你在对象被垃圾回收时请求一个回调</p><p>当一个在注册表中注册的对象被回收时，可以请求在某个时间点上调用一个清理回调（清理回调有时被称为 finalizer）</p><p>注册：register方法，注册任何想要清理后执行回调的对象，传入该对象，和所含的值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> finalRegistry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;注册在finalRegistry的对象,某个被销毁&quot;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> info = &#123; <span class="attr">age</span>: <span class="number">15</span> &#125;</span><br><span class="line"></span><br><span class="line">finalRegistry.<span class="title function_">register</span>(obj, <span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line">finalRegistry.<span class="title function_">register</span>(info, <span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">info = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 注册在finalRegistry的对象,某个被销毁 val</span></span><br><span class="line"><span class="comment">// 注册在finalRegistry的对象,某个被销毁 obj</span></span><br></pre></td></tr></table></figure><h3 id="WeakRefs">WeakRefs</h3><p>如果我们默认将一个对象赋值给另一个引用，那么这个引用是强引用</p><p>如果我们希望是弱引用，可以使用 WeakRef</p><blockquote><p>注意这里有一个 deref 方法获取弱引用的值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> finalRegistry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;注册在finalRegistry的对象,某个被销毁&quot;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> info = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(obj)</span><br><span class="line"></span><br><span class="line">finalRegistry.<span class="title function_">register</span>(obj, <span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj = null</span></span><br><span class="line"><span class="comment">// 注册在finalRegistry的对象,某个被销毁 obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那还能获取info吗？</span></span><br><span class="line"><span class="comment">// 因为回收要时间，所以这里也做一个延迟才获取属性值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>); <span class="comment">// undefined(不能这样获取)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">deref</span>()?.<span class="property">name</span>);</span><br><span class="line">  <span class="comment">// 如果原对象obj没有被销毁, 可以使用deref()来获取</span></span><br><span class="line">  <span class="comment">// 如果被销毁了,获取到的是 undefined</span></span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h3 id="logical-assignment-operators">logical assignment operators</h3><blockquote><p>logical：逻辑的</p><p>几个逻辑赋值运算符 ||=，&amp;&amp;=（很少用），??=</p><p>可读性不是很好</p></blockquote><ul><li>||= 逻辑或赋值运算</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// message = message || &#x27;default value&#x27;</span></span><br><span class="line">message ||= <span class="string">&#x27;default value&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// default value</span></span><br><span class="line"><span class="comment">// 也是不能判断空串的</span></span><br></pre></td></tr></table></figure><ul><li>&amp;&amp;= 逻辑与赋值运算（很少用）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有值取值</span></span><br><span class="line">info = obj &amp;&amp; obj.<span class="property">name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">obj &amp;&amp;= obj.<span class="property">name</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// xxx</span></span><br></pre></td></tr></table></figure><ul><li>??= 逻辑空赋值运算  0 “”</li></ul><blockquote><p>感觉是可以填补 || 不能很好的判断&quot;&quot; 0</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="number">0</span></span><br><span class="line">message ??= <span class="string">&quot;default value&quot;</span></span><br><span class="line">msg ??= <span class="string">&quot;default val&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Numeric-Separator">Numeric Separator</h3><blockquote><p>Numeric 数值的  Separator 分离器</p></blockquote><p>大的数值有一个连接符 _ ，便于阅读</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10_000_000_000_000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 10000000000000</span></span><br></pre></td></tr></table></figure><h3 id="String-replaceAll">String.replaceAll</h3><blockquote><p>字符串替换，替换所有匹配条件的地方</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">// &#x27;aa..cc&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>之前replace只换第一处匹配的地方</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">// aa.bcc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09_class定义类_ES6</title>
      <link href="/2022/04/08/09_class%E5%AE%9A%E4%B9%89%E7%B1%BB-ES6/"/>
      <url>/2022/04/08/09_class%E5%AE%9A%E4%B9%89%E7%B1%BB-ES6/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6中类的使用">ES6中类的使用</h2><h3 id="认识class定义类">认识class定义类</h3><p>按照构造函数的形式创建类，不仅仅和编写普通的函数过于相似，而且代码并不容易理解</p><ul><li>在ES6(ECMAScript2015)新的标准中使用了class关键字来直接定义类</li><li>但是类的本质上只是构造函数，原型链的语法糖</li><li>最终还是会被 babel 工具转换为ES5的代码</li></ul><h3 id="定义类的方式">定义类的方式</h3><p>可以发现类和构造函数的特性是一致的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的表达式(不怎么用)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的特性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>) <span class="comment">// [class Person]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// [class Person]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="类的构造方法">类的构造方法</h3><p>一个类只能有一个构造函数 constructor，如果包含多个会报错</p><p>new 的时候：</p><ol><li>在内存中创建一个对象 moni = { }</li><li>将类的原型prototype赋值给创建出来的对象的[[prototype]]，<code>moni.__ptoto__ = Person.prototype</code></li><li>将对象复制给函数的this：new绑定 this = moni</li><li>执行函数体中的代码</li><li>自动返回创建出来的对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kac&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;awe&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p2);</span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;kac&#x27;, age: 12 &#125; Person &#123; name: &#x27;awe&#x27;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="类中的方法定义">类中的方法定义</h3><p>三种定义方法</p><ol><li><p>普通的实例方法：实际上是放到原型上的，可以被多个实例共享</p></li><li><p>类的访问器方法：setter，getter</p></li><li><p>类的静态方法：直接使用类来调用的方法 <a href="http://Person.xxx">Person.xxx</a>()，不需要借助实例来调用，例如Promise.all()，也是类方法</p><p>使用 static关键字来定义</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_address</span> = <span class="string">&quot;广州市&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.普通的实例方法</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.类的访问器方法（不怎么用）</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">address</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拦截访问操作&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_address</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">address</span>(<span class="params">newAddress</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拦截设置操作&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_address</span> = newAddress</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.类的静态方法（类方法）：直接通过类来访问的方法</span></span><br><span class="line">  <span class="comment">// Person.xxx()</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">randomPerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> nameIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * names.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">var</span> name = names[nameIndex]</span><br><span class="line">    <span class="keyword">var</span> age = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;axf&quot;</span>, <span class="number">18</span>)</span><br><span class="line">p.<span class="title function_">eating</span>() <span class="comment">// axf eating~</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">address</span>);</span><br><span class="line">p.<span class="property">address</span> = <span class="string">&quot;北京市&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">address</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">randomPerson</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的继承extends">类的继承extends</h3><p>ES6中新增了 <strong>extends</strong> 关键字，可以方便的帮助我们实现继承</p><p><strong>super</strong>关键字，三个使用位置：子类的构造函数、实例方法、静态方法</p><ul><li><p>子类的构造函数：JS引擎在解析子类的时候就有要求，如果我们有实现继承，那么子类的构造方法中,在使用this之前,要调用super()</p><p>否则报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReferenceError</span>: <span class="title class_">Must</span> call <span class="variable language_">super</span> constructor <span class="keyword">in</span> derived <span class="keyword">class</span> <span class="title class_">before</span> accessing <span class="string">&#x27;this&#x27;</span> or returning <span class="keyword">from</span> derived constructor</span><br></pre></td></tr></table></figure></li><li><p>子类可以<strong>重写父类的方法</strong>，在重写方法中使用 super 来复用父类中的逻辑</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑1&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑2&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑3&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; running~&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person staticMethod&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, sno</span>) &#123;</span><br><span class="line">    <span class="comment">// 在使用this前，这里必须使用super()</span></span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写方法一般实例方法</span></span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 复用父类中的逻辑</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">running</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑4&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑5&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑6&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;student &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写父类中的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">staticMethod</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;student staticMethod&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;asx&quot;</span>, <span class="number">12</span>, <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"><span class="comment">// p.running()</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">staticMethod</span>()</span><br></pre></td></tr></table></figure><h3 id="继承内置类">继承内置类</h3><p>让我们的类继承内置类，比如：Array</p><p>这样我们就可以得到Array的方法了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span>&#123;</span><br><span class="line">  <span class="title function_">firstItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">lastItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">firstItem</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>([<span class="number">33</span>])) <span class="comment">// MyArray(4) [ 1, 2, 3, 33 ]</span></span><br></pre></td></tr></table></figure><h3 id="类的混入-少用">类的混入(少用)</h3><p>JavaScript 的类只支持单继承，也就是只能有一个父类</p><p>如果想在一个类中添加更多相似的功能时，可以使用混入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数去继承一些公共方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixinRunner</span>(<span class="params">BaseClass</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">NewClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am running~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewClass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixinEater</span>(<span class="params">BaseClass</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">NewClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am eating~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewClass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var NewStudent = mixinRunner(Student) // 返回一个已经继承了run方法的新的类</span></span><br><span class="line"><span class="comment">// 在继承了run的基础上继续继承eat</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NewStudent</span> = <span class="title function_">mixinEater</span>(<span class="title function_">mixinRunner</span>(<span class="title class_">Student</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">NewStudent</span>()</span><br><span class="line">stu.<span class="title function_">running</span>()</span><br><span class="line">stu.<span class="title function_">eating</span>() </span><br></pre></td></tr></table></figure><h3 id="JavaScript中的多态">JavaScript中的多态</h3><blockquote><p>维基百科：多态（英语：polymorphism）指为不同数据类型的实体提供统一的接口，或使用一 个单一的符号来表示多个不同的类型</p><p>总结：不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现</p><p>所以说，JS也是有多态的，虽然跟别的一些面向对象语言有些区别</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calcArea</span>(<span class="params">foo</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">getArea</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;sfr&quot;</span>,</span><br><span class="line">  <span class="attr">getArea</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">calcArea</span>(obj1)</span><br><span class="line"><span class="title function_">calcArea</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下也是多态的体现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>) <span class="comment">// 不同数据类型，不同形态</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;asf&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="ES6转ES5">ES6转ES5</h3><blockquote><p>可以在 <a href="http://babeljs.io">babeljs.io</a> 中看es6通过babel转es5后的代码</p><p>有点难度，不要浮躁，慢慢看</p><p>可以打 debug 一点点看</p></blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel转换</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_classCallCheck</span>(<span class="params">instance, Constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> <span class="title class_">Constructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target: Person.prototype</span></span><br><span class="line"><span class="comment">// props: [&#123;key, value&#125;]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_defineProperties</span>(<span class="params">target, props</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">    descriptor.<span class="property">enumerable</span> = descriptor.<span class="property">enumerable</span> || <span class="literal">false</span>;</span><br><span class="line">    descriptor.<span class="property">configurable</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> descriptor) descriptor.<span class="property">writable</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, descriptor.<span class="property">key</span>, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor: Person</span></span><br><span class="line"><span class="comment">// protoProps: [&#123;key, value&#125;]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (protoProps) </span><br><span class="line">    <span class="title function_">_defineProperties</span>(<span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>, protoProps);</span><br><span class="line">  <span class="keyword">if</span> (staticProps) </span><br><span class="line">    <span class="title function_">_defineProperties</span>(<span class="title class_">Constructor</span>, staticProps);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Constructor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /*#__PURE__*/ 纯函数</span></span><br><span class="line"><span class="comment">// webpack 压缩 tree-shaking</span></span><br><span class="line"><span class="comment">// 这个函数没副作用</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = <span class="comment">/*#__PURE__*/</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_createClass</span>(<span class="title class_">Person</span>, [&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;eating&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Person</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Vuex</title>
      <link href="/2022/04/07/%E5%AD%A6%E4%B9%A0Vuex/"/>
      <url>/2022/04/07/%E5%AD%A6%E4%B9%A0Vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="Vuex的状态管理">Vuex的状态管理</h2><h3 id="vuex介绍">vuex介绍</h3><ul><li><p>什么是状态管理？</p><p>应用程序的各种数据保存到某个位置进行管理</p></li></ul><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a797ec53c22b488b8b169c6c80daab85~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>​ state：数据view：最终模块渲染成DOMactions：修改state的行为事件</p><ul><li><p>复杂的状态管理</p><p>多个组件共享状态</p></li><li><p>Vuex的状态管理</p><p>将组件的内部状态抽离出来</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a54e89c5272448eb9c1850ee729526cb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li><li><p>Vuex使用单一状态树</p><p>SSOT：Single Source of Truth，单一数据源</p><p>每个应用仅仅包含一个store实例</p></li></ul><h4 id="安装">安装</h4><p><code>npm install vuex@next</code></p><p>使用vuex4.x，需要添加next指定版本</p><h4 id="使用">使用</h4><h4 id="创建store（仓库）">创建store（仓库）</h4><ul><li><p>Vuex和单纯的全局对象有什么区别呢？</p><p>Vuex的状态存储是响应式的</p></li><li><p>不能直接改变store中的状态</p><p>改变store中的状态的唯一途径就是<strong>提交(commit) mutation</strong></p><p>这样方便我们跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态</p></li><li><p>具体步骤：</p><ol><li>store/index</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的store实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span> <span class="comment">// 数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; <span class="comment">// 方法</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">       state.<span class="property">counter</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">       state.<span class="property">counter</span>--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><ol start="2"><li>在全局将 store 实例作为插件安装</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(store).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件中使用store">组件中使用store</h3><h3 id="state">state</h3><p>使用store中的state数据</p><ul><li><p>在模板中使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在options api 中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">counter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在setup中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">const</span> counter = store.<span class="property">state</span>.<span class="property">counter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="mapState">mapState</h4><p>如果需要拿state中的多个数据，在可以借助辅助函数 mapState，</p><ul><li><p>setup中使用mapState</p><p>默认情况下，Vuex没有提供非常方便的的使用mapState的方式，所以我们进行了一个函数的封装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;sCounter&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState, useStore &#125; from &quot;vuex&quot;</span><br><span class="line">import &#123; computed &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  // options api使用mapState</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // fullName: function() &#123; return xxx&#125;, </span><br><span class="line">    ...mapState([&quot;counter&quot;, &quot;name&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const store = useStore()</span><br><span class="line">    const sCounter = computed(() =&gt; store.state.counter)</span><br><span class="line"></span><br><span class="line">    // 实际上放入mapState这里拿到的是这样形式的一个个函数</span><br><span class="line">    // &#123;counter: function(), name: function() ...&#125;</span><br><span class="line">    const storeStateFns = mapState([&quot;counter&quot;, &quot;name&quot;, &quot;age&quot;, &quot;height&quot;])</span><br><span class="line">    </span><br><span class="line">    // 封装一个函数转化一下,主要思想是把这一个个的函数放到computed里面</span><br><span class="line">    // 因为computed就是传入一个函数，然后会给我们返回一个ref</span><br><span class="line">    // &#123;counter: ref, age: ref, ...&#125;</span><br><span class="line">    const storeState = &#123;&#125;</span><br><span class="line">    Object.keys(storeStateFns).forEach(fnKey =&gt; &#123;</span><br><span class="line">      // 因为内部的computed取数据的时候是通过this.$store...</span><br><span class="line">      // 但我们这里的fn没有this, undefined.$store 是错的</span><br><span class="line">      // 用bind给每个函数绑定this为一个对象,里面需要有$store这个属性</span><br><span class="line">      // &#123;$store: store&#125;</span><br><span class="line">      const fn = storeStateFns[fnKey].bind(&#123; $store: store&#125;)</span><br><span class="line">      // 然后把函数一个方法computed, 以键值对的方式存储起来</span><br><span class="line">      storeState[fnKey] = computed(fn)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    return &#123;</span><br><span class="line">      sCounter,</span><br><span class="line">      // 最终在这里用展开运算符展开</span><br><span class="line">      ...storeState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>把函数的封装抽离到 hooks/useState.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取到对应的对象的functions: &#123;name: function, age: function&#125;</span></span><br><span class="line">  <span class="keyword">const</span> storeStateFns = <span class="title function_">mapState</span>(mapper)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数据进行转换</span></span><br><span class="line">  <span class="keyword">const</span> storeState = &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(storeStateFns).<span class="title function_">forEach</span>(<span class="function"><span class="params">fnKey</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = storeStateFns[fnKey].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;)</span><br><span class="line">    storeState[fnKey] = <span class="title function_">computed</span>(fn)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> storeState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在组件使用就会简便很多</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;../hooks/useState&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> storeState = <span class="title function_">useState</span>([<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;height&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当然也可以是对象形式(想要重命名的时候使用)</span></span><br><span class="line">    <span class="keyword">const</span> storeState2 = <span class="title function_">useState</span>(&#123;</span><br><span class="line">      <span class="attr">sCounter</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">counter</span>,</span><br><span class="line">      <span class="attr">sName</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">name</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...storeState,</span><br><span class="line">      ...storeState2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters">getters</h3><ul><li><p>getters 的基本使用</p><p>某些属性可能需要经过变化后才使用，（就像store中的计算属性）</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5234df35d8b42a3a105bf9573c66885~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:70%;" /></li><li><p>getters 第二个参数</p><p>getters可以接收第2个参数getters，使用getters本身的属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="title function_">totalPrice</span>(<span class="params">state, getters</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">books</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pre + cur.<span class="property">count</span> * cur.<span class="property">price</span></span><br><span class="line">    &#125;, <span class="number">0</span>) + <span class="string">&quot; &quot;</span> + getters.<span class="property">myName</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">myName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getters 的返回函数</p><p>getters中的函数本身，可以返回一个函数，那么在使用的地方相当于可以调用这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">totalPrice</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> totalPrice = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> book <span class="keyword">of</span> state.<span class="property">books</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (book.<span class="property">price</span> &lt; price) <span class="keyword">continue</span></span><br><span class="line">            totalPrice += book.<span class="property">count</span> * book.<span class="property">price</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalPrice</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="mapGetters">mapGetters</h4><p>与mapState类似</p><ul><li><p>在setup中使用mapGetters</p><p>封装好的 /useGetters</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore, mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useGetters</span>(<span class="params">mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stateFns = <span class="title function_">mapGetters</span>(mapper)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(stateFns).<span class="title function_">forEach</span>(<span class="function"><span class="params">fnKey</span> =&gt;</span> &#123;</span><br><span class="line">    state[fnKey] = <span class="title function_">computed</span>(stateFns[fnKey].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> storeGetters = <span class="title function_">useGetters</span>([<span class="string">&quot;nameInfo&quot;</span>, <span class="string">&quot;ageInfo&quot;</span>, <span class="string">&quot;heightInfo&quot;</span>])</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...storeGetters</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="封装useMapper">封装useMapper</h3><p>我们发现前面 useState，useGetters的逻辑大部分相同，所以我们可以封装一个新的函数，根据使用的时候的 mapState还是mapGetters 来调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mapFn:使用的mapXXX</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMapper</span>(<span class="params">mapper, mapFn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> storeStateFns = <span class="title function_">mapFn</span>(mapper)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> storeState = &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(storeStateFns).<span class="title function_">forEach</span>(<span class="function"><span class="params">fnKey</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = storeStateFns[fnKey].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;)</span><br><span class="line">    storeState[fnKey] = <span class="title function_">computed</span>(fn)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> storeState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f546da191e74eb8928f81fab5c259b7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><h3 id="Mutations">Mutations</h3><p>更改 Vuex 的store中的状态的唯一方法是提交mutation</p><ul><li><p>mutations 基本使用</p><p>在store中定义方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">counter</span>++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">counter</span>--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setup中commit事件，提交的是mutations中的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    store.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>, xxx) <span class="comment">// 可以传参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutation携带数据</p><p>很多时候提交mutation会携带一些数据，在mutation中第二个参数可以接收</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addNumber</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span> += payload</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload也可以是对象类型</p><p>提交的时候：可以用type，指定提交的方法名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.<span class="title function_">commit</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;addNumber&quot;</span>,</span><br><span class="line">    <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addNumber</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span> += payload.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutation 常量类型</p><p>主要是预防粗心的时候，commit的方法名字和mutation定义的方法名不一致</p><ul><li><p>定义常量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INCREMENT_N</span> = <span class="string">&quot;INCREMENT_N&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>store中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">INCREMENT_N</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/mutation-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;...&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    [<span class="variable constant_">INCREMENT_N</span>](state, payload) &#123;</span><br><span class="line">      state.<span class="property">counter</span> += payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>组件中提交事件的时候使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">INCREMENT_N</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/mutation-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      store.<span class="title function_">commit</span>(<span class="variable constant_">INCREMENT_N</span>, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>mutation重要原则</p><p>mutation 必须是同步函数</p><ul><li>这是因为devtool工具会记录mutation的日记</li><li>每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照</li><li>但是在mutation中执行异步操作，就无法追踪到数据的变化</li><li>所以Vuex的重要原则中要求 mutation必须是同步函数；</li></ul></li></ul><h4 id="mapMutations">mapMutations</h4><p>我们也可以借助于辅助函数，帮助我们快速映射到对应的方法中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = <span class="title function_">mapMutations</span>([<span class="string">&quot;increment&quot;</span>, <span class="string">&quot;decrement&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> mutations2 = <span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">    <span class="attr">addNumber</span>: <span class="variable constant_">ADD_NUMBER</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="actions">actions</h3><ul><li><p>action提交mutation</p><ul><li><p>actions 类似于mutations，但是action提交的是mutation，而不是直接变更状态</p></li><li><p>actions 可以包含任意<strong>异步操作</strong></p></li><li><p>actions有一个很重要的参数 <strong>context</strong>，里面有很多属性，我们用的时候除了context.xxx使用，也可以解构出来使用</p></li><li><p>从context获取<strong>commit</strong>方法来提交一个mutation</p></li></ul></li><li><p>actions的分发操作（触发actions中的方法）</p><p>在组件中使用store上的<strong>dispatch</strong>进行分发，并且可以传递参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 1. 可以接收参数</span></span><br><span class="line">    <span class="title function_">incrementAction</span>(<span class="params">context, payload</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(payload)  <span class="comment">// payload为接收到的参数</span></span><br><span class="line">        <span class="comment">// 模拟异步：1s之后再提交事件</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>) <span class="comment">// 提交mutation</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">        <span class="comment">// 2. context 的属性</span></span><br><span class="line">    <span class="title function_">decrementAction</span>(<span class="params">&#123; commit, dispatch, state, rootState, getters, rootGetters &#125;</span>) &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&quot;decrement&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件的setup中</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 分发actions，并携带参数</span></span><br><span class="line">   store.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementAction&quot;</span>, &#123;<span class="attr">count</span>: <span class="number">100</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，也可以以对象的形式进行分发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件的setup中</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="string">&quot;incrementAction&quot;</span>,</span><br><span class="line">     <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="mapActions">mapActions</h4><p>actions 也有对应的辅助函数 mapActions</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样用不行..</span></span><br><span class="line"><span class="keyword">const</span> actions = mapActions[<span class="string">&quot;incrementAction&quot;</span>, <span class="string">&quot;decrementAction&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象写法(重命名)</span></span><br><span class="line"><span class="keyword">const</span> actions2 = <span class="title function_">mapActions</span>(&#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="string">&quot;incrementAction&quot;</span>,</span><br><span class="line">  <span class="attr">sub</span>: <span class="string">&quot;decrementAction&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="actions的异步操作">actions的异步操作</h4><p>actions很多时候是异步的，那么当我们组件派发actions的时候，我们也想收到结果，是请求成功了还是失败了，这时候我们可以在actions对应方法中返回 Promise，并对成功失败做处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">   <span class="title function_">getHomeMultidata</span>(<span class="params">context</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">          context.<span class="title function_">commit</span>(<span class="string">&quot;addBannerData&quot;</span>, res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span>)</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&quot;okok&quot;</span>)</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = store.<span class="title function_">dispatch</span>(<span class="string">&quot;getHomeMultidata&quot;</span>)</span><br><span class="line">    promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="module">module</h3><h4 id="module的基本使用">module的基本使用</h4><p>什么是module？</p><ul><li>由于使用单一状态树，应用的所有状态都集中到一个比较大的对象，当应用变得复杂时，store对象就变得相当臃肿，不利于管理</li><li>所以Vuex允许我们将store分模块</li><li>每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块</li></ul><p>使用：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c755defa77b4c7fa9c8bd2d4a36217c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><ul><li>模块内部的mutation和getter的第一个参数state是模块的局部状态对象</li></ul><h4 id="module的命名空间">module的命名空间</h4><p>默认情况下，模块内部的action，mutation仍然是注册在全局的命名空间中的</p><p>如果希望模块具有更高的封装度和复用性，可以在模块中添加<code>namespaced: true</code></p><p>使模块更独立</p><p>之后，当模块被注册后它的所有getter、action及mutation都会自动根据模块注册的路径调整命名</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/827e0697e09d426699b684bf4bbdc59e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="module修改或派发根组件">module修改或派发根组件</h4><p>{root: true}</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementAction</span>(<span class="params">&#123;commit, dispatch,state&#125;</span>) &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&quot;rootIncrement&quot;</span>, <span class="literal">null</span>, &#123;<span class="attr">root</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="string">&quot;rootIncrementAction&quot;</span>, <span class="literal">null</span>, &#123;<span class="attr">root</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="module的辅助函数">module的辅助函数</h4><p>写法一：通过完整的模块空间名来查找(不是很推荐使用)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="attr">homeCounter</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">home</span>.<span class="property">homeCounter</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...<span class="title function_">mapGetters</span>(&#123;</span><br><span class="line">    <span class="attr">doubleHomeCounter</span>: <span class="string">&quot;home/doubleHomeCounter&quot;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>写法二：第一个参数写模块名，第二个参数写属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">   ...<span class="title function_">mapState</span>(<span class="string">&quot;home&quot;</span>, [<span class="string">&quot;homeCounter&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法三：<code>createNamespacedHelpers</code>辅助函数</p><p>创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapGetters&#125; = <span class="title function_">createNamespacedHelpers</span>(<span class="string">&quot;home&quot;</span>)</span><br><span class="line"></span><br><span class="line">...<span class="title function_">mapState</span>([<span class="string">&quot;homeCounter&quot;</span>])</span><br></pre></td></tr></table></figure><p><strong>setup中使用</strong></p><p>修改之前的 hooks，<strong>useState</strong>，<strong>useGetters</strong>，考虑模块的情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useMapper &#125; <span class="keyword">from</span> <span class="string">&#x27;./useMapper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">moduleName, mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mapperFn = mapState</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> moduleName === <span class="string">&#x27;string&#x27;</span> &amp;&amp; moduleName.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    mapperFn = <span class="title function_">createNamespacedHelpers</span>(moduleName).<span class="property">mapState</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mapper = moduleName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMapper</span>(mapper, mapperFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// useGetters同理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useMapper &#125; <span class="keyword">from</span> <span class="string">&quot;./useMapper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useGetters</span>(<span class="params">moduleName, mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mapperFn = mapGetters</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> moduleName === <span class="string">&#x27;string&#x27;</span> &amp;&amp; moduleName.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    mapperFn = <span class="title function_">createNamespacedHelpers</span>(moduleName).<span class="property">mapGetters</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mapper = moduleName</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMapper</span>(mapper, mapperFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">useState</span>([<span class="string">&quot;rootCounter&quot;</span>])</span><br><span class="line">  <span class="keyword">const</span> rootGetters = <span class="title function_">useGetters</span>([<span class="string">&quot;doubleRootCounter&quot;</span>])</span><br><span class="line">  <span class="keyword">const</span> getters = <span class="title function_">useGetters</span>(<span class="string">&quot;home&quot;</span>, [<span class="string">&quot;doubleHomeCounter&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深入Vue3+Typescript学习⚡ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端人的数据结构与算法之路</title>
      <link href="/2022/04/04/%E5%89%8D%E7%AB%AF%E4%BA%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/04/04/%E5%89%8D%E7%AB%AF%E4%BA%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="学习资料">学习资料</h3><blockquote><ol><li><p>[前端算法与数据结构面试：底层逻辑解读与大厂真题训练]</p><p>链接：<a href="https://juejin.cn/book/6844733800300150797">https://juejin.cn/book/6844733800300150797</a></p><p>大纲：</p></li></ol><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/24/171ac6e4faf30ecf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:67%;" /></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法😥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueRouter</title>
      <link href="/2022/04/04/VueRouter/"/>
      <url>/2022/04/04/VueRouter/</url>
      
        <content type="html"><![CDATA[<p>VueRouter路由使用</p><h3 id="简单的介绍😏">简单的介绍😏</h3><blockquote><p>这一部分了解、理解一下，知道有就行</p></blockquote><p>后端路由阶段：</p><ul><li>服务器渲染好整个页面，并且将页面返回给客户端</li><li>不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化</li><li>不利于维护</li></ul><p>前后端分离阶段：</p><ul><li>后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中</li><li>前后端责任清晰，后端专注于数据上，前端专注于交互和可视化上</li></ul><p>前端路由是如何做到URL和内容进行映射呢？监听URL的改变</p><h4 id="URL的hash">URL的hash</h4><p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性</p><p>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p><p>(页面一旦刷新，又会向服务器发请求)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> contentEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.content&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">switch</span>(location.<span class="property">hash</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">case</span> <span class="string">&quot;#/home&quot;</span>: </span></span><br><span class="line"><span class="language-javascript">                contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;Home&quot;</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">case</span> <span class="string">&quot;#/about&quot;</span>: </span></span><br><span class="line"><span class="language-javascript">                contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;About&quot;</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br></pre></td></tr></table></figure><p>hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2338dd9e294d475d98d18814fc6a9759~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:50%;" /><h4 id="HTML5的History">HTML5的History</h4><p>history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面：</p><p>replaceState：替换原来的路径</p><p>pushState：使用新的路径（压栈）</p><p>popState：路径的回退（弹栈）</p><p>go：向前或向后改变路径 go(1)前进1步，go(2)，前进两步，go(-1)，后退一步</p><p>forward：向前一步</p><p>back：后退一步</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> contentEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.content&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">changeContent</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">switch</span>(location.<span class="property">pathname</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">case</span> <span class="string">&quot;/home&quot;</span>:</span></span><br><span class="line"><span class="language-javascript">        contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;Home&quot;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">case</span> <span class="string">&quot;/about&quot;</span>:</span></span><br><span class="line"><span class="language-javascript">        contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;About&quot;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: </span></span><br><span class="line"><span class="language-javascript">        contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;Default&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> aEls = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> aEl <span class="keyword">of</span> aEls) &#123;</span></span><br><span class="line"><span class="language-javascript">    aEl.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      e.<span class="title function_">preventDefault</span>() <span class="comment">// 阻止默认行为</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> href = aEl.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// history.replaceState(&#123;&#125;, &quot;&quot;, href)</span></span></span><br><span class="line"><span class="language-javascript">      history.<span class="title function_">pushState</span>(&#123;&#125;, <span class="string">&quot;&quot;</span>, href)</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">changeContent</span>()</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, changeContent)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce1fff5aaeb47de851682528df97530~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:50%;" /><h3 id="vue-router📱">vue-router📱</h3><p>Vue Router 是 Vue.js 的官方路由，便于构建单页面应用</p><h4 id="使用vue-router">使用vue-router</h4><ul><li>安装 Vue Router</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><ul><li>路由的使用步骤</li></ul><ol><li><p>创建路由组件</p></li><li><p>配置路由映射、创建路由对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个路由对象router</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 使用路由的模式，hash / history</span></span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>在全局main.js中注册路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">vue.<span class="title function_">use</span>(router)</span><br></pre></td></tr></table></figure></li><li><p>使用路由：<code>&lt;router-link&gt;</code> <code>&lt;router-view&gt;</code></p><p>这种<code>&lt;router-link to&gt;</code>叫 <strong>声明式导航</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="路由重定向">路由重定向</h4><p>对 ‘/’ 这个路径，重定向到’/home’</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">  <span class="comment">// 重定向</span></span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>路由还有其他属性</p><ul><li>name：给某个路由起独一无二的名字</li><li>meta：配置一些参数，被一起带到router对象中</li></ul><h4 id="路由懒加载">路由懒加载</h4><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件</p><p>好处：提高首屏的渲染效率</p><p>实际就是webpack的分包，而Vue Router默认就支持动态来导入组件</p><ul><li>这是因为component可以传入一个组件，也可以接收一个函数，该函数需要返回一个Promise</li><li>而import函数就是返回一个Promise</li></ul><p>不采用直接<code>import Home from '../pages/Home.vue'</code>的方式</p><p>另外还可以对分包命名：<code>/*webpackChunkName: &quot;xxx&quot;*/</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="comment">// 还可以对分包命名</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="comment">/*webpackChunkName: &quot;ahout-chunk&quot; */</span><span class="string">&quot;../pages/About.vue&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>打包后的效果</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd0fdef2422c405388ab51b6a851eabc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="router-link的属性">router-link的属性</h4><ul><li><p>to：字符串（‘/home’）或者对象（配置路径+参数）</p></li><li><p>replace：替代</p><p>设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()</p></li><li><p>active-class属性：可以在这个class加样式啥的</p><p>设置激活a元素后应用的class，默认是router-link-active(一般 不去修改)</p></li><li><p>exact-active-class属性</p><p>链接精准激活时，应用于渲染的  的 class，默认是router-link-exact-active</p><p>在嵌套路由中，例如有一个嵌套路由是：/home/message 那么这个class只会在message那个子路由中</p></li></ul><h4 id="动态路由">动态路由</h4><p>动态，即这个路由的路径是动态改变的</p><p>在Vue Router中，我们可以在路径中使用一个动态字段来实现，我们称之为路径参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:username/id/:id&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/User.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:username? 加？表示可有可无，否则必须有</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82dd5687c9ad49d7932878f443e5319d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" /><p>如何获取动态路由的值？</p><p>在template中：<code>$route.params</code></p><p>在created中：<code>this.$route.params</code></p><p>在setup中：要使用 vue-router库给我们提供的一个hook <strong>useRoute</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 直接调用useRoute()，会返回一个路由对象</span></span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(route);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="NotFound">NotFound</h4><p>对于那些没有匹配到的路由，我们通常会匹配到固定的某个页面</p><p>可编写一个动态路由用于匹配所有的页面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/:pathMath(.*)&#x27;</span>, <span class="comment">// 用到正则 .*匹配任意字符0或多个</span></span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/NotFound.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>$route.params.pathMath</code>获取传入的参数</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ad95ddeb9fd4b9fbf2cf6d647adb023~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>还有一种写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/:pathMath(.*)*&#x27;</span> <span class="comment">// 这里多加一个*</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/NotFound.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别在于解析的时候，是否解析 /：</p><p>把路径中的/…/ 分成一个个的</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7701324e163b43c9a42c24b89deefe4f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="路由的嵌套">路由的嵌套</h4><p>某个路由页面本身也存在路由的来回切换</p><p>配置子路由，同样在home中使用router-link,router-view</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>),</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>, <span class="comment">// 这里不需要/</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Message.vue&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;goods&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Goods.vue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编程式路由">编程式路由</h4><p>不通过router-link的方式实现跳转，比如点击的是一个按钮等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取router对象</span></span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">gotoMessage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/home/message&#x27;</span>) <span class="comment">// 可以直接传字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">gotoGoods</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home/goods&#x27;</span> <span class="comment">// 也可以是对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有 router.replace、router.go、back、forward</p><p>vue2中：<code>this.$router.push</code></p><h4 id="query-查询-方式的参数">query(查询)方式的参数</h4><p>传递query参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home/goods&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在对应页面中获取query参数：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;---&#123;&#123;$route.query.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="router-link的v-slot">router-link的v-slot</h4><blockquote><p>用到查文档就好</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-slot可以拿到router-link给我们传递过来的属性(可以自己命名 props)</span></span><br><span class="line"><span class="comment">custom:表示自定义router-link，外部不会给我们包裹a元素了</span></span><br><span class="line"><span class="comment">props.navigate：所以当我们想点击某个元素跳转的时候可以使用navigate(当然用编程式导航也是可以的)</span></span><br><span class="line"><span class="comment">props.route：路由对象</span></span><br><span class="line"><span class="comment">props.href: 解析后的url</span></span><br><span class="line"><span class="comment">props: isActive 是否当前处于活跃的状态 (true,false)</span></span><br><span class="line"><span class="comment">props: isExactActive 是否当前处于精确的活跃状态 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;props&quot;</span> <span class="attr">custom</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>href: &#123;&#123;props.href&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;props.navigate&quot;</span>&gt;</span>跳转home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;props.route&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: props.isActive&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: props.isActive&#125;&quot;</span>&gt;</span>&#123;&#123;props.isExactActive&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="router-view的v-slot">router-view的v-slot</h4><p>router-view也提供给我们一个插槽，可以用于<code>&lt;transition&gt;</code>和<code>&lt;keep-alive&gt;</code>组件来包裹你的路由组件（用于加动画，缓存）</p><p>Component：要渲染的组件</p><p>route：解析出的标准化路由对象</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以拿到router-view给我们传过来的组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;props.Component&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="动态添加路由">动态添加路由</h4><p>比如说我们要根据不同的权限来决定是否添加路由</p><p>路由对象router上有方法：addRoute()动态添加路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义要添加的动态路由（可以先定义</span></span><br><span class="line"><span class="keyword">const</span> momentRoute = &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/moment&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/HomeMoment.vue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">router.<span class="title function_">addRoute</span>(momentRoute)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加的时候作为addRoute的第二个参数）</span></span><br><span class="line"><span class="comment">// 给home动态添加子路由cart 路径:/home/cart</span></span><br><span class="line">router.<span class="title function_">addRoute</span>(<span class="string">&#x27;home&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;cart&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Cart.vue&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="动态删除路由">动态删除路由</h4><p>三种方式：</p><ul><li>添加一个同名路由，相当于覆盖</li><li>通过removeRoute方法，传入路由的名称</li><li>通过addRoute方法的返回值回调</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span>&#125;)</span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">router.<span class="title function_">addRoute</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/other&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Other</span>&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">router.<span class="title function_">removeRoute</span>(<span class="string">&#x27;about&#x27;</span>)</span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line"><span class="keyword">const</span> removeRoute = router.<span class="title function_">addRoute</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span>&#125;)</span><br><span class="line"><span class="title function_">removeRoute</span>()</span><br></pre></td></tr></table></figure><p><strong>路由其他方法补充</strong></p><ul><li>router.hasRoute()：检查路由是否存在。</li><li>router.getRoutes()：获取一个包含所有路由记录的数组</li></ul><h3 id="路由导航守卫👮">路由导航守卫👮</h3><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p><h4 id="全局前置守卫beforeEach">全局前置守卫beforeEach</h4><p>在导航触发时会被回调</p><p>它有两个参数：</p><ul><li>to：即将进入的路由对象</li><li>from：即将离开的Route对象</li></ul><p>返回值：</p><ul><li>false：取消当前导航</li><li>不返回或者返回undefined：进行默认导航</li><li>返回一个路由地址：<ul><li>路径字符串：‘/home’</li><li>对象：类似于 router.push({path: “/login”, query: …})</li></ul></li></ul><p>小案例：如果没登录就跳转到登录页面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> !== <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(!token) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><blockquote><p>更多导航守卫看官网</p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p></blockquote><p><strong>完整的导航解析流程</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1054c2d5ce484b73bb273502b22db54b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="其他补充-2">其他补充</h3><h4 id="historyApiFallback">historyApiFallback</h4><p>开发中一个非常常见的属性，主要作用是解决SPA页面在路由跳转之后，进行页面刷新时，返回404的错误</p><p>如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容</p><blockquote><p>因为我们使用的是前端路由，刷新页面时访问的资源在服务端找不到，因为vue-router设置的路径不是真实存在的路径。</p></blockquote><blockquote><p>注：我们使用 vue-cli的时候，默认已经帮我们设置为true了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback">https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深入Vue3+Typescript学习⚡ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔✍</title>
      <link href="/2022/04/03/%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/04/03/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p>待完善…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于JS数据类型</title>
      <link href="/2022/04/03/%E5%85%B3%E4%BA%8EJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/04/03/%E5%85%B3%E4%BA%8EJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="JS-数据类型转换">JS 数据类型转换</h3><p>类型转换可以分为两种：<strong>隐式类型转换</strong> 和 <strong>显式类型转换</strong></p><p><strong>显式</strong>：比如 Number(value) String(value) …</p><p><strong>隐式</strong>：对不同类型的值使用运算符时，值可以自动转换，比如 1 == null</p><p>我们需要知道：在 JS 中只有3中类型的转换：转换为 Number，String，Boolean类型</p><p>所以我们只需要弄清楚在什么场景下应该转成哪种类型就可以了</p><h4 id="转换为boolean"><strong>转换为boolean</strong></h4><p><strong>显式</strong>：<code>Boolean() </code>方法可以直接用来将值转换成布尔型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>隐式</strong>：通常在逻辑判断或者有逻辑运算符时被触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">2</span>) &#123;&#125; <span class="comment">// 逻辑判断</span></span><br><span class="line">!!<span class="number">2</span> <span class="comment">// 逻辑运算</span></span><br><span class="line"><span class="number">2</span> || <span class="string">&#x27;hello&#x27;</span> <span class="comment">// 逻辑运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="string">&#x27;hello&#x27;</span> &amp;&amp; <span class="number">123</span> <span class="comment">// x === 123</span></span><br><span class="line"><span class="comment">// 逻辑运算符（比如 || 和 &amp;&amp;）是在内部做了 boolean 类型转换，但实际上返回的是原始操作数的值</span></span><br></pre></td></tr></table></figure><p>boolean类型转换只有 true，false两种结果。</p><p>除了 <strong>0、NaN、空字符串、null、undefined</strong>五个值是false，其余都是true</p><blockquote><p>额外补充：</p><p>逻辑或 ||：一真为真，a || b，只要a为真就返回a的执行结果，b不执行；a为假则执行b，并返回b执行后的结果</p><p>逻辑与 &amp;&amp;：一假为假，a &amp;&amp; b，只要a为假就返回a的执行结果，b不执行；a为真则执行b，并返回b执行后的结果</p></blockquote><h4 id="转换为为string">转换为为string</h4><ul><li>显式：<code>String() </code>方法可以用来显式将值转为字符串。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"><span class="title class_">String</span>(&#123;&#125;) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>隐式：隐式转换通常在有 <code>+</code> 运算符并且只是至少有一个操作数是 string 类型时被触发，即字符串拼接</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;123&#x27;</span>  <span class="comment">//&quot;1123&quot; </span></span><br><span class="line"><span class="number">1</span> + &#123;&#125; <span class="comment">// &#x27;1[object Object]&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">null</span> <span class="comment">// &#x27;1null&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型]</p></li><li><p>null 与字符串拼接时null直接转为 ‘null’ (内部的实现)</p></li></ul></blockquote><h4 id="转换为number">转换为number</h4><p><strong>显式</strong>：<code>Number()</code>方法可以用来显式将值转换成数字类型</p><ul><li>字符串转换为数字：空字符串变为0，如果出现任何一个非有效数字字符，结果都是NaN</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)           <span class="comment">//0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;10px&quot;</span>)       <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;10&quot;</span>)         <span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>布尔转换为数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>null 和 undefined 转换成数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><ul><li>Symbol无法转换为数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="title class_">Symbol</span>()) <span class="comment">// Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><ul><li>BigInt</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="title class_">BigInt</span>(<span class="number">10</span>)) <span class="comment">// 10</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="number">10n</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p><strong><code>BigInt</code></strong> 是一种内置对象，它提供了一种方法来表示大于 <code>2^53 - 1</code> 的整数。<strong><code>BigInt</code></strong> 可以表示任意大的整数。</p><p>可以用在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>BigInt</code> ，如：<code>10n</code>，或者调用函数 <code>BigInt()</code>（但不包含 <code>new</code> 运算符）并传递一个整数值或字符串值,如<code>BigInt(10)</code></p></blockquote><ul><li>对象转换为数字，会按照下面的步骤执行</li></ul><ol><li><p>先调用对象的 <code>Symbol.toPrimitive</code> 这个方法，如果不存在这个方法</p><blockquote><p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive</a></p></blockquote></li><li><p>再调用对象的 <code>valueOf()</code> 获取原始值，如果获取的值依然不是数字</p><blockquote><p><code>valueOf()</code> 方法返回指定对象的原始值。</p></blockquote></li><li><p>再调用对象的 <code>toString()</code> 把其变为字符串</p><blockquote><p>把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型]</p></blockquote></li><li><p>最后再把字符串基于<code>Number()</code>方法转换为数字</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj-<span class="number">10</span>) <span class="comment">// 数学运算：先把obj隐式转换为数字，再进行运算</span></span><br><span class="line"><span class="comment">//运行机制</span></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] <span class="comment">//undifined </span></span><br><span class="line">obj.<span class="title function_">valueof</span>() <span class="comment">// &#123;name:xxx&#125;</span></span><br><span class="line">obj.<span class="title function_">toString</span>() <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">Number</span> (<span class="string">&quot;[object object]&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span>-<span class="number">10</span> <span class="comment">// NaN </span></span><br></pre></td></tr></table></figure><p><strong>隐式</strong></p><p>number 的隐式类型转换是比较复杂的，因为它可以在下面多种情况下被触发</p><ul><li><p>比较操作（&gt;, &lt;, &lt;=, &gt;=）</p></li><li><p>按位操作（| &amp; ^ ~）</p></li><li><p>算数操作（- + * / %），</p><p><strong>注意</strong>：当 <code>+</code>存在任意的操作数是 string 类型时，转换到string类型为止，不会触发 number 类型的隐式转换</p></li><li><p>一元 + 操作</p><blockquote><p>一元就是只有一个操作数，+5    +[]</p><p>+[]  --&gt; 0 相当于Number([])</p><p>+{} --&gt; NaN  相当于String({})=‘[object,Object]’；Number(‘[object,Object]’) --&gt;NaN</p></blockquote></li></ul><p><strong>需要注意的情况</strong></p><blockquote><p>javascript中加法会触发3种类型转换，即将值转换为原始值，转换为字符串，转换为数字。这刚好对应了javascript引擎内部的转换操作：ToPrimitive(),toString(),toNumber()</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + [] === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">[] + &#123;&#125; === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125; + []，对于编译器来说,&#123;&#125;在开头，被解析成代码块，不会返回任何值</span></span><br><span class="line"><span class="comment">// 所以&#123;&#125; + []实际上就是 +[]</span></span><br><span class="line"><span class="comment">// []通过ToPrimitive(),toString() 变成 &quot;&quot;</span></span><br><span class="line"><span class="comment">// 最后 toNumber() --&gt; 0</span></span><br><span class="line"></span><br><span class="line">[] + &#123;&#125; <span class="comment">// 这里&#123;&#125;就是一个对象</span></span><br><span class="line"><span class="comment">// String([])=&#x27;&#x27; String(&#123;&#125;)=&#x27;[object Object]&#x27; </span></span><br><span class="line"><span class="comment">// 有string类型不会触发number转换了,两边都是string直接拼接</span></span><br><span class="line"><span class="comment">// 所以 &#x27;&#x27; + &#x27;[object Object]&#x27; --&gt; &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>操作符 == 两边的隐式转换</strong></p><p>如果两边的数据类型不同，需要先转为相同类型再进行比较</p><ul><li>对象 == 字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] == <span class="string">&#x27;1,2,3&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 转为字符串</span></span><br><span class="line"><span class="comment">// [1,2,3].toString() --&gt; &#x27;1,2,3&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;helo&#x27;</span>&#125; == <span class="string">&quot;&#123;name:&#x27;helo&#x27;&#125;&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// &#123;name:&#x27;helo&#x27;&#125;.valueOf().toString() --&gt; &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>null/ undefined</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">//null/undefined和其他任何值都不相等</span></span><br></pre></td></tr></table></figure><ul><li>对象 == 对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == &#123;&#125; <span class="comment">// false 比较的是堆内存地址，地址相同才相等</span></span><br></pre></td></tr></table></figure><ul><li>NaN</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> == xxx  都是<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>除了以上的四种情况，只要两边类型不一致，都是转换为数字再进行比较</p><p>最后，看题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">100</span> + <span class="literal">true</span> + <span class="number">21.2</span> + <span class="literal">null</span> + <span class="literal">undefined</span> + <span class="string">&quot;Tencent&quot;</span> + [] + <span class="literal">null</span> + <span class="number">9</span> + <span class="literal">false</span></span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd196b1f2e24fae861c5137e543c817~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>参考资料：</p><blockquote><p><a href="https://juejin.cn/post/6956170676327677966">https://juejin.cn/post/6956170676327677966</a></p></blockquote><h3 id="数据类型的判断">数据类型的判断</h3><blockquote><p><a href="https://juejin.cn/post/7061588533214969892#heading-29">https://juejin.cn/post/7061588533214969892#heading-29</a></p><p>把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型]</p><p>Object.prototype.toString.call() 有显式绑定，</p><p>因此 Object.prototype.toString.call(xxx)就是 找到xxx中的toString方法，输出的对象的类型就是根据xxx来的</p></blockquote><h3 id="神奇的加法">神奇的加法</h3><blockquote><p><a href="https://blog.csdn.net/dk2290/article/details/86534595">https://blog.csdn.net/dk2290/article/details/86534595</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08_JS面向对象</title>
      <link href="/2022/04/02/08-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/04/02/08-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="深入JS面向对象">深入JS面向对象</h2><h2 id="面向对象初识">面向对象初识</h2><h2 id="创建对象的方式">创建对象的方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：通过new Object()创建</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;hill&quot;</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">obj.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：字面量形式</span></span><br><span class="line"><span class="keyword">var</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hill&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">eating</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对属性的操作">对属性的操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yuzi&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.获取属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// yuzi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给属性赋值</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;jackson&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// jackson</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除属性</span></span><br><span class="line"><span class="comment">// delete obj.name</span></span><br><span class="line"><span class="comment">// console.log(obj); // &#123;age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.遍历属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种直接定义在对象内部或者直接添加到对象内部的属性，我们不能对其做出限制：比如这个属性是否可以通过delete删除，是否可以在for-in遍历的时候被遍历出来</p><h2 id="Object-defineProperty">Object.defineProperty()</h2><ul><li><p>如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符</p><ul><li><p>通过属性描述符可以精准的添加或修改对象的属性</p></li><li><p>属性描述符需要使用 Object.defineProperty 来对属性进行添加或修改</p></li></ul></li><li><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p></li><li><p>接收三个参数</p><ul><li>obj:要定义属性的对象</li><li>prop: 要定义或修改的属性的名称或Symbol</li><li>descriptor：要定义或修改的属性描述符</li></ul></li><li><p>第三个参数的属性描述符分为两类：</p><ul><li>数据属性描述符<br>configurable，enumerable，writable，value</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接在一个对象上定义某个属性时，描述符的默认值为</span></span><br><span class="line"><span class="comment">// value: 赋值的value</span></span><br><span class="line"><span class="comment">// configurable: true</span></span><br><span class="line"><span class="comment">// enumerable: true</span></span><br><span class="line"><span class="comment">// writable: true</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;height&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1.88</span>, <span class="comment">// 属性值(默认为 undefined)</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,  <span class="comment">// 对应属性是否可以枚举(默认为false)</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以修改属性值(默认为false)</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 属性能否被删除(默认为false),属性的描述符能否被改变</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name age height 可枚举</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;height&#x27; ] 可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性值</span></span><br><span class="line">obj.<span class="property">height</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">height</span>); <span class="comment">// 2 可修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">height</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">height</span>); <span class="comment">// undefined 删除成功</span></span><br></pre></td></tr></table></figure><ul><li><p>存取属性描述符<br>enumerable，configurable，get，set</p><p>不用value,writable，而是用 get,set</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">_address</span>: <span class="string">&quot;广东&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有属性，js里面是没有严格意义的私有属性的，所以我们实际上也能直接访问，但是在社区人们约定 下划线_开头的属性定义为私有属性</span></span><br><span class="line"><span class="comment">// 1.隐藏某一个私有属性(address)不希望直接被外界使用和赋值</span></span><br><span class="line"><span class="comment">// 2.如果我们希望截获某个属性被访问和设置值的过程时，也会使用存储属性描述符</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;address&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可删除，可修改描述符</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取了一次address的值&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_address</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;设置了address的值&quot;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_address</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">address</span>); <span class="comment">// 广东</span></span><br></pre></td></tr></table></figure></li></ul><p>可枚举属性的补充</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;address&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;北京市&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// address属性默认是不可枚举的，但是我们在浏览器上面是可以看到的（稍微浅色一点），这是浏览器为了方便我们调试做的处理</span></span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fca538eddaf4ec39491455e819979ef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h2 id="Object-defineProperties">Object.defineProperties()</h2><p><strong>Object.defineProperties()</strong> 方法可以直接在一个对象上定义多个新的属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">_age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;jackson&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对象方法补充(了解)</p><ul><li>获取对象的属性描述符<ul><li>getOwnPropertyDescriptor</li><li>getOwnPropertyDescriptors</li></ul></li><li>禁止对象扩展新属性<ul><li>preventExtensions：给一个对象添加新的属性会失败(在严格模式下会报错)</li></ul></li><li>密封对象，不允许配置和删除属性：seal<ul><li>实际是调用preventExtensions</li><li>并且将现有属性的configurable:false</li></ul></li><li>冻结对象，不允许修改现有属性：freeze<ul><li>实际上是调用seal</li><li>并且将现有属性的writable: false</li></ul></li></ul><h2 id="创建多个对象的方式">创建多个对象的方式</h2><blockquote><p>通过想要创建多个对象的目的，来引出后面的构造函数</p></blockquote><p>前面我们通过 new Object，字面量的方式创建对象，但是这两种方式有一个很大的弊端：</p><p>创建同样的对象时，需要编写重复代码</p><p>比如说字面量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = &#123;<span class="attr">name</span>: , <span class="attr">age</span>: &#125;</span><br><span class="line"><span class="keyword">var</span> p2 = &#123;<span class="attr">name</span>: , <span class="attr">age</span>: &#125;</span><br><span class="line"><span class="keyword">var</span> p3 = &#123;<span class="attr">name</span>: , <span class="attr">age</span>: &#125; <span class="comment">// 它们有同样的属性或者方法</span></span><br></pre></td></tr></table></figure><h3 id="创建对象的方式-工厂模式">创建对象的方式 - 工厂模式</h3><ul><li>工厂模式其实是一种常见的设计模式</li><li>通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象</li><li>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</li><li>但是从某些角度来说，这些对象应该有一个他们共同的类型</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = &#123;&#125; <span class="comment">// 定义一个对象</span></span><br><span class="line">  p.<span class="property">name</span> = name</span><br><span class="line">  p.<span class="property">age</span> = age</span><br><span class="line">  p.<span class="property">height</span> = height</span><br><span class="line"></span><br><span class="line">  p.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p <span class="comment">// 把对象返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">createPerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>, <span class="number">1.98</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="title function_">createPerson</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>, <span class="number">1.78</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式的缺点：获取不到对象最真实的类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p2, p3); <span class="comment">// 我只知道你是一个对象，但我不知道你是person类型</span></span><br></pre></td></tr></table></figure><h3 id="认识构造函数">认识构造函数</h3><h4 id="什么是构造函数？">什么是构造函数？</h4><ul><li>构造函数也称之为构造器（constructor），通常我们在创建对象时会调用的函数</li><li>JavaScript 中，如果一个普通的函数被使用 new 操作符来调用了，那么这个函数就称之为是一个构造函数</li></ul><blockquote><p>所以说构造函数也是一个普通函数，只不过用 new 去调用，就称为构造函数</p><p>new也是可以调用函数的喔</p></blockquote><h4 id="new操作符">new操作符</h4><p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p><ol><li>在内存中创建一个新的对象（空对象）</li><li>这个对象内部的 **[[prototype]]**属性会被赋值为该构造函数的 <strong>prototype</strong>属性</li><li>构造函数的 this ，会指向创建出来的新对象</li><li>执行函数的内部代码</li><li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li></ol><h4 id="构造函数创建对象">构造函数创建对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规范：构造函数的首字母一般是大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, height, address</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">address</span> = address</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is running&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>, <span class="string">&#x27;广州&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>, <span class="number">1.78</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// Person &#123;...&#125; 是可以看见类型的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure><ul><li>这个构造函数可以确保我们的对象是有Person的类型的</li><li>但是也有缺点：我们需要给每个对象的函数去创建一个函数对象实例（开辟新的内存空间）</li></ul><h3 id="对象的原型-prototype">对象的原型 [[prototype]]</h3><ul><li><p>JavaScript 中，每个对象都有一个特殊的内置属性 <strong>[[prototype]]</strong>，这个属性称之为对象的原型（隐式原型）（只要是对象，就会有这个内置属性）</p></li><li><p>[[prototype]] 指向一个对象（也就是说它也是一个对象）</p></li><li><p>那么这个对象有什么用呢？</p><ul><li>当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作</li><li>这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它</li><li>如果对象中没有该属性， 那么会沿着它的原型去查找 [[prototype]]</li></ul></li><li><p>如果通过字面量直接创建一个对象，那么这个对象也有[[prototype]]这个属性</p><p>如何查看这个属性呢</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> info = &#123;&#125;</span><br><span class="line"><span class="comment">// 创建出来的对象上都有 [[prototype]]属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何查看这个属性？</span></span><br><span class="line"><span class="comment">// 早期的ECMA是没有规范如何去查看 [[prototype]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象中提供了一个属性 __proto__, 可以让我们查看一下这个原型对象(浏览器提供)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);<span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于(伪代码)</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>, <span class="attr">__proto__</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5之后提供的Object.getPrototypeOf()查看</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如找 age 这个属性，该对象本身没有，沿着原型查找</span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数的原型-prototype">函数的原型 prototype</h3><ul><li>所有的函数都有一个 prototype 属性（显式原型）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数也是一个对象，所以它也是有[[prototype]]隐式属性</span></span><br><span class="line"><span class="comment">// 另外，函数还会多出来一个显式原型属性：prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br></pre></td></tr></table></figure><ul><li><p>再看回new操作符其中的一个步骤：</p><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性</p></li><li><p>也就意味着我们通过 Foo 构造函数创建出的所有对象的 [[prototype]] 都指向 Foo.prototype</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>创建对象的内存表现</strong></p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70022f5ae6854d12aad1feb4059f06af~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>可以看到：</p><ul><li>构造函数的 prototype 属性指向该函数的原型对象</li><li>原型对象身上有一个 constructor 属性指回构造函数本身</li><li>new出来的实例对象 p1，p2 对象身上有<code> __proto__</code>属性也指向构造函数的原型对象</li></ul><h3 id="函数原型上的属性constructor">函数原型上的属性constructor</h3><ul><li>默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. constructor属性</span></span><br><span class="line"><span class="comment">// Foo.prototype这个对象中有一个constructor属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123;&#125; 为什么没看到constructor？</span></span><br><span class="line"><span class="comment">// 那换一种方式看</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>));</span><br><span class="line"><span class="comment">//打印 </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: &#123;</span></span><br><span class="line"><span class="comment">//     value: [Function: Foo],</span></span><br><span class="line"><span class="comment">//     writable: true,        </span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 可以看到enumerable为false，所以第一种方式不能看到constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然这样，我们能不能重写这个对象的属性constructor呢？肯定可以呀</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//可枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可删除，描述符可修改</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 可写</span></span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hahahha&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这个时候我们再来直接打印，就可以看到constructor了(被我们改成可枚举了)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// &#123; constructor: &#x27;hahahha&#x27; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>我们也可以在prototype上添加自己的属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;jackson&quot;</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再new对象的时候，这些属性都可以通过实例的原型__proto__找到</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">name</span>); <span class="comment">// jackson</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: &#x27;hahahha&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;jackson&#x27;,</span></span><br><span class="line"><span class="comment">//   age: 18,</span></span><br><span class="line"><span class="comment">//   eating: [Function (anonymous)]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bf25777e8f4d79acf69ac0f18ee3ef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><ul><li>直接修改整个prototype对象（赋值，新开内存空间）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Foo</span>, <span class="comment">// 让它指回本身(但这样它默认是可枚举的)</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">name</span>); <span class="comment">// &quot;jackson&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了可以自定属性描述符,真实开发中我们可以通过Object.defineProperty添加constructor</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Foo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af35cbd1ec241cdba0a2f6059dfc55d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>原来的foo函数的原型对象因为没有对它的引用，会被回收的</p><h3 id="创建对象的方式-—-构造函数和原型组合">创建对象的方式 — 构造函数和原型组合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, address</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">address</span> = address</span><br><span class="line">  <span class="comment">// this.fn = function()</span></span><br><span class="line">  <span class="comment">// 为了不给每个实例都新开内存空间保存相同的方法，我们不把共同的方法定义在这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以把一些公共的方法直接通过原型对象添加</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is eating&#x27;</span>);</span><br><span class="line">  <span class="comment">// 这里的this怎么找到实例对象的？</span></span><br><span class="line">  <span class="comment">// 调用函数的时候隐式绑定啊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is running&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jackson&quot;</span>, <span class="number">18</span>, <span class="string">&quot;guangdong&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yuzi&quot;</span>, <span class="number">18</span>, <span class="string">&quot;beijing&quot;</span>)</span><br><span class="line">p1.<span class="title function_">eating</span>()</span><br><span class="line">p2.<span class="title function_">eating</span>()</span><br></pre></td></tr></table></figure><p><strong>JavaScript中的类和对象</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>在 JS 中，Person应该被称之为是一个构造函数</p><p>但是从很多面向对象语言的开发者习惯称之为类，因为类可以帮我们创建出来实例对象，也是可以的</p><h2 id="面向对象的特性-继承">面向对象的特性 - 继承</h2><p>面向对象有三大特性：封装、继承、多态</p><ul><li>封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程</li><li>继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中）</li><li>多态：不同的对象在执行时表现出不同的形态</li></ul><h3 id="JavaScript原型链">JavaScript原型链</h3><p><strong>原型链的理解</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们&quot;.&quot;的时候就是[[get]]操作</span></span><br><span class="line"><span class="comment">// 1.在当前的对象中查找属性</span></span><br><span class="line"><span class="comment">// 2.如果没有找到，这个时候会去原型链(__proto__)对象上查找</span></span><br><span class="line">obj.<span class="property">__proto__</span> = &#123;</span><br><span class="line">  <span class="comment">// address: &quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>= &#123;</span><br><span class="line">  <span class="comment">// address: &quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>= &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">address</span>); <span class="comment">// &quot;广州市&quot;</span></span><br><span class="line"><span class="comment">// 只要在原型链上都可以找到的</span></span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c063bcc6504441389d9b3c70db077d8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>这样一直向上找的话，那么<strong>顶层原型</strong>究竟是什么呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;Jackson&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到那一层对象之后会停止继续查找呢？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// 可以看到字面量obj的原型是 [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们继续往上看看</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 所以我们可以说 [Object: null prototype] &#123;&#125; 就是顶层的原型</span></span><br></pre></td></tr></table></figure><p>顶层对象有什么特别吗？该对象上有很多默认的属性和方法</p><p>顶层原型又来自哪里呢？下面我们创建Object对象看看</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象(这种方式相当于下面一种方式的语法糖，本质都是创建一个对象)</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125; </span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 创建了一个对象</span></span><br><span class="line"><span class="comment">// 创建对象的话，其中有一步是：将Object函数的显式原型prototype赋值给实例的隐式原型</span></span><br><span class="line"><span class="comment">// 相当于这里</span></span><br><span class="line"><span class="comment">// Object.prototype = obj2.__proto__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此（我们知道这里obj1/2.__proto__已经是到顶层了）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === obj1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === obj2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype也是一个对象，那么它应该也有 __proto__</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 因此Object.prototype指向的已经是顶层原型了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)) </span><br><span class="line"><span class="comment">// 有constructor,toString等属性和方法</span></span><br></pre></td></tr></table></figure><p>因此，<strong>原型链最顶层的原型对象就是Object的原型对象</strong></p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b10008bf8e7c4bdbab8263ac50ea0ead~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>也就是说，<strong>Object是所有类的父类</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看构造函数Person的原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// &#123;&#125; 看不到！应该是不可枚举吧</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>));</span><br><span class="line"><span class="comment">//输出 &#123;constructor: &#123;...&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);<span class="comment">//[Object: null prototype] &#123;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cab7b21f72df4098af70a97cb23b19a9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="通过原型链实现继承">通过原型链实现继承</h3><p><strong>为什么需要有继承？</strong></p><p>如果没有继承，我们想创建多个类，类里面的属性和方法很多是一样的，那么我们就会写很多重复的代码，所以主要是为了代码的复用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, sno</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// Teacher</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params">name, age, title</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>原型链的继承方案</strong></p><blockquote><p>自己画画图更好理解</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：公共属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Jackson&quot;</span>,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = []</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：特有属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = <span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new一个person</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="comment">// console.log(stu.sno); // 111</span></span><br><span class="line"><span class="comment">// console.log(stu.name);// Jackson</span></span><br><span class="line"><span class="comment">// stu.eating()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链实现继承的弊端：</span></span><br><span class="line"><span class="comment">// 1.打印stu对象，继承的属性是不能直观看到的</span></span><br><span class="line"><span class="comment">// console.log(stu); // Person &#123; sno: 111 &#125;</span></span><br><span class="line"><span class="comment">// 前面显示的 Person 类型,实际上是实例的name属性，显然这里应该是Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建出来两个stu对象</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取引用，修改引用中的值，会相互影响</span></span><br><span class="line"><span class="comment">// 因为这个fre1被加到p对象，而stu1,stu2的__proto__都指向p</span></span><br><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;fre1&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">friends</span>); <span class="comment">// [ &#x27;fre1&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>); <span class="comment">// [ &#x27;fre1&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在前面实现类的过程中都没有传递参数</span></span><br><span class="line"><span class="keyword">var</span> stu3 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jeccy&quot;</span>, <span class="number">112</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接在function Student(name,age)&#123;this.name = name this.age = age&#125;？</span></span><br><span class="line"><span class="comment">// 肯定不行啊，我们是想要把name的处理放在Person的</span></span><br></pre></td></tr></table></figure><h3 id="借用构造函数实现继承">借用构造函数实现继承</h3><blockquote><p>使用call调用构造函数，</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：公共属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, friends</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = friends</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：特有属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, friends, sno</span>) &#123;</span><br><span class="line">  <span class="comment">// 我们在这里调用Person,并把需要Person处理的参数传过去</span></span><br><span class="line">  <span class="comment">// this 就是Student的实例 </span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, friends) <span class="comment">// 这里可以获得父类的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new一个person</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 依然需要这里来获得方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p </span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决弊端3</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>, [<span class="string">&#x27;fred1&#x27;</span>], <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1); </span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;aaa&#x27;, age: 18, friends: [ &#x27;fred1&#x27; ], sno: 111 &#125; 解决弊端1</span></span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;vvv&quot;</span>, <span class="number">20</span>, [<span class="string">&#x27;fred2&#x27;</span>], <span class="number">112</span>)</span><br><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;hahaha&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">friends</span>); <span class="comment">// [ &#x27;fred2&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>); <span class="comment">// [ &#x27;fred1&#x27;, &#x27;hahaha&#x27; ]</span></span><br><span class="line"><span class="comment">// 解决弊端2</span></span><br></pre></td></tr></table></figure><p>但是这种方法依然存在弊端：</p><ol><li>Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person）</li><li>stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的）</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a1097b7c69f4850b9e4d5f245de611e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>注意：</p><p>那么我们换一种获得父类方法的方法，直接<strong>将父类原型赋值给子类</strong>？</p><p>肯定是不行的，因为以后给某个子类添加方法的时候，会使所有的子类都有该方法，显然是不行的</p><p>因为所有子类的prototype都指向同一个父类的原型</p><h3 id="原型式继承函数-对象">原型式继承函数 - 对象</h3><blockquote><p>我们先实现对象的继承，后面再扩展到类</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jackson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型式继承函数</span></span><br><span class="line"><span class="comment">// 这个函数要做到的是，你给我传入的对象，作为新对象的原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 这个方法是把o设置为newObj的原型</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(newObj, o)</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Douglas 的实现(当时还没有setPrototypeOf这个方法)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject2</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">  <span class="comment">// 因此 newObj.__proto__ = Fn.prototype = o</span></span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们想要新建的对象info的原型指向obj（后面扩展到类）</span></span><br><span class="line"><span class="comment">// var info = createObject(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 新的ECMA 给我们提供了新的方法：Object.create(obj)</span></span><br><span class="line"><span class="comment">// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span></span><br><span class="line"><span class="comment">// 实际上这个方法跟我们上面的两种实现方法实现的功能是一样的</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info);</span><br><span class="line"><span class="comment">// 已经实现了我们的目的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">__proto__</span>); <span class="comment">// &#123; name: &#x27;Jackson&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Object.create() ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p></blockquote><h3 id="寄生式继承函数（了解）">寄生式继承函数（了解）</h3><ul><li><p>寄生式继承的思路是结合原型类继承和工厂模式的一种方式</p></li><li><p>即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> personObj = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目的：继承 personObj里面的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> stu = <span class="title class_">Object</span>.<span class="title function_">create</span>(personObj)</span><br><span class="line">  stu.<span class="property">name</span> = name</span><br><span class="line">  stu.<span class="property">studying</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stuObj = <span class="title function_">createStudent</span>(<span class="string">&quot;why&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="寄生组合式继承-最终方案">寄生组合式继承(最终方案)</h3><p>利用寄生式继承将组合式继承的两个问题解决</p><ul><li>首先我们需要明确，当我们在子类的构造函数中调用父类.call(this，参数)的时候，就会将父类的属性和方法复制一份到子类中，所以父类本身里面的内容我们是不需要的</li><li>然后，我们还需要获取到一份父类的原型对象中的属性和方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不想使用Object.create这个方法的话，我们可以定义前面说过的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">SubType, SuperType</span>) &#123;</span><br><span class="line">  <span class="comment">// SubType.prototype = Object.create(SuperType.prototype)</span></span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">createObject</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="comment">// 当然子类的prototype还需要有constructor指向子构造函数本身</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">SubType</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, friends</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = friends</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, friends, sno</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, friends) <span class="comment">// 获取一份Person中的属性和方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student类还需要获取一份父类的prototype的属性和方法</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, [<span class="string">&quot;kobe&quot;</span>], <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br><span class="line"> <span class="comment">// 打印  Student &#123; name: &#x27;why&#x27;,age: 18,friends: [ &#x27;kobe&#x27; ],sno: 111,&#125;</span></span><br></pre></td></tr></table></figure><h3 id="JS原型的补充">JS原型的补充</h3><h4 id="hasOwnProperty">hasOwnProperty</h4><ul><li>判断对象是否有某个属于自己的属性，不包括在原型上的</li></ul><h4 id="in-for-in-操作符">in/ for in 操作符</h4><ul><li>判断某个属性是否在某个对象或者对象的原型上</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数是info添加属于自己的属性</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj, &#123;</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// hasOwnProperty</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;address&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">//  false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in 操作符: 不管在当前对象还是原型中返回的都是true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;address&quot;</span> <span class="keyword">in</span> info); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> info); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for in (包括原型上的属性都可以遍历到)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> info) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// address name age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof">instanceof</h4><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 使用前面的寄生组合式继承</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="comment">// stu是否出现在构造函数 Student 的原型链上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="isPrototypeOf-了解">isPrototypeOf(了解)</h4><p>用于检测某个对象，是否出现在某个实例对象的原型链上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj)</span><br><span class="line"><span class="comment">// obj是否出现在info的原型链上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">isPrototypeOf</span>(info))</span><br></pre></td></tr></table></figure><h2 id="对象-函数-原型之间的关系">对象-函数-原型之间的关系</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要是对象，里面就会有一个__proto__对象（隐式原型对象）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);<span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 所有的 function xx() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 我们都可以认为 xx 是 new Function 创建出来的</span></span><br><span class="line"><span class="comment">// 相当于 var xxx = new Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要是函数，那么它就会有一个显式原型对象：Foo.prototype</span></span><br><span class="line"><span class="comment">// 那 Foo.prototype 这个对象又来自哪里呢？</span></span><br><span class="line"><span class="comment">// 创建函数的时候，JS内部就会创建一个对象,并添加到函数的prototype属性中：Foo.prototype = &#123;constructor: Foo&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo也是一个对象，只要是对象，就会有隐式原型对象 Foo.__proto__</span></span><br><span class="line"><span class="comment">// Foo.__proto__来自哪里？</span></span><br><span class="line"><span class="comment">// var Foo = new Function() </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 而 Function.prototype对象是我们创建Function函数的时候创建出来的</span></span><br><span class="line"><span class="comment">// Function.prototype = &#123;constructor: Function&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Function函数</span></span><br><span class="line"><span class="comment">// function Function() &#123;&#125;</span></span><br><span class="line"><span class="comment">// Function.prototype</span></span><br><span class="line"><span class="comment">// Function 又是一个对象</span></span><br><span class="line"><span class="comment">// Function.__proto__</span></span><br><span class="line"><span class="comment">// 唯一一个比较特殊的东西</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外还有 function Object() &#123;&#125;</span></span><br><span class="line"><span class="comment">// Object作为函数, 就会有Object.prototype</span></span><br><span class="line"><span class="comment">// Object作为对象, 就会有Object.__proto__</span></span><br><span class="line"><span class="comment">// Object函数是Function创建出来的，所以</span></span><br><span class="line"><span class="comment">// Objcet.__proto__ === Function.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后就是每个函数的原型prototype都会有一个constructor指回函数本身</span></span><br></pre></td></tr></table></figure><p>最后 上图！</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98247be221ed4805a65a68e7f0d8fffd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4465e678da8240028f973262ac63399d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07_严格模式</title>
      <link href="/2022/04/02/07_%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/07_%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="严格模式">严格模式</h3><h4 id="如何开启严格模式？">如何开启严格模式？</h4><p>在文件或者函数开头使用 “use strict”</p><h4 id="严格模式常见的限制">严格模式常见的限制</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="comment">// 1.禁止意外创建全局变量</span></span><br><span class="line"><span class="comment">// 在全局中不使用关键字直接定义变量</span></span><br><span class="line">message = <span class="string">&quot;hello&quot;</span></span><br><span class="line">message is not defined</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不允许函数有相同的参数名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y, x</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// Duplicate parameter name not allowed in this context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使静默错误(不报错但也没有任何效果)的赋值操作抛出异常</span></span><br><span class="line"><span class="literal">true</span>.<span class="property">name</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="title class_">NaN</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不可写</span></span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;hillyee&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;jenny&quot;</span></span><br><span class="line"><span class="comment">// 试图删除不可删除的属性，报错</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span></span><br><span class="line"><span class="comment">// Cannot delete property &#x27;name&#x27; of #&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.不允许使用原先的八进制格式</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0o123</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0x123</span> <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">0b100</span> <span class="comment">// 二进制</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="严格模式下的this">严格模式下的this</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格模式下，独立函数调用this默认绑定不是window，而是undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hill&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span></span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout的this</span></span><br><span class="line"><span class="comment">// 内部 fn.apply(this=window)</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06_纯函数-柯里化-组合</title>
      <link href="/2022/04/02/06_%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88/"/>
      <url>/2022/04/02/06_%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="纯函数-柯里化-组合">纯函数 - 柯里化 - 组合</h3><h4 id="纯函数">纯函数</h4><ul><li><p>什么是纯函数？</p><ul><li><p>确定的输入，一定会产生确定的输出</p></li><li><p>函数在执行过程中，不能产生副作用</p></li></ul></li><li><p>什么是副作用？</p><ul><li>在执行一个函数时，除了返回值函数之外，还对调用函数产生了附加的影响，比如说修改了全局变量，修改参数或者改变外部的存储</li></ul></li><li><p>纯函数例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>, <span class="string">&quot;dna&quot;</span>]</span><br><span class="line"><span class="comment">// slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值</span></span><br><span class="line"><span class="comment">// slice函数本身它是不会修改原来的数组</span></span><br><span class="line"><span class="comment">// 所以slice函数本身就是一个纯函数</span></span><br><span class="line"><span class="keyword">var</span> newNames1 = names.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice不是一个纯函数</span></span><br><span class="line"><span class="keyword">var</span> newNames2 = names.<span class="title function_">splice</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names) <span class="comment">// [ &#x27;abc&#x27;, &#x27;cba&#x27; ] 改变了原数组</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="JavaScript柯里化">JavaScript柯里化</h4><ul><li><p>什么是柯里化？</p><ul><li>把接收多个参数的函数变成接收一个单一参数的函数</li><li>“如果你固定某些参数，你将得到接受余下参数的一个函数”</li><li>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数，这个过程称之为柯里化</li></ul></li><li><p>柯里化的结构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum1</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">z</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="title function_">sum1</span>(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>) <span class="comment">// 60</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum2</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z</span><br></pre></td></tr></table></figure></li><li><p>柯里化让函数的职责单一</p><p>每次接收的一个参数，都做它自己的逻辑</p></li><li><p>可以更好的复用参数逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">count</span>) &#123;</span><br><span class="line">  count = count * count</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> count + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如说我们想要每次的count都是5</span></span><br><span class="line"><span class="keyword">var</span> adder5 = <span class="title function_">makeAdder</span>(<span class="number">5</span>)</span><br><span class="line"><span class="title function_">adder5</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">adder5</span>(<span class="number">13</span>) </span><br></pre></td></tr></table></figure></li><li><p>柯里化函数的实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurrying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 当已经传入的参数 大于等于 需要的参数时, 就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// fn()</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有达到个数时, 需要返回一个新的函数,继续来接收参数</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">curried2</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收到参数后, 需要递归调用curried来检查函数的个数是否达到</span></span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args, ...args2])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> curried2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个柯里化的函数</span></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryAdd = <span class="title function_">myCurrying</span>(add1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>));</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合函数">组合函数</h4><ul><li><p>什么是组合函数？</p><ul><li>组合函数是在 JavaScript 开发过程中一种对函数的使用技巧、模式</li></ul></li><li><p>组合函数的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num ** <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">square</span>((<span class="title function_">double</span>(count)))</span><br></pre></td></tr></table></figure></li><li><p>实现组合函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hyCompose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是函数,直接报错</span></span><br><span class="line">  <span class="keyword">let</span> length = fns.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fns[i] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出所有的函数一次调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = length ? fns[index].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args) : args</span><br><span class="line">    <span class="keyword">while</span>(++index &lt; length) &#123;</span><br><span class="line">      result = fns[index].<span class="title function_">call</span>(<span class="variable language_">this</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFn = <span class="title function_">hyCompose</span>(double, square)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newFn</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05_认识arguments</title>
      <link href="/2022/04/02/05_%E8%AE%A4%E8%AF%86arguments/"/>
      <url>/2022/04/02/05_%E8%AE%A4%E8%AF%86arguments/</url>
      
        <content type="html"><![CDATA[<h3 id="认识-arguments">认识 arguments</h3><h4 id="什么是-arguments">什么是 arguments</h4><p><strong><code>arguments</code></strong> 是一个对应于传递给函数的参数的类数组对象。(MDN)</p><ul><li><p>类数组对象，就说明它本质上是一个对象类型</p></li><li><p>类数组表示它长得像数组，并且拥有数组的一些特性，比如说 length，可以通过 index 访问</p><p>但是却没有数组的一些方法，比如说 forEach，map 等</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 会帮你接收所有传递给函数的参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 10, &#x27;1&#x27;: 20, &#x27;2&#x27;: 30 &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取参数的长度</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// 根据索引值获取某一个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]); <span class="comment">// 20</span></span><br><span class="line">  <span class="comment">// 获取当前 arguments 所在的函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>); <span class="comment">// [Function: foo]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// arguments.forEach() 是不可以的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><h4 id="arguments-转成数组">arguments 转成数组</h4><p>如果我们需要遍历里面的参数呢？或者说使用一些数组的方法呢？</p><p>所以在开发中，我们经常会把 arguments 转成数组</p><h5 id="第一种方法-自己遍历">第一种方法: 自己遍历</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 我们可以通过索引值拿到 arguments 的每一个值</span></span><br><span class="line">  <span class="comment">// 然后添加到新的数组</span></span><br><span class="line">  <span class="keyword">let</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    newArr.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [ 10, 20, 30, 40, 50 ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>) </span><br></pre></td></tr></table></figure><h5 id="第二种方法：Array-prototype-slice">第二种方法：Array.prototype.slice</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>Array.prototype.slice.call(arguments) ？什么意思呀？</p><p>首先，我们一般使用 slice 的时候，是 <code>arr.slice(start, end)</code>，那如果没有这个arr呢？我们怎么才能拿到 slice 这个方法</p><p>是不是可以在 Array 的原型上面找这个方法，所以 Array.prototype.slice()</p><p>那为什么要用 call 来调用？</p><p>我们先来模拟一下 Array 中的 slice 是怎么实现的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myslice</span> = <span class="keyword">function</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果我们直接 Array.prototype.myslice() 这样调用的话, this 指向的就是prototype了</span></span><br><span class="line">  <span class="comment">// 而我们希望的是, 这里的 this 是指向调用 slice 这个方法的数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="variable language_">this</span></span><br><span class="line">  start = start || <span class="number">0</span></span><br><span class="line">  end = end || arr.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newArray = []</span><br><span class="line">  <span class="comment">// 从start到end(不包括end),把元素添加到数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    newArray.<span class="title function_">push</span>(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们要使用 call 来显式绑定这个 this，让this指向数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myslice</span>.<span class="title function_">call</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然可以传递参数</span></span><br><span class="line"><span class="keyword">let</span> newArr2 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myslice</span>.<span class="title function_">call</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr2); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><p>那跟我们 arguments 有什么关系？</p><p>Array内部 slice 的实现只不过是对 this，也就是需要使用 slice 的数组进行遍历，然后把需要的部分加入到新数组</p><p>那遍历 arguments 也可以啊，把元素一个个加入到一个数组里面，再把这个数组返回，最后不就实现了 arguments 转数组了吗</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 同样道理的还有一种方法, 我们目的就是拿到 slice 这个方法,并且让 this 绑定 arguments,让内部遍历arguments</span></span><br><span class="line">  <span class="keyword">let</span> newArr2 = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>再看回这个，应该理解了吧</p><h5 id="Array-from-ES6"><strong>Array</strong>.from (ES6)</h5><p><strong>Array.from()</strong> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例（MDN）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h5 id="展开运算符-ES6">展开运算符 (ES6)</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 因为展开运算符实际上也是遍历，把遍历的元素一个个放到数组</span></span><br><span class="line">  <span class="keyword">let</span> newArr = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="箭头函数没有-arguments">箭头函数没有 arguments</h4><p>箭头函数是不绑定 arguments 的，如果在箭头函数中使用 arguments，会去找上层作用域中的arguments</p><p>注意，全局作用域是没有 arguments 的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 找上层作用域，找到 window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// arguments is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// arguments 有 123</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// Arguments [123]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// Arguments [123]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">foo</span>(<span class="number">123</span>)</span><br><span class="line"><span class="title function_">fn</span>() </span><br></pre></td></tr></table></figure><p>那如果想传递多个参数呢？用 ES6 的剩余参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params">a, b, ...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 1 2 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args); <span class="comment">// [3,4,5,6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码学习</title>
      <link href="/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>Vue3源码学习</h1><blockquote><p>第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭</p></blockquote><h2 id="1-真实的DOM渲染">1. 真实的DOM渲染</h2><p>传统的前端开发中，我们是编写自己的HTML，最终被渲染到浏览器上的，这个过程大概是：</p><p>解析 html 转化成 DOM 树，然后渲染到页面</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06870cfbd95e41b6b19f557735a82565~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="2-虚拟DOM">2. 虚拟DOM</h2><h3 id="2-1-渲染过程">2.1 渲染过程</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5da766b840443a082d46dea3ef61179~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="3-Vue-源码的三大核心系统">3. Vue 源码的三大核心系统</h2><ul><li><p>Complier模块：编译模板系统</p></li><li><p>Runtime模块：也可以称之为 Renderer模块，真正渲染的模块</p></li><li><p>Reactivity模块：响应式系统</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2570e47944e340d09d20b337494d597a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li>三大系统协同工作</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917ae20ad154485f86dc308eb3841d69~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="4-实现-Mini-Vue">4. 实现 Mini-Vue</h2><blockquote><p>mini-vue的实现也是，后面有时间得回来重新看看</p></blockquote><p>包括三部分：</p><ul><li>渲染系统模块</li><li>可响应式系统模块</li><li>应用程序入口模块</li></ul><h3 id="4-1-渲染系统实现">4.1 渲染系统实现</h3><p>包含三个功能：</p><ul><li>h 函数，返回一个 VNode 对象</li><li>mount 函数，用于将 VNode 挂载到 DOM 上</li><li>patch 函数，用于对比两个 VNode，决定如何处理新的VNode（diff）</li></ul><h4 id="h函数生成-VNode">h函数生成 VNode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 VNode</span></span><br><span class="line"><span class="comment">// 直接返回一个 VNode对象即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">h</span> = (<span class="params">tag, props, children</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mount函数挂载-vnode">mount函数挂载 vnode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mount函数, 挂载VNode</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mount</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1.根据tag创建HTML元素,并且存储到vnode的el中</span></span><br><span class="line">  <span class="keyword">const</span> el = vnode.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>)</span><br><span class="line">  <span class="comment">// 2.处理props属性</span></span><br><span class="line">  <span class="comment">// 2.1 如果以on开头,那么监听事件</span></span><br><span class="line">  <span class="comment">// 2.2 普通属性直接通过 setAttribute 添加</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">props</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnode.<span class="property">props</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.<span class="property">props</span>[key]</span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.处理children</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      el.<span class="property">textContent</span> = vnode.<span class="property">children</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">mount</span>(item, el)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.将 el挂载到container上</span></span><br><span class="line">  container.<span class="title function_">appendChild</span>(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="patch函数-对比两个VNode">patch函数 - 对比两个VNode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patch,对比两个 VNode</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. tag不同,直接加入新的节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1.<span class="property">tag</span> !== n2.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1Elparent = n1.<span class="property">el</span>.<span class="property">parentElement</span></span><br><span class="line">    n1Elparent.<span class="title function_">removeChild</span>(n1.<span class="property">el</span>)</span><br><span class="line">    <span class="title function_">mount</span>(n2, n1Elparent)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 取出element对象,并且在n2中进行保存</span></span><br><span class="line">    <span class="keyword">const</span> el = n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line">    <span class="comment">// 2. 处理props</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.1 获取所有的newProps添加到el</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key]</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123; <span class="comment">// 对事件监听的判断</span></span><br><span class="line">          el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), </span><br><span class="line">          newValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          el.<span class="title function_">setAttribute</span>(key, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2删除旧的props</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = oldProps[key]</span><br><span class="line">        el.<span class="title function_">removeEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.<span class="title function_">removeAttribute</span>(key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.处理children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span> || []</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.<span class="property">children</span> || []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123; <span class="comment">// 3.1newChildren本身是一个string</span></span><br><span class="line">      <span class="comment">// 边界情况 如果oldChildren也是一个字符串</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newChildren !== oldChildren) &#123;</span><br><span class="line">          el.<span class="property">textContent</span> = newChildren</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="property">innerHTML</span> = newChildren</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2 newChildren本身是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        el.<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        newChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">mount</span>(item, el)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// oldChildren 也是数组</span></span><br><span class="line">        <span class="comment">// 1. 前面有相同节点的</span></span><br><span class="line">        <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldChildren.<span class="property">length</span>, newChildren.<span class="property">length</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">          <span class="title function_">patch</span>(oldChildren[i], newChildren[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果新节点的length更长，那么剩余的新节点进行挂载操作</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &gt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          newChildren.<span class="title function_">slice</span>(oldChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">mount</span>(item, el)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果旧节点的length更长，那么移除剩余的旧节点进行</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &lt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          oldChildren.<span class="title function_">slice</span>(newChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            el.<span class="title function_">removeChild</span>(item.<span class="property">el</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-响应式系统">4.2 响应式系统</h3><h4 id="依赖收集系统-vue2响应式系统">依赖收集系统 + vue2响应式系统</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="comment">// 只要new Dep,就会给你添加subscribes属性 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 创建集合(里面放某属性依赖的函数)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  <span class="title function_">effect</span>() <span class="comment">// 原始数据先执行一次</span></span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDep</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据对象(target)取出对应的Map对象</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.取出具体的dep对象</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象拿到所有key,组成数组</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(raw).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取key对应的依赖</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(raw, key)</span><br><span class="line">    <span class="keyword">let</span> value = raw[key]</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(raw, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="comment">// 用到了某个key,调用get,所以可以在这里收集依赖</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; <span class="comment">// 当属性被重新赋值的时候,会调用set,所以在这里执行这个属性依赖的函数</span></span><br><span class="line">        <span class="comment">// raw[key] = newValue 不能这样设置,否则递归了(又对raw操作,又劫持,又来到set这里了)</span></span><br><span class="line">        <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">          value = newValue</span><br><span class="line">          dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hillyee&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect1</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">counter</span> * <span class="number">2</span>, info.<span class="property">name</span>, <span class="string">&#x27;w1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect2</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">counter</span> * info.<span class="property">counter</span>, <span class="string">&#x27;w2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// info.counter++ // 修改数据的时候,所有对这个数据有依赖的函数都应该被执行一次</span></span><br><span class="line"><span class="comment">// info.name = &quot;hahahhahah&quot;</span></span><br></pre></td></tr></table></figure><h4 id="响应式系统-vue3-proxy实现">响应式系统 vue3-proxy实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="comment">// Proxy(原对象,代理对象)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(raw, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(target, key) <span class="comment">// 获取该属性的依赖</span></span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(target, key)</span><br><span class="line">      target[key] = newValue</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么-Vue3-选择-Proxy-呢？">为什么 Vue3 选择 Proxy 呢？</h4><ul><li><p>Object.definedProperty 是劫持对象的属性时，如果新增元素，</p><p>那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理</p></li><li><p>修改对象的不同： 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截；</p><p>而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截；</p></li></ul><h3 id="4-3-框架外层-API-设计">4.3 框架外层 API 设计</h3><h4 id="createApp">createApp()</h4><p>用于创建一个app对象，该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">rootComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">mount</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector)</span><br><span class="line">      <span class="keyword">let</span> isMounted = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">let</span> oldVNode = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">watchEffect</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">          <span class="comment">// rootComponent.render() 返回根组件的vnode</span></span><br><span class="line">          oldVNode = rootComponent.<span class="title function_">render</span>()</span><br><span class="line">          <span class="title function_">mount</span>(oldVNode, container)</span><br><span class="line">          isMounted = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> newVNode = rootComponent.<span class="title function_">render</span>()</span><br><span class="line">          <span class="title function_">patch</span>(oldVNode, newVNode)</span><br><span class="line">          oldVNode = newVNode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用案例–计数">使用案例–计数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../mini_vue/renderer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../mini_vue/reactive.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.创建根组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">counter</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;),</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">`当前计数:<span class="subst">$&#123;<span class="variable language_">this</span>.data.counter&#125;</span>`</span>),</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">counter</span>++</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">counter</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;, <span class="string">&quot;+1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        ])</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2.挂载根组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span></span><br><span class="line"><span class="language-javascript">    app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>Vue3源码阅读</h1><blockquote><p>根据图的流程，加上源码，多看看叭，第一次看源码确实有点吃力了</p><p>先看熟悉流程，然后可以 debugger 在浏览器上简单过一下整个流程</p></blockquote><h2 id="createApp-2">createApp</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941441a206f545c488351612ee7f0a96~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="源码阅读之挂载根组件">源码阅读之挂载根组件</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e27cf0afe14494e963576c217bff7ab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;<span class="attr">props</span>: &#123;<span class="attr">message</span>: <span class="title class_">String</span>&#125;</span><br><span class="line">instance</span><br><span class="line"><span class="comment">// 1.处理props和attrs</span></span><br><span class="line">instance.<span class="property">props</span></span><br><span class="line">instance.<span class="property">attrs</span></span><br><span class="line"><span class="comment">// 2.处理slots</span></span><br><span class="line">instance.<span class="property">slots</span></span><br><span class="line"><span class="comment">// 3.执行setup</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">setup</span>()</span><br><span class="line">instance.<span class="property">setupState</span> = <span class="title function_">proxyRefs</span>(result);</span><br><span class="line"><span class="comment">// 4.编译template -&gt; compile</span></span><br><span class="line">&lt;template&gt; -&gt; render函数</span><br><span class="line">instance.<span class="property">render</span> = <span class="title class_">Component</span>.<span class="property">render</span> = render函数</span><br><span class="line"><span class="comment">// 5.对vue2的options api进行知识</span></span><br><span class="line">data/methods/computed/生命周期</span><br></pre></td></tr></table></figure><h2 id="组件化的初始化">组件化的初始化</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40e10ca0c2b044d78ba221099f6d9eef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="Compile过程">Compile过程</h2><p>对于不会改变的静态节点进行作用于提升</p><blockquote><p>我都没找到这部分函数。。。</p></blockquote><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd404365f8f946d89e99ccc604ffa235~tplv-k3u1fbpfcp-watermark.image?" alt="image.png " style="zoom:67%;" /><h2 id="Block-Tree-分析">Block Tree 分析</h2><p>vue3的一个优化：对于不会改变的静态节点进行作用域提升，仅对新的vnode进行创建</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c78021a3a241ca8ef00958116b4445~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="生命周期回调">生命周期回调</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8269743b1fb949219a2216950b8b1fb6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="template中数据的使用顺序">template中数据的使用顺序</h2><blockquote><p>如果setup跟data中有同一个属性,首先选择setup的,内部做了一个判断吧</p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6505298f6148e69434be3079bb168c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 深入Vue3+Typescript学习⚡ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3_compositionAPI</title>
      <link href="/2022/03/31/Vue3-compositionAPI/"/>
      <url>/2022/03/31/Vue3-compositionAPI/</url>
      
        <content type="html"><![CDATA[<h3 id="Composition-API">Composition API</h3><h4 id="1-setup">1. setup</h4><p><strong>1.1 setup函数有两个参数：props，context</strong></p><ul><li>props：其实就是父组件传递过来的属性，但是在setup外面依然需要用props接收</li><li>context：里面包含三个属性：<ul><li>attrs：父组件传递过来的没有被prop接收的属性</li><li>slots：父组件传递过来的插槽</li><li>emit：当组件内部需要发出事件的时候用（vue2里面是this.$emit，但是vue3中，setup不能访问this）</li></ul></li></ul><p><strong>1.2 setup 函数的返回值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup的返回值可以在模板 template 中使用，也就是可以代替data</p><p>但是直接这么返回变量，是没有响应式的</p><p><strong>1.3 setup 不可以使用 this</strong></p><ul><li>this 并没有指向当前组件实例</li><li>在 setup 被调用之前，data、computed、等都没有被解析</li><li>所以无法在 setup 中获取this</li></ul><h4 id="2-reactive-API">2. reactive API</h4><p>为setup中定义的数据提供响应式的特性</p><p>reactive API 传入的类型必须是对象或者数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>  <span class="comment">// 这时候这个name就是响应式的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-ref-API">3. ref API</h4><h5 id="3-1-ref-API-基本使用">3.1 ref API 基本使用</h5><p>可以传入基本数据类型，在开发中推荐使用 ref，便于代码的抽离，当然如果属性关系很紧密的时候，我们也可以用 reactive</p><p>ref 会返回一个可变的响应式对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>在 template 中引用 ref 的值时，Vue会自动帮我们进行解包，就是说我们不需要在模板中 xxx.value 来使用</li><li>但是在 setup 内部，它依然是一个 ref 的引用，所以要使用 <strong>ref.value</strong></li></ul><h5 id="3-2-ref-API-的补充">3.2 ref API 的补充</h5><ul><li>toRefs 和 toRef</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 当我们想解构的时候</span></span><br><span class="line"><span class="comment">// let &#123;name, age&#125; = info // 不再是响应式的了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望响应式的话</span></span><br><span class="line"><span class="comment">// 1. toRefs: 将 reactive 对象中所有属性都转成 ref</span></span><br><span class="line"><span class="comment">// let &#123;name, age&#125; = toRefs(info)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只希望单个响应式的话</span></span><br><span class="line"><span class="comment">// 2. toRef</span></span><br><span class="line"><span class="keyword">let</span> &#123;name&#125; = info <span class="comment">// 不是响应式</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="title function_">toRef</span>(info, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  age.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>shallowRef：创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的</li><li>triggerRef：手动触发和 shallowRef 相关联的副作用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info = <span class="title function_">shallowRef</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// info.value = &quot;hello&quot; 响应式</span></span><br><span class="line">  info.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&quot;james&quot;</span> <span class="comment">// 不是响应式</span></span><br><span class="line">  <span class="comment">// 手动触发和 shallowRef 相关联的副作用(变成响应式)</span></span><br><span class="line">  <span class="title function_">triggerRef</span>(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>customRef 自定义 ref</li></ul><h4 id="4-readonly">4. readonly</h4><ul><li><p>当我们希望我们给其他组件传递数据时，希望其他组件只是使用我们的内容，但是不允许它们修改的时候，可以用readonly</p></li><li><p>实际上，readonly 会返回原生对象的只读代理，也就是它依然是一个 Proxy，但是set方法被劫持</p></li><li><p>开发中常见的readonly方法会传入三个类型的值</p><ul><li>普通对象</li><li>reactive 返回的对象</li><li>ref 的对象</li></ul></li><li><p>readonly 使用时，readonly 返回的对象不允许修改，但是经过 readonly 处理的原来的对象是可以修改的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">readonly</span>(info)</span><br><span class="line">state.<span class="property">name</span> = <span class="string">&quot;aaa&quot;</span> <span class="comment">// 不可以</span></span><br><span class="line">info.<span class="property">name</span> = <span class="string">&quot;aaa&quot;</span> <span class="comment">// 可以</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-computed">5. computed</h4><ul><li><p>用法一：传入一个getter函数,computed的返回值是一个只读的ref对象(不能修改)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> firstName.<span class="property">value</span> + <span class="string">&quot;-&quot;</span> +lastName.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   firstName.<span class="property">value</span> = <span class="string">&quot;james&quot;</span> <span class="comment">// 可修改</span></span><br><span class="line">   fullName.<span class="property">value</span> = <span class="string">&quot;yuzi bing&quot;</span> <span class="comment">// 不可修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用法二：传入一个对象,对象包含 getter/setter,返回一个可读写的ref 对象</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> firstName.<span class="property">value</span> + <span class="string">&quot;-&quot;</span> +lastName.<span class="property">value</span>,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> names = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    firstName.<span class="property">value</span> = names[<span class="number">0</span>]</span><br><span class="line">    lastName.<span class="property">value</span> = names[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  fullName.<span class="property">value</span> = <span class="string">&quot;yuzi bing&quot;</span> <span class="comment">// 可修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-watchEffect">6. watchEffect</h4><p><strong>6.1 watchEffect 基本使用</strong></p><ul><li>watchEffect 传入的函数会被立即执行一次, 并在执行的过程中自动收集依赖（相当于你在这个函数使用了什么变量，它会自动收集到）</li><li>只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行</li></ul><p>下面案例中，name 的改变会被侦听到，而 age 不会被侦听</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watchEffect: 自动收集响应式的依赖</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;jenny&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params"></span>) =&gt; name.<span class="property">value</span> = <span class="string">&quot;tony&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeAge</span> = (<span class="params"></span>) =&gt; age.<span class="property">value</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name:&quot;</span>, name.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>6.2 watchEffect 停止侦听</strong></p><p>如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"><span class="comment">// watchEffect 会返回一个函数,供我们停止侦听使用</span></span><br><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;age:&quot;</span>, age.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  age.<span class="property">value</span>++</span><br><span class="line">  <span class="comment">// 案例：age 到25的时候就停止侦听</span></span><br><span class="line">  <span class="keyword">if</span> (age.<span class="property">value</span> &gt; <span class="number">25</span>) &#123;</span><br><span class="line">    <span class="title function_">stop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.3 watchEffect 清除副作用</strong></p><p>清除副作用？</p><p>比如我们需要在侦听器中执行网络请求，但是在网络请求还没完成之前，我们停止了侦听器或者修改了数据让侦听器侦听函数再次执行了，这时候我们应该清除上一次的副作用（数据改变了要重新发送请求或者说不需要发了）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网络请求成功~&#x27;</span>); <span class="comment">// 定时器模拟网络请求</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在传入的回调函数中执行一些清除工作</span></span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onInvalidate&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;age:&quot;</span>, age.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>6.4 watchEffect 执行时机</strong></p><ul><li><p>首先补充一下：在 setup 中如何属于 ref 或者元素或者组件？</p><p>定义一个 ref 对象，绑定到元素或组件的ref属性上</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2 ref=<span class="string">&quot;title&quot;</span>&gt;hello&lt;<span class="regexp">/h2&gt; /</span><span class="regexp">/ 绑定到元素的ref属性</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const title = ref(null) /</span><span class="regexp">/ 定义 ref 对象</span></span><br></pre></td></tr></table></figure><ul><li><p>watchEffect 执行时机</p><p>如果我们希望在副作用函数中获取元素，我们会发现打印结果有两个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220329144156444-16485361187171.png" alt="image-20220329144156444 " style="zoom:60%;" /><ul><li>这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null</li><li>当 DOM 挂载时，会给 title 的 ref 对象赋新的值，副作用函数会再次执行</li></ul></li><li><p>调整 watchEffect 的执行时机</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// flush: &quot;pre&quot; // 在元素挂载或更新之前执行</span></span><br><span class="line">    <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span> <span class="comment">// 元素挂载更新之后执行, 这时候只打印一次&lt;h2&gt;&lt;/h2&gt;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-watch">7. watch</h4><h5 id="7-1-侦听单个数据源">7.1 侦听单个数据源</h5><ul><li>侦听一个 getter 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. watch侦听时,传入一个getter函数, 具体监听某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> info.<span class="property">name</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue); <span class="comment">// Tom jenny</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接侦听一个可响应式的对象，reactive 或 ref （ref更常用）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个可响应式对象: reactive对象/ref对象</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="title function_">ref</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(info, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue); </span><br><span class="line">    <span class="comment">// Proxy &#123;name: &#x27;Tom&#x27;, age: 18&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(title, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue); <span class="comment">// world hello</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    title.<span class="property">value</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-侦听多个数据源">7.2 侦听多个数据源</h5><p>注：如果我们希望侦听一个数组或者对象，那么可以使用一个getter函数，并且对可响应对象进行解构</p><p>(不解构也行,不解构n,o就是一个Proxy对象)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> title = <span class="title function_">ref</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时侦听多个数据源</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">() =&gt;</span> (&#123;...info&#125;), title], <span class="function">(<span class="params">[newInfo, newTitle], [oldInfo, oldTitle]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newInfo, newTitle, oldInfo, oldTitle);</span><br><span class="line">    <span class="comment">// &#123;name: &#x27;Tom&#x27;, age: 18&#125; &#x27;world&#x27; </span></span><br><span class="line">    <span class="comment">// &#123;name: &#x27;jenny&#x27;, age: 18&#125; &#x27;hello&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    title.<span class="property">value</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-watch-的选项">7.3 watch 的选项</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">hobby</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;haha&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> (&#123;...info&#125;), <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度监听</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// 立即执行一次</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// info.name = &quot;Tom&quot;</span></span><br><span class="line">    info.<span class="property">hobby</span>.<span class="property">title</span> = <span class="string">&quot;hehe&quot;</span> <span class="comment">// 开启深度监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-生命周期钩子">8. 生命周期钩子</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在挂载开始之前被调用：相关的 render 函数首次被调用。</span></span><br><span class="line"><span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 实例挂载完毕后调用</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。</span></span><br><span class="line"><span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</span></span><br><span class="line"><span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载组件实例前调用, 这个阶段,实例仍然是完全正常的</span></span><br><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 卸载组件实例后调用,调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</span></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line"><span class="title function_">onActivated</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件失活时调用。</span></span><br><span class="line"><span class="title function_">onDeactivated</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="9-Provide-和-Inject">9. Provide 和 Inject</h4><p>父组件通过 provide 来提供数据（必须要在父组件中使用过子组件，建立联系才能提供数据）</p><p>provide(属性名，属性值)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;jenny&quot;</span>)</span><br><span class="line"><span class="comment">// 给后代组件提供属性或方法(为了不让子组件随意修改父组件的数据,可以使用readonly)</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;name&quot;</span>, <span class="title function_">readonly</span>(name))</span><br></pre></td></tr></table></figure><p>后代组件可以通过 Inject 来注入需要的属性和对应值</p><p>inject(要注入的属性名, 默认值) ，默认值就是如果父组件没有提供改数据的话就使用默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">inject</span>(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="10-composition-API-练习">10. composition API 练习</h4><p>自定义 hooks</p><h5 id="1-useTitle">1. useTitle</h5><p>改变页面标题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">title = <span class="string">&quot;默认的title&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> titleRef = <span class="title function_">ref</span>(title)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(titleRef, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = newValue</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> titleRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-useScrollPosition">2. useScrollPosition</h5><p>监听页面滚动位置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useScrollPosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> scrollX = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> scrollY = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    scrollX.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">scrollX</span></span><br><span class="line">    scrollY.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">scrollY</span></span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    scrollX,</span><br><span class="line">    scrollY</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-useMousePosition">3. useMousePosition</h5><p>监听鼠标位置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useMousePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mouseX = <span class="title function_">ref</span>(<span class="number">0</span>)  </span><br><span class="line">  <span class="keyword">const</span> mouseY = <span class="title function_">ref</span>(<span class="number">0</span>)  </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    mouseX.<span class="property">value</span> = event.<span class="property">pageX</span></span><br><span class="line">    mouseY.<span class="property">value</span> = event.<span class="property">pageY</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    mouseX,</span><br><span class="line">    mouseY</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-useLocalStorage">4. useLocalStorage</h5><p>使用 localStorage 存储和获取数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(value)</span><br><span class="line">  <span class="comment">// 如果有传value,表示要存储值,否则是获取值</span></span><br><span class="line">  <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.<span class="property">value</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(data, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newValue))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器存取值</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="title function_">useLocalStorage</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jenny&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; data.<span class="property">value</span> = <span class="string">&quot;hahaha&quot;</span></span><br></pre></td></tr></table></figure><h5 id="5-useCounter">5. useCounter</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> doubleCounter = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counter.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; counter.<span class="property">value</span>++;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; counter.<span class="property">value</span>--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter, </span><br><span class="line">    doubleCounter, </span><br><span class="line">    increment, </span><br><span class="line">    decrement</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-认识自定义指令">11. 认识自定义指令</h4><h5 id="11-1-简单使用">11.1 简单使用</h5><ul><li><p>除了 v-for, v-show，等指令，Vue也允许我们自定义指令</p></li><li><p>自定义指令分为两种</p><ul><li>自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用</li><li>自定义全局指令：app的 directive 方法，可以在任意组件中被使用</li></ul></li><li><p>简单的案例：当某个元素挂载完成后可以自定获取焦点</p><ul><li><p>默认方式的实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref, onMounted&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const input = ref(null)</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      input.value.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      input</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义局部指令 v-focus</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; ref=&quot;input&quot; v-focus&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    // 自定义属性的名称(这里不需要写 v-)</span><br><span class="line">    focus: &#123;</span><br><span class="line">      mounted(el) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义全局指令 v-focus (main.js中)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.directive(&quot;focus&quot;, &#123;</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="11-2-指令的生命周期">11.2 指令的生命周期</h5><ul><li>一个指令定义的对象，Vue提供了如下的几个钩子函数：</li><li>created：在绑定元素的 attribute 或事件监听器被应用之前调用；</li><li>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用</li><li>mounted：在绑定元素的父组件被挂载后调用</li><li>beforeUpdate：在更新包含组件的 VNode 之前调用</li><li>updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用</li><li>beforeUnmount：在卸载绑定元素的父组件之前调用</li><li>unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次</li></ul><p>指令的生命周期可以拿到几个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// el: &lt;input&gt;</span></span><br><span class="line">  <span class="comment">// bindings: 包含一些属性的对象</span></span><br><span class="line">  <span class="comment">// vnode: 一个真实 DOM 元素</span></span><br><span class="line">  <span class="comment">// preVnode: 上一个虚拟节点</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, bindings, vnode, preVnode</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;focus created&quot;</span>, el, bindings, vnode, preVnode);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindings.<span class="property">value</span>); <span class="comment">// 拿到传入的参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindings.<span class="property">modifiers</span>); <span class="comment">// 指令的修饰符</span></span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="11-3-指令的参数和修饰符">11.3 指令的参数和修饰符</h5><ul><li><p>指令接受参数或者修饰符</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">v-指令名:参数名.修饰符=&quot;具体值&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-why:info.aaa.bbb</span>=<span class="string">&quot;&#123;title: &#x27;hello&#x27;, name: &#x27;me&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="11-4-自定义指令练习">11.4 自定义指令练习</h5><p>自定义时间格式化的指令 v-format-time</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&quot;dayjs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  app.<span class="title function_">directive</span>(<span class="string">&quot;format-time&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params">el, bindings</span>) &#123;</span><br><span class="line">      <span class="comment">// 默认格式</span></span><br><span class="line">      bindings.<span class="property">formatString</span> = <span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span></span><br><span class="line">      <span class="comment">// 如果有传入格式的参数，那么使用传入的格式</span></span><br><span class="line">      <span class="keyword">if</span> (bindings.<span class="property">value</span>) &#123;</span><br><span class="line">        bindings.<span class="property">formatString</span> = bindings.<span class="property">value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params">el, bindings</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> textContent = el.<span class="property">textContent</span> <span class="comment">// 节点及其后代的文本内容</span></span><br><span class="line">      <span class="keyword">let</span> timestamp = <span class="built_in">parseInt</span>(textContent)</span><br><span class="line">      <span class="keyword">if</span> (textContent.<span class="property">length</span> === <span class="number">10</span>) &#123;</span><br><span class="line">        timestamp = timestamp * <span class="number">1000</span> <span class="comment">// 转成毫秒</span></span><br><span class="line">      &#125;</span><br><span class="line">      el.<span class="property">textContent</span> = <span class="title function_">dayjs</span>(timestamp).<span class="title function_">format</span>(bindings.<span class="property">formatString</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-nextTick">12. nextTick</h4><blockquote><p>将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它</p></blockquote><p>案例：当message更新时，拿到它的高度</p><p>如果不放到 nextTick执行，拿到的就是未更新之前的数据，比如第一次点添加内容，输出0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot; ref=&quot;titleRef&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;addContent&quot;&gt;添加内容&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, nextTick &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const message = ref(&quot;&quot;)</span><br><span class="line">    const titleRef = ref(null)</span><br><span class="line"></span><br><span class="line">    const addContent = () =&gt; &#123;</span><br><span class="line">      message.value += &quot;哈哈哈哈哈哈哈哈哈&quot;</span><br><span class="line">      // console.log(titleRef.value.offsetHeight);</span><br><span class="line">      nextTick(() =&gt; &#123;</span><br><span class="line">        console.log(titleRef.value.offsetHeight);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>nextTick的回调函数会被加入到微任务队列之后，在微任务队列中，DOM更新完之后才轮到它执行</p><h3 id="其他补充">其他补充</h3><h4 id="1-render函数">1. render函数</h4><h5 id="1-1-认识-h-函数">1.1 认识 h 函数</h5><ul><li><p>绝大多数情况下，我们的HTML都是用模板<code>&lt;template&gt;</code>创建的，如果在一些特殊的场景，真的需要JavaScript的完全编程能力，这个时候可以使用 渲染函数，它比模板更接近编译器</p><ul><li><p>Vue在生成真实的 DOM 之前，会将我们的节点转换成 VNode（虚拟节点），而VNode组合在一起形成一棵树结构，就是虚拟DOM（VDOM）</p></li><li><p>你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode</p></li></ul></li><li><p>h()函数是一个用于创建 VNode 的函数</p></li></ul><h5 id="1-2-h-函数基本使用">1.2 h 函数基本使用</h5><ul><li>h() 函数接收三个参数，（标签名，组件名…）（属性）（子节点，内容）</li><li>h 函数可以在两个地方使用，render 函数选项中或者 setup 函数选项中</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// render 函数选项中</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, &#123;<span class="attr">class</span>: <span class="string">&quot;title&quot;</span>&#125;, <span class="string">&quot;Hello Render&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, &#123;<span class="attr">class</span>: <span class="string">&quot;title&quot;</span>&#125;, <span class="string">&quot;Hello Render&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220330152843095-16486253285831.png" alt="image-20220330152843095 " style="zoom:67%;" /><h5 id="1-3-h-函数实现计数器案例">1.3 h 函数实现计数器案例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, &#123;<span class="attr">class</span>: <span class="string">&quot;app&quot;</span>&#125;, [</span><br><span class="line">            <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">`当前计数:<span class="subst">$&#123;<span class="variable language_">this</span>.counter&#125;</span>`</span>),</span><br><span class="line">            <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;<span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">counter</span>++&#125;, <span class="string">&quot;+1&quot;</span>),</span><br><span class="line">            <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;<span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">counter</span>--&#125;, <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">        ])</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-jsx">2. jsx</h4><ul><li><p>在项目中使用 jsx 需要添加对 jsx 的支持</p><ul><li><p>安装Babel支持Vue的jsx插件</p><p><code>npm install @vue/babel-plugin-jsx -D</code></p></li><li><p>在 babel.config.js 配置文件中配置插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&quot;@vue/babel-plugin-jsx&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基本使用：计数器案例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span>.<span class="property">counter</span>++;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span>.<span class="property">counter</span>--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;this.counter&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;decrement&#125;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-认识-Teleport">3. 认识 Teleport</h4><p>(先了解一下)</p><p>在组件化开发中，我们封装一个组件A，在另外一个组件B中使用，p 那么组件A中template的元素，会被挂载到组件B中template的某个位置，最终形成一棵 DOM 树结构</p><p>但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置，这个时候就可以通过teleport完成</p><h4 id="4-认识-Vue-插件">4. 认识 Vue 插件</h4><p>通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式</p><ul><li><p>对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) &#123; <span class="comment">//</span></span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$name</span> = <span class="string">&quot;hillyee&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数类型：一个function，这个函数会在安装插件时自动执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins_function.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(pluginsFunction)</span><br><span class="line">app.<span class="title function_">use</span>(pluginsObject)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深入Vue3+Typescript学习⚡ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题 — JS篇</title>
      <link href="/2022/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87/"/>
      <url>/2022/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试题 — JS篇</p></blockquote><h3 id="问：JS-原始数据类型有哪些？引用数据类型有哪些？">问：JS 原始数据类型有哪些？引用数据类型有哪些？</h3><p>答：在JS中,存在7中原始数据类型,分别是：<br>boolean,null,undefined,number,string,symbol,bigint<br>引用类型：Object(包含普通对象 Object, 数组对象 Array, 正则对象 RegExp,日期对象 Date,数字函数 Math,函数对象 Function)</p><ul><li>Symbol表示独一无二的值，主要是用来定义对象的唯一属性名</li><li>bigint 可以表示任意大小的整数</li></ul><h3 id="问：请说出下面代码的运行结果，并解释原因">问：请说出下面代码的运行结果，并解释原因</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  person.<span class="property">age</span> = <span class="number">26</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hzj&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;fyq&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">test</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1) <span class="comment">// -&gt; &#123;name: &#x27;fyq&#x27;,age: 26&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2) <span class="comment">// -&gt; &#123; name: &#x27;hzj&#x27;,age: 18 &#125;</span></span><br></pre></td></tr></table></figure><p>答：因为在test函数传参的时候，实际上传递的是p1对象在堆中的内存地址值，所以通过调用person.age = 26确实改变了p1的值，但是随后person变成了另一块内存空间的地址，并且在最后将这个内存空间的地址返回，然后赋值给了p2</p><h3 id="问：下面代码的输出结果是什么？-和-操作符的优先级">问：下面代码的输出结果是什么？(. 和 = 操作符的优先级)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;n : <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.<span class="property">x</span> = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;</span><br><span class="line">      </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>) <span class="comment">// &#123;n:2&#125;</span></span><br></pre></td></tr></table></figure><p>首先我们要知道 在js的运算中&quot;.“和”=“运算符同时出现时，会先执行”.&quot;运算<br>所以 a.x = a = {n:2} --&gt; a.x = {n:2} --&gt; a = {n:2}</p><h3 id="问：0-1-0-2为什么不等于0-3？">问：0.1+0.2为什么不等于0.3？</h3><p>答：(进制转换) js在做数字计算的时候，0.1和0.2都会被转成二进制后无限循环，但是js采用的IEEE 754二进制浮点运算，最大可以存储53位有效数字，于是大于53位后面的会全部截掉，将会导致精度缺失。<br>(对阶运算) 由于指数位数不相同，运算时需要对阶运算，这部分也可能产生精度缺失</p><blockquote><p><a href="https://juejin.cn/post/6940405970954616839">https://juejin.cn/post/6940405970954616839</a><br><a href="https://juejin.cn/post/6844903680362151950">https://juejin.cn/post/6844903680362151950</a></p></blockquote><h3 id="你真的了解作用域吗？">你真的了解作用域吗？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>,b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    A = <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b++)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a++)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">A</span>(<span class="number">2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="‘1’-toString-为什么可以调用？">‘1’.toString()为什么可以调用？</h3><p>实际上这个语句运行的过程中做了以下几件事：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&quot;1&quot;</span>) <span class="comment">// 第一步：创建Object实例。</span></span><br><span class="line">s.<span class="title function_">toString</span>() <span class="comment">// 第二步：调用实例方法</span></span><br><span class="line">s = <span class="literal">null</span> <span class="comment">// 第三步：执行完方法立即销毁这个实例</span></span><br></pre></td></tr></table></figure><blockquote><p>创建Object实例。注意为什么不是String？由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类</p><p>整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean，Number和String</p></blockquote><h3 id="数据类型的判断-2">数据类型的判断</h3><ul><li><p><strong>typeof</strong>：能判断所有值类型，函数。不可对null、对象、数组进行精确判断，因为都返回object</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;str&quot;</span>); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2172141653n</span>); <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">// function</span></span><br><span class="line"><span class="comment">// 不能判别</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></li><li><p><strong>instanceof</strong>：可用于判断对象类型</p><blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// p1.__proto__ === Person.prototype</span></span><br><span class="line">p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">// true 即Person构造函数的prototype出现在实例p1的原型链上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false（str1不是对象实例）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Object.prototype.toString.call()</strong>：所有原始数据类型都能判断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">2</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>); <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>); <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>为什么要用call去调用toString方法呢？</p><p>借用Object原型对象上的toString方法，通过this绑定调用，返回<code>&quot;[object 类型]&quot;</code></p></blockquote><h3 id="如何判断变量是否为数组？">如何判断变量是否为数组？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr); <span class="comment">// true</span></span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr); <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="和-有什么区别？">== 和 === 有什么区别？</h3><ul><li><p>=== 叫严格相等，左右两边不仅值要相等，类型也要相等</p></li><li><p>== 对于一般情况，只要值相等就返回 true，但 == 还涉及一些类型转换，转换规则如下：</p><ul><li>两边类型是否相同，相同的话就比较值的大小，如：1==2 false</li><li>判断两边是否是 null 和 undefined，是的话就返回true</li><li>两边是否是 String 和 Number，是的话，就把String类型转换成 Number，再进行比较</li><li>判断其中一边是否是 Boolean，是的话就把Boolean转换成Number，再进行比较</li><li>如果其中一边为 Object，而另一边为String、Number或Symbol，会将Object转换成字符串，再进行比较</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="string">&quot;[object Object]&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="的结果是什么？">[ ] == ![ ]的结果是什么？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == ![] <span class="comment">// 逻辑运算需进行布尔值转换, [] -&gt; true</span></span><br><span class="line">[] == !<span class="literal">true</span></span><br><span class="line">[] == <span class="literal">false</span> <span class="comment">// false -&gt; 0</span></span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// [] 转换为数值，经过 [].valueOf() --&gt; []</span></span><br><span class="line"><span class="comment">// [].toString -&gt; &quot;&quot;</span></span><br><span class="line">    <span class="comment">// &quot;&quot;.toNumber() -&gt; 0</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="对象转原始类型是根据什么流程运行的？">对象转原始类型是根据什么流程运行的？</h3><p>对象转原始类型，会调用内置的 [ToPrimitive] 函数，对于该函数，其逻辑如下：</p><blockquote><p><code>Symbol.toPrimitive</code> 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</p></blockquote><ol><li>如果有Symbol.toPrimitive()方法，优先调用再返回</li><li>调用valueOf()，如果转换后为原始类型，则返回，否则继续</li><li>调用toString()，如果转换后为原始类型，则返回</li><li>如果都没有返回原始类型，会报错</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;5&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="number">1</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="如何让-if-a-1-a-2-条件成立？">如何让 if(a == 1 &amp;&amp; a == 2)条件成立？</h3><blockquote><p>如果 a 是对象，则在执行 == 比较的时候，会执行 valueOf 方法(或toString)，因此我们可以重写该方法让条件成立</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span>++</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="谈谈你对闭包的理解">谈谈你对闭包的理解</h3><h4 id="什么是闭包？">什么是闭包？</h4><p>MDN对JS闭包的解释：</p><blockquote><ul><li>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</li><li>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</li><li>在JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</li></ul></blockquote><p>也可以说：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</p><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><h4 id="闭包的产生">闭包的产生</h4><p>在某个内部函数的执行上下文创建时，会将父级函数的活动对象(VO)加到内部函数的 [[scope]]中，形成作用域链，所以即使父级函数的执行上下文销毁，但是因为其活动对象实际上还存储在内存中可被内部函数访问到，从而实现了闭包</p><h4 id="闭包的应用">闭包的应用</h4><ul><li><p>函数作为参数被传递</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="comment">// 这就是闭包</span></span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>函数作为返回值被返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">200</span></span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方</p></blockquote><h4 id="如何解决下面的循环输出问题？">如何解决下面的循环输出问题？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么全部输出6？如何改进让它输出1,2,3,4,5？</p><p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，输出i的时候，当前作用域没有，往上一层找，因为循环已结束，上层作用域中的i为6。因此会全部输出6</p><p>解决方法：</p><ol><li><p>利用IIFE，每次for循环时，把此时的 i 变量传递到定时器中</p><blockquote><p><strong>IIFE</strong>（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给定时器传入第三个参数，作为timer函数的第一个函数参数</p><blockquote><p>定时器从第三个参数开始是附加参数，一旦定时器到期，它们会作为参数传递给function</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ES6中的let</p><p>let是块级作用域，用let后，变量只在它所在的代码块生效，没有什么作用域链了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i = 1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i = 2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); </span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i = 3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以可以依次输出1,2,3,4,5</p></li></ol><h3 id="谈谈你对原型链的理解">谈谈你对原型链的理解</h3><ul><li><strong>原型对象和构造函数有何关系？</strong></li></ul><p>在JavaScript中，每当定义一个函数数据类型（普通函数、类）的时候，这个函数就会自带一个prototype属性，这个属性指向函数的原型对象</p><p>另外，这个原型对象会有一个constructor属性指回函数本身</p><p>当函数被new调用的时候，这个函数就称为了构造函数</p><p>new调用会创建一个实例对象，这个实例对象会自带一个<code>__proto__</code>属性，这个属性指向构造函数的原型对象</p><p>即<code>o.__proto__ === Foo.prototype</code></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e27264b5519e45b083a64fb8934f7a88~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><ul><li>描述一下原型链？</li></ul><p>JavaScript对象通过<code>__proto__</code>指向父类原型对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，即原型链</p><p>原型链最顶层的原型对象就是Object的原型对象</p><p>另外，检查对象自身是否包含某属性，可以使用 hasOwnProperty()</p><p>使用 in 的话，即使自身没有，但是原型链中有，也会返回true</p><blockquote><p>绿色箭头，原型链</p><p><code>o.__proto__.__proto__.__proto__</code></p></blockquote><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e945e58756d643809d5e0c6c6d2d6797~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><blockquote><p>带着掘金的各种文章一起看,找到自己想要的答案<br>做了一份前端面试复习计划，保熟～<br>链接：<a href="https://juejin.cn/post/7061588533214969892">https://juejin.cn/post/7061588533214969892</a><br>神十三-原生JS灵魂之问, 请问你能接得住几个<br>链接：<a href="https://juejin.cn/post/6844903974378668039">https://juejin.cn/post/6844903974378668039</a><br>字节跳动最爱考的前端面试题：JavaScript 基础<br>链接：<a href="https://juejin.cn/post/6934500357091360781">https://juejin.cn/post/6934500357091360781</a><br>「查缺补漏」送你 54 道 JavaScript 面试题<br>链接：<a href="https://juejin.cn/post/6854573211443544078#comment">https://juejin.cn/post/6854573211443544078#comment</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 😣面试题-js篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手</title>
      <link href="/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
      <url>/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1-TCP-三次握手过程">1. TCP 三次握手过程 ?</h4><p>（首先，两个概念：SYN：同步标志   ACK：确认标志）</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手：</p><p>第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态</p><p>第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</p><p>第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态</p><p>最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接</p><h4 id="2-为什么需要三次握手？两次不行吗？">2. 为什么需要三次握手？两次不行吗？</h4><p>其实这是由 TCP 的自身特点可靠传输决定的。</p><p>第一次握手，客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的</p><p>第二次握手，服务端发包，客户端收到了。这样客户端就能得出结论：服务端的发送能力、客户端的接收能力是正常的。</p><p>第三次握手，客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送，接收能力也正常。</p><h4 id="3-ISN-是固定的吗">3. (ISN) 是固定的吗?</h4><p>三次握手的一个重要功能是客户端和服务端交换 ISN ，以便让对方知道接下来接受数据的时候如何按序列号组装数据</p><p>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</p><h4 id="4-三次握手过程中可以携带数据吗">4. 三次握手过程中可以携带数据吗</h4><p>第三次握手的时候可以携带数据。因为假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常。然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，可能会让服务器更加容易受到攻击。</p><p>而对于第三次的话，客户端已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的，所以携带数据也没问题</p><h4 id="5-四次挥手？为什么要四次？">5. 四次挥手？为什么要四次？</h4><p>刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则：</p><p>刚开始双方都处于established状态，假如是客户端先发起关闭请求</p><p>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态</p><p>第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态</p><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态</p><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p><h4 id="6-SYN-攻击是什么？">6. SYN 攻击是什么？</h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h5 id="检测-SYN-攻击？">检测 SYN 攻击？</h5><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p><h5 id="常见的防御-SYN-攻击的方法？">常见的防御 SYN 攻击的方法？</h5><p>缩短超时时间</p><p>增加最大半连接数</p><p>过滤网关防护</p><p>SYN cookies技术</p><h4 id="7-什么是半连接队列？">7. 什么是半连接队列？</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_REVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，这种队列称之为半连接队列。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var_let_const区别</title>
      <link href="/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="var、let、const-相关">var、let、const 相关</h3><p>var（ES5）let,const（ES6）</p><h4 id="1-作用域？"><strong>1. 作用域？</strong></h4><p>简单来说，作用域就是一个独立的地盘，外层作用域无法读取内层作用域的变量，但是内层作用域可以访问外层作用域的变量或者定义外层作用域的同名变量。</p><h4 id="2-var-变量提升？-var-特点？"><strong>2. var 变量提升？ var 特点？</strong></h4><p>无论在全局作用域还是在局部作用域中，使用 var 关键字声明的变量都会被提升到该作用域的最顶部，这就是我们常说的<strong>变量提升</strong></p><p>在代码预编译的时候，JavaScript 引擎会自动将所有代码里面以var 关键字声明的语句提升到<strong>当前作用域</strong>的顶端</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span></span><br></pre></td></tr></table></figure><h4 id="var-的特点"><strong>var 的特点</strong></h4><ul><li><p>存在变量提升</p></li><li><p>在变量未赋值时，变量为 undefined</p></li><li><p>一个变量可以多次声明，后面的声明会覆盖前面的声明</p></li><li><p>在函数中使用 var 声明变量的时候，该变量是局部的（因为在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum)  <span class="comment">// 报错 sum is not defined</span></span><br></pre></td></tr></table></figure><p><strong>如果函数内不使用 var 声明，该变量是全局的</strong>，sum 被添加到全局上下文（window）window.sum</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-let"><strong>3. let</strong></h4><ul><li><p>let 不存在变量提升，let 声明变量前，该变量不能使用(暂时性死区)</p></li><li><p>let 为块级作用域，所有外面的语句块访问不到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value)  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>let <strong>不允许重复声明</strong>，如果在同一个作用域中某个变量已经存在，再次使用 let 关键字声明的话会报错</p></li></ul><h4 id="4-const"><strong>4. const</strong></h4><p>与 let 没什么大不同</p><ul><li><p>const 声明的是常量，常量就是一旦定义完就不能修改的值。</p></li><li><p>必须初始化值，否则会报错。</p></li><li><p>需要注意的是：const 变量不能再被重新赋值为其他引用值，但对象的键不受限制</p><p>也就是说，并不是变量的值不能改动，而是变量指向的那个内存地址不得改动</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1 = &#123;&#125; <span class="comment">// 报错，不能给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span> &#125;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;tony&quot;</span>  <span class="comment">// 没问题</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-暂时性死区？"><strong>5. 暂时性死区？</strong></h4><p>如果区块中存在 let 和 const 命令，以这个命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错</p><p>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”(temporal dead zone 简称 TDZ )</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// TDZ 开始</span></span><br><span class="line">    tmp = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp)</span><br><span class="line">    </span><br><span class="line">    tmp = <span class="number">123</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的死区</p><h4 id="6-在-for-循环中使用-var，let-的区别"><strong>6. 在 for 循环中使用 var，let 的区别</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line">&#125;  <span class="comment">// 输出全是10</span></span><br><span class="line"><span class="comment">// 因为 i 是全局变量，最后访问的都是全局变量</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line">&#125;  <span class="comment">// 0123456789; </span></span><br><span class="line"><span class="comment">// i 是局部变量，每次循环改变的是对局部变量赋值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04_实现call_apply_bind</title>
      <link href="/2022/03/30/04_%E6%89%8B%E5%86%99call-apply-bind/"/>
      <url>/2022/03/30/04_%E6%89%8B%E5%86%99call-apply-bind/</url>
      
        <content type="html"><![CDATA[<h3 id="call、apply、bind-实现">call、apply、bind 实现</h3><h4 id="1-call-实现">1. call 实现</h4><p>首先我们要知道系统的 call 方法主要实现了什么</p><ul><li>执行了函数</li><li>改变了 this 的指向</li></ul><p>先看系统的call方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo函数被执行&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum函数被执行&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 传入对象</span></span><br><span class="line">foo.<span class="title function_">call</span>(&#123;&#125;) </span><br><span class="line"><span class="comment">// 2. 传入null/undefined</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// this自动替换为指向全局对象</span></span><br><span class="line"><span class="comment">// 3. 传入其他，字符串，数字，布尔值等等</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="string">&quot;abc&quot;</span>) <span class="comment">// this 指向相应的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = sum.<span class="title function_">call</span>(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b796e59e07f4560acdbfe38abe4ad79~tplv-k3u1fbpfcp-watermark.image?" alt="img0328_01.png"></p><p>接下来我们开始实现自己的call（主要是实现思路，没有把所有的边缘条件考虑完全，但是基本都有）</p><p><strong>1.1 让函数执行起来</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="variable language_">this</span> <span class="comment">// this就是我们想要执行的函数 foo,把它保存到 fn</span></span><br><span class="line">    <span class="comment">// 接着让函数执行起来</span></span><br><span class="line">    <span class="title function_">fn</span>() <span class="comment">// 但是这里是独立函数调用，this指向window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">mycall</span>() <span class="comment">// 这里相当于mycall隐式绑定了foo,因此 mycall中的this就是foo</span></span><br></pre></td></tr></table></figure><p><strong>2.2 显式绑定this</strong></p><p>现在我们要绑定我们指定的this</p><ul><li>先看第一种：<code>foo.mycall(&#123;name: 'hello'&#125;)</code>，绑定一个对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> <span class="comment">// this就是我们想要执行的函数 foo,把它保存到 fn</span></span><br><span class="line">  <span class="comment">// 接着调用这个函数</span></span><br><span class="line">  <span class="comment">// 我们的目的是让函数执行的时候绑定thisArg这个对象执行即thisArg.fn()(隐式绑定)</span></span><br><span class="line">  <span class="comment">// 但是现在 thisArg没有 fn 这个属性呀，怎么调用呢</span></span><br><span class="line">  <span class="comment">// 所以我们可以给thisArg添加一个属性 fn, 值就是我们想要执行的函数</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="comment">// 然后再调用</span></span><br><span class="line">  thisArg.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="comment">// 但是这样我们不就让thisArg多出来一个属性fn了吗？</span></span><br><span class="line">  <span class="comment">// 没关系，函数执行完 删掉就好</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果我们传入的不是对象呢？那就不能给thisArg添加属性啦</p><p><code>foo.mycall(&quot;123&quot;)</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> </span><br><span class="line">  <span class="comment">// 所以要把 thisArg 转成对象类型(Object构造函数可以将给定的值包装为一个新对象)</span></span><br><span class="line">  thisArg = <span class="title class_">Object</span>(thisArg)</span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  thisArg.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果传入的是 null / undefined 呢</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> </span><br><span class="line">  <span class="comment">// 如果thisArg传入的是 undefined / null, 应该让它指向全局对象</span></span><br><span class="line">  <span class="comment">// 所以我们要做一个判断</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  thisArg.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3 接下来要考虑参数了</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rest运算符</span></span><br><span class="line"><span class="comment">// ...args 会把我们传入的参数列表组合到一个数组 [num1,num2]</span></span><br><span class="line"><span class="comment">// ...args 也可以展开数组, 相当于对数组的一个遍历</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> </span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="comment">// 把参数传入函数，并用 result 接收函数执行完的结果(例子中就是sum函数执行完的结果)</span></span><br><span class="line">  <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...args) <span class="comment">// ...[num1, num2] --&gt; num1, num2</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">  <span class="comment">// 最后把结果返回出去</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，基本的call就已经实现了</p><p>检验一下叭</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">mycall</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line">foo.<span class="title function_">mycall</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">foo.<span class="title function_">mycall</span>(<span class="literal">undefined</span>)</span><br><span class="line">foo.<span class="title function_">mycall</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">sum.<span class="title function_">mycall</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>&#125;, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> res1 = sum.<span class="title function_">mycall</span>(<span class="number">123</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4b709b153349f7afbde95a6b9af35c~tplv-k3u1fbpfcp-watermark.image?" alt="image0328_02.png style=&quot;zoom:70%;&quot;"></p><h4 id="2-apply-实现">2. apply 实现</h4><p>跟 call 类似，只不过参数的处理有不同</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myapply</span> = <span class="keyword">function</span>(<span class="params">thisArg, argsArray</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="comment">// 没有传argArray,那么argsArray默认为 undefined,那么就不能使用展开运算符了</span></span><br><span class="line">  <span class="comment">// 所以如果没有传入参数, 那么把它初始化为 [], 空数组也是可以展开的 ...[]</span></span><br><span class="line">  argsArray = argsArray || []</span><br><span class="line">  <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...argsArray)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-bind-实现">3. bind 实现</h4><p>bind 需要我们返回一个新的函数，并且调用 bind 的时候不需要执行函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mybind</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    thisArg.<span class="property">fn</span> = fn</span><br><span class="line">    <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 需要返回一个新的函数 你也可以直接 return function() &#123;...&#125;</span></span><br><span class="line">  <span class="keyword">return</span> newFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上也差不多，但我们可以就下面这种情况改进一下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum2</span>(<span class="params">num1, num2, num3, num4</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum2函数被执行&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> num1 + num2 + num3 + num4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newSum2 = sum2.<span class="title function_">mybind</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">10</span>,<span class="number">20</span>) <span class="comment">// 绑定的时候传入了两个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newSum2</span>(<span class="number">30</span>,<span class="number">40</span>)); <span class="comment">// 使用新返回的函数的时候再传入剩余的参数</span></span><br></pre></td></tr></table></figure><p>这种情况，我们就需要把两次传入的参数合并起来，再调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mybind</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="comment">// 合并传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> allArgs = [...args, ...newArgs]</span><br><span class="line"></span><br><span class="line">    thisArg.<span class="property">fn</span> = fn</span><br><span class="line">    <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...allArgs)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，基本的bind也实现了</p><p>最后说明一下，实现的思路是这样，但是方法不唯一的，可能还有一些边边角角没有考虑到的话，可以自己添加进去</p>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03_JS函数的this指向</title>
      <link href="/2022/03/30/03_JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/"/>
      <url>/2022/03/30/03_JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h3 id="JS-函数的-this-指向">JS 函数的 this 指向</h3><h4 id="1-this-在全局作用域下的指向">1. this 在全局作用域下的指向</h4><p>在浏览器中，this在全局作用域下指向 window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span>) <span class="comment">// hello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">title</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h4 id="2-this-的四个绑定规则">2. this 的四个绑定规则</h4><h4 id="2-1-规则一：默认绑定">2.1 规则一：默认绑定</h4><p>在<strong>独立函数调用</strong>的情况下会使用默认绑定</p><p>独立函数调用简单来说就是它没有绑定到某个对象上进行调用，简单看几个例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo1</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo2</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo3</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>以上的函数调用的时候，都是没有被绑定到对象中调用的，所以 this 都指向 window</p><h4 id="2-2-规则二：隐式绑定">2.2 规则二：隐式绑定</h4><p>函数通过某个对象进行调用的时候，这个对象会被 js 引擎绑定到函数中的 this 里</p><p>下面看几个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn</span>() <span class="comment">// obj 对象</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: obj1.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.<span class="title function_">bar</span>() <span class="comment">// obj2对象</span></span><br></pre></td></tr></table></figure><h4 id="2-3-显式绑定">2.3 显式绑定</h4><p>利用 call，apply，bind手动指定 this 的绑定，这种明确的绑定称为显式绑定</p><p><strong>(1) call，apply</strong></p><p>call，apply 都是可以调用函数的</p><p>fn.call(自定的this指向，参数1，参数2)  fn.apply(this指向，[参数1，参数2])</p><p>两者的区别在于传参的方式，下面例子可以看出来 call 传入参数列表，apply是数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2, num3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2 + num3, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.<span class="title function_">call</span>(<span class="string">&quot;123&quot;</span>, <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>) <span class="comment">// 手动让this指向&quot;123&quot;</span></span><br><span class="line">sum.<span class="title function_">apply</span>(obj, [<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) <span class="comment">// 手动让this指向obj</span></span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc769b40fc274f32b225566e2b2dec07~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220327114447032.png"></p><p><strong>(2) bind</strong></p><p>bind不会调用函数，而是返回一个新的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2, num3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2 + num3, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var obj = &#123;</span></span><br><span class="line"><span class="comment">//   title: &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;</span></span><br><span class="line"><span class="comment">// sum.apply(obj, [20,30,40]) // 手动让this指向obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newSum = sum.<span class="title function_">bind</span>(<span class="string">&#x27;aaa&#x27;</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="title function_">newSum</span>() <span class="comment">// 60 String &#123;&#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>咦？newSum 不也是独立函数调用吗，怎么不指向 window 了</p><p>这就是默认绑定和显式绑定bind的冲突，显式绑定的优先级更高！</p><h4 id="2-4-new绑定">2.4 new绑定</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="comment">// 实际上这里是会把 this 返回出去的,即return this（默认）</span></span><br><span class="line">  <span class="comment">// this = 创建出来的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 会创建一个全新的对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jenny&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tony&quot;</span>, <span class="number">15</span>)</span><br></pre></td></tr></table></figure><h4 id="3-一些内置函数的-this-绑定">3. 一些内置函数的 this 绑定</h4><p>有时候我们会调用一些 JS 的内置函数，这些函数要求我们传入另外一个函数，并且我们不会自己去调用这些函数，而是 JS 内部会帮助我们执行。</p><p>这个时候，this 的绑定就跟内部帮我们指向函数的方式有关系了。</p><p>看几个例子吧</p><h5 id="3-1-setTimeout">3.1 setTimeout</h5><p>内部通过 apply 调用函数，并绑定了this对象，是window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h5 id="3-2-数组的内置函数-forEach">3.2 数组的内置函数 forEach</h5><p>默认情况下传入的函数是自动调用函数（默认绑定）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 三次 window</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以通过传入第二个参数，改变this指向</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 三次 &#x27;obj&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;obj&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="3-3-点击事件">3.3 点击事件</h5><p>在发生点击时，回调函数被调用，会将 this 绑定到该函数中</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>)</span><br><span class="line">box.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// box对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，某些内置的函数，我们很难确定它内部是如何调用传入的回调函数的，可以自己测试一下，记一下，看源码当然更好啦</p><h4 id="4-几个规则的优先级">4. 几个规则的优先级</h4><p>从高到低：new绑定 &gt; 显式绑定(bind) &gt; 隐式绑定 &gt; 默认绑定</p><p>new绑定和call，apply是不允许同时使用的，（毕竟都会调用函数），所以不存在谁的优先级更高</p><ul><li><p>显式绑定高于隐式绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式绑定和隐式绑定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// obj 对象</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// &#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>new 绑定高于隐式绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">foo</span>() <span class="comment">// 输出 foo 对象而不是 obj</span></span><br></pre></td></tr></table></figure></li><li><p>new 绑定高于bind</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj) <span class="comment">// 显式绑定obj</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">bar</span>() <span class="comment">// 打印 foo对象 而不是 obj</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-两种特殊情况">5. 两种特殊情况</h4><p><strong>5.1 在显式绑定中传入 null 或 undefined</strong></p><p>这时候，显式绑定会被忽略，使用默认规则</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj) <span class="comment">// obj</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p><strong>5.2 间接函数引用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来看一下这个赋值的结果, 是 foo 函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((obj2.<span class="property">foo</span> = obj1.<span class="property">foo</span>)); <span class="comment">// foo函数</span></span><br><span class="line"><span class="comment">// 这种叫做间接函数引用，是会把赋值语句右边的结果返回，然后直接调用，是独立函数调用</span></span><br><span class="line">(obj2.<span class="property">foo</span> = obj1.<span class="property">foo</span>)() <span class="comment">// 相当于直接调用 foo 函数，所以是默认绑定，输出window</span></span><br></pre></td></tr></table></figure><h4 id="6-箭头函数的this">6. 箭头函数的this</h4><p>箭头函数不绑定 this，也就是说它没有自己的 this，而是根据外层作用域来决定this</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 在这里this的外层作用域就是 window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// window</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>再来看一个案例：</p><p>使用<strong>setTimeout</strong>模拟一个网络请求，如果我们想把返回来的数据保存到 data 中，该怎么做</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">getData</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj 对象</span></span><br><span class="line">      <span class="comment">// 这里的 this 不是应该指向window吗？</span></span><br><span class="line">      <span class="comment">// 如果我们这里使用的是普通的函数 function() &#123;console.log(this)&#125;</span></span><br><span class="line">      <span class="comment">// 那么这个函数在内部调用的时候，会绑定this，就是window</span></span><br><span class="line">      <span class="comment">// 但是我们使用了箭头函数，它不绑定this，会往上层作用域中找到对应的this</span></span><br><span class="line">      <span class="comment">// 所以找到了 obj</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span> = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// --&gt; obj.data = &quot;hello&quot;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure><h4 id="7-this-的面试题">7. this 的面试题</h4><p>如果每题都会了，那么 this 绑定的问题，就是你的送分题而不是送命题了哈哈哈</p><p>建议把我的答案跟注释都删掉，自己一点点理清哦</p><p><strong>题一</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>; <span class="comment">// window.name = &quot;window&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">// window 很明显是独立函数调用,没有与任何对象关联</span></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">// person 隐式绑定,与person关联</span></span><br><span class="line">  (person.<span class="property">sayName</span>)(); <span class="comment">// person 同上(加括号只是代表这是一个整体)</span></span><br><span class="line">  <span class="comment">// console.log((b = person.sayName)); // 这里实际上就是sayName这个函数</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)(); <span class="comment">// 间接函数引用，是独立函数调用, 输出 window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure><p><strong>题二</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定person1对象</span></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// person1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定person2</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2);  <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数不适用任何规则, 向上层作用域中找this</span></span><br><span class="line">person1.<span class="title function_">foo2</span>(); <span class="comment">// window</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3()返回了一个函数，然后独立调用</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3.call(person2) 返回的是一个函数，然后独立调用</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3()返回一个函数，然后显式绑定到 person2</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2); <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4()返回一个箭头函数，往上层作用域找，找到foo4中绑定的this,是 person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>()(); <span class="comment">// person1</span></span><br><span class="line"><span class="comment">// foo4显式绑定到 person2</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// person1.foo4()返回箭头函数，往上层作用域找</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2); <span class="comment">// person1</span></span><br></pre></td></tr></table></figure><p><strong>题三</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo1</span>() <span class="comment">// person1 隐式绑定</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2) <span class="comment">// person2 显式绑定</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>() <span class="comment">// person1 隐式绑定</span></span><br><span class="line"><span class="comment">// 箭头函数不适用显式绑定规则，直接向上层作用域找</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2) <span class="comment">// person1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3() 返回一个函数，在全局调用</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()() <span class="comment">// window</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window // 同理</span></span><br><span class="line"><span class="comment">// person1.foo3() 返回的函数使用 .call 显式绑定 person2</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2) <span class="comment">//person2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4() 返回一个箭头函数，再调用，向上层作用域找</span></span><br><span class="line">person1.<span class="title function_">foo4</span>()() <span class="comment">// person1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4.call(person2) 返回箭头函数，并且foo4显式绑定this为person2</span></span><br><span class="line"><span class="comment">// 再调用这个箭头函数，向上找就找到 foo4 的this 为person2</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4() 返回箭头函数,不适用显式绑定，向上找到 person1</span></span><br><span class="line"><span class="comment">// 注意这里跟上面的区别，这里的foo4调用不是.call调用的，而是.foo4()这样调用的</span></span><br><span class="line"><span class="comment">// call是来调用箭头函数的，而箭头函数不适用显式绑定，向上找到的是person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2) <span class="comment">// person1</span></span><br></pre></td></tr></table></figure><p><strong>题四</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.obj.foo1()返回一个函数，在全局中调用</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>()() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// person1.obj.foo1.call(person2) 返回一个函数 在全局中调用</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo1</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// person1.obj.foo1() 返回一个函数，显式绑定person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>().<span class="title function_">call</span>(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数调用，向上找到 foo2 中的this是obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>()() <span class="comment">// obj</span></span><br><span class="line"><span class="comment">// foo2调用的时候显式绑定person2，箭头函数向上层找到的就是person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo2</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// 箭头函数不适用 显式绑定，向上找找到 obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>().<span class="title function_">call</span>(person2) <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02_JS内存管理和闭包</title>
      <link href="/2022/03/30/02_JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2022/03/30/02_JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JS-的内存管理">一、JS 的内存管理</h2><h4 id="1-JS-的内存管理">1. JS 的内存管理</h4><ul><li>JavaScript 会在定义变量时为我们分配内存</li><li>内存分配的方式是一样的吗？<ul><li>JS 对于基本数据类型内存的分配，会在执行时直接在栈空间进行分配</li><li>JS 对于复杂数据类型内存的分配，会在堆内存中开辟一块空间，并且将这块空间的地址保存在栈空间</li></ul></li></ul><h4 id="2-JS-的垃圾回收">2. JS 的垃圾回收</h4><ul><li>垃圾回收的英文是 Garbage Collection，简称 GC</li><li>对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放出更多的内存空间</li><li>JavaScript的运行环境 js引擎都会内存垃圾回收器</li></ul><h4 id="3-常见的两个-GC-算法">3. 常见的两个 GC 算法</h4><p>GC怎么知道哪些对象是不再使用的呢？这里就要用到 GC 算法了</p><h5 id="3-1-引用计数"><strong>3.1 引用计数</strong></h5><ul><li><p>当一个对象有一个引用指向它的时候，那么这个对象的引用就 +1，当一个对象的引用为 0 时，这个对象就可以被回收掉</p></li><li><p>但是这个算法有一个很大的弊端，就是会产生循环引用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">friend</span>: obj2&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">friend</span>: obj1&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5ae097e453a43cc84b2ff11211ac823~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220326000211839.png"></p><hr><h5 id="3-2-标记清除">3.2 标记清除</h5><ul><li>这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d16ee47dfe794e74a2cef9747d341bcc~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220326000504460.png"></p><p>​图中从 A 开始找，找到 D 的时候结束，M,N不可达，被认为是不可用的对象</p><ul><li>这个算法可以很好的解决循环引用的问题</li></ul><p>注：JS 引擎比较广泛采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，在算法的实现细节上也会结合一些其他的算法</p><h2 id="二、JS中的闭包">二、JS中的闭包</h2><h4 id="1-什么是闭包？">1. 什么是闭包？</h4><p>JavaScript 中的一个函数，如果它访问了外层作用域的变量，那么这个函数是一个闭包。</p><p>MDN中的一个解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name)<span class="comment">// name访问了外层作用域的变量name</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// age访问了外层作用域的变量age</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bar <span class="comment">// 返回一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h4 id="2-闭包的访问过程">2. 闭包的访问过程</h4><p>简单描述上面函数的执行过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="attr">GO</span>: &#123;<span class="attr">foo</span>:地址<span class="number">1</span>, <span class="attr">fn</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="number">2.</span> 执行代码：</span><br><span class="line">   <span class="number">2.1</span> <span class="title function_">foo</span>():只要执行函数，就会创建一个函数执行上下文</span><br><span class="line">     (<span class="number">1</span>)<span class="attr">VO</span>: &#123;<span class="variable constant_">AO</span>对象:&#123;<span class="attr">name</span>: <span class="literal">undefined</span>;<span class="attr">age</span>:<span class="literal">undefined</span>;<span class="attr">bar</span>:地址<span class="number">2</span>&#125;&#125;</span><br><span class="line">        <span class="attr">scopechain</span>:[<span class="variable constant_">VO</span>+parent scopes]</span><br><span class="line"> (<span class="number">2</span>)开始执行代码 &#123;<span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>;&#125; <span class="keyword">return</span> bar地址<span class="number">2</span></span><br><span class="line"> (<span class="number">3</span>)foo执行完毕</span><br><span class="line">   <span class="number">2.2</span> <span class="attr">fn</span>: bar地址<span class="number">2</span></span><br><span class="line">   <span class="number">2.3</span> <span class="title function_">fn</span>(),即执行 bar地址<span class="number">2</span>中的函数执行体,创建bar的函数执行上下文</span><br><span class="line">      (<span class="number">1</span>)&#123;<span class="attr">AO</span>:&#123;&#125;,scopechain&#125;</span><br><span class="line">       (<span class="number">2</span>)执行代码:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name):在自己的<span class="variable constant_">AO</span>中找不到，通过作用域链找到foo的<span class="variable constant_">AO</span>，找到<span class="attr">name</span>:<span class="string">&quot;foo&quot;</span>,输出 <span class="string">&quot;foo&quot;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(age)同理</span><br><span class="line">   (<span class="number">3</span>)<span class="title function_">fn</span>()执行完毕</span><br><span class="line"><span class="number">3.</span>执行完毕</span><br><span class="line">地址<span class="number">1</span>:foo函数对象: &#123;<span class="attr">parentScope</span>: <span class="variable constant_">GO</span>&#125;,&#123;foo函数的执行体&#125;</span><br><span class="line">地址<span class="number">2</span>:bar函数对象: &#123;<span class="attr">parentScope</span>: foo的<span class="variable constant_">AO</span>对象&#125;,&#123;bar函数的执行体&#125;</span><br></pre></td></tr></table></figure><p>你可能会有疑惑：foo函数执行完毕之后，不是应该弹出栈吗，foo的AO对象不应该被释放了吗？怎么bar还能找到 name，找到 age 呢？</p><p>看下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0596bf34709b420e83d0b18255b35a8e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220326190828378.png"></p><p>可以看到，当我们执行完 foo 函数的时候，返回的是 bar 函数(或者说是bar的地址)，然后因为 <code>fn = foo()</code>，把这个地址赋值给了fn，因此会存在 fn 指向 bar函数对象，而bar的父作用域又指向了 foo 的AO对象，因此foo的AO是不会被释放的</p><h4 id="3-闭包的内存泄漏">3. 闭包的内存泄漏</h4><p><strong>为什么总说闭包是有内存泄漏的呢？什么是内存泄漏？</strong></p><p>拿上面的例子说，如果后续我们不会再用 foo，bar 这些函数了，但是在全局作用域下 fn 变量对bar函数对象有引用，而bar的作用域中AO对foo的AO有引用，所以会造成这些内存都是无法被释放的。</p><p>这就是我们所说的内存泄漏，其实就是刚才的引用链中的对象无法释放</p><p><strong>怎么解决这个问题呢？</strong></p><p>很简单，设置 fn = null，就不再对 bar 函数对象有引用，那么从GO出发，bar是不可达的，那么对应的AO对象(foo) 同样也就不可达。</p><p>在下一次 GC 的的检测中，它们就会被销毁掉</p><p><strong>还有一个问题，形成闭包之后，是不是所有的属性都不会被释放呢？</strong></p><p>还是这个例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="comment">// console.log(age) </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><p>如果age不使用了，会不会被销毁掉呢？<br>答案是会的，测试如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf0ce1e854b45628e802630620b740b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220327110308371.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ae9ba0420c41a0bc10be84501afbd4~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220327110407999.png"></p><p>这是因为 V8 引擎做的优化，因为规范中闭包的属性应该是不会被销毁的</p>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01_深入JS运行原理</title>
      <link href="/2022/03/30/01_%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/30/01_%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-从输入-URL-到页面展示-发生了什么？">1. 从输入 URL 到页面展示 发生了什么？</h3><p>​总体分为以下过程：</p><ul><li>DNS 域名解析：将域名解析成 IP 地址</li><li>TCP 连接：TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ul><h3 id="2-浏览器工作原理">2. 浏览器工作原理</h3><p>在浏览器中输入查找内容，浏览器是怎样将页面加载出来的？</p><p>大致流程如下：</p><ul><li>首先，用户输入服务器地址，与服务器建立连接</li><li>服务器返回对应的静态资源（index.html）</li><li>然后浏览器拿到 index.html 后进行解析</li><li>当解析时遇到 css 或 js 文件，就向服务器请求并下载对应的 css 和 js 文件</li><li>最后浏览器对页面进行渲染，执行 js 代码</li></ul><h3 id="3-浏览器渲染过程">3. 浏览器渲染过程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fceb0c8f81764c578d11e3b428d9ec61~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325160129577.png"></p><ol><li><p>HTML Parser 将 HTML解析转换成 DOM 树</p></li><li><p>CSS Parser 将 样式表转换成 CSS 规则树</p></li><li><p>合并 DOM 树和 CSS 规则树，生成 render（渲染） 树</p></li><li><p>布局 render 树（Layout）</p><p>通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</p></li><li><p>绘制 render 树（painting），进行 Display 展示</p></li></ol><p>注意图中顶部的紫色 DOM 三角形，实际上是 js 对 DOM 的相关操作。</p><h3 id="4-一个强大的-JavaScript-引擎-—-V8-引擎">4. 一个强大的 JavaScript 引擎 — V8 引擎</h3><p>在解析 HTML 的过程中，遇到了 JavaScript 标签，该怎么办呢？</p><ul><li>会停止解析 HTML ，而去加载和执行 JavaScript 代码</li></ul><p>那么，JavaScript 代码由谁来执行呢？</p><ul><li><p>JavaScript 引擎</p><p>高级的编程语言最终都要转成机器指令来执行的，</p><p>所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行</p></li></ul><h4 id="（1）V8-引擎的架构">（1）V8 引擎的架构</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b0f83a00e64e2587ab3d79a4c524fd~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325165859884.png"></p><p>V8 的底层架构主要有三个核心模块（Parse、Ignition、TurboFan）</p><p><strong>1. Parse</strong>：</p><p>该过程主要是对 JavaScript 源代码进行<strong>词法分析</strong>和<strong>语法分析</strong>。</p><p><strong>词法分析</strong>：对代码中的每一个词每一个符号进行解析，最终生成很多 tokens</p><p>例如：对 const name = “curry”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先对const进行解析，因为const为一个关键字，所以类型会被记为一个关键词，值为const</span></span><br><span class="line"><span class="attr">tokens</span>: [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;keyword&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;const&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着对name进行解析，因为name为一个标识符，所以类型会被记为一个标识符，值为name</span></span><br><span class="line"><span class="attr">tokens</span>: [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;keyword&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;const&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;identifier&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;name&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以此类推...</span></span><br></pre></td></tr></table></figure><p><strong>语法分析</strong>：在词法分析的基础上，拿到 tokens 中的一个个对象，根据不同类型，再进一步分析具体语法，最终生成 AST 抽象语法树</p><p>可以详细查看通过 Parse 转换后的 AST 的工具：AST Explorer</p><p><strong>2. Ignition</strong></p><p>一个解析器，可以将 AST 转换成 ByteCode（字节码）</p><p><strong>3. TurboFan</strong></p><p>一个编译器，可以将字节码编译为 CPU 认识的机器码</p><h4 id="（2）V8-引擎的执行过程">（2）V8 引擎的执行过程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f816f1a12884ef6bf8fe4ffec33a2ce~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325171051967.png"></p><ul><li>Blink 内核将 JS 源码交给 V8 引擎</li><li>Stream 获取到 JS 源码进行编码转换</li><li>Scanner 进行词法分析，将代码转换成 tokens</li><li>Parser 和 PreParser<ul><li>Parser ：直接解析，将 tokens 转成 AST 树</li><li>PreParser：预解析，对不必要的函数进行预解析，也就是只解析暂时需要的内容，而在函数被调用时才进行函数的全量解析</li></ul></li><li>生成 AST 树后，会被 Ignition 转成字节码，之后就是代码的执行过程</li></ul><h3 id="5-JavaScript-的执行过程">5. JavaScript 的执行过程</h3><p>假如要执行如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> title = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">30</span></span><br><span class="line"><span class="keyword">var</span> result = num1 + num2</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><p>（1）首先，<strong>代码被解析</strong>，V8 引擎内部会帮助我们创建一个全局对象：Global Object（GO）</p><ul><li><p>GO 可以访问所有的作用域</p></li><li><p>里面会包含 Date、Array、String、setTimeout等等（所以我们可以直接 new Date() ）</p></li><li><p>GO 还有一个window 属性指向自己（所以window.window.window还是指向 GO自己）</p></li></ul><p>用伪代码表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalObject = &#123;</span><br><span class="line">    <span class="title class_">String</span>: 类,</span><br><span class="line">    <span class="attr">setTimeout</span>: 函数,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">window</span>: globalObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<strong>然后运行代码</strong></p><ol><li><p>首先我们要知道 js 引擎内部有一个<strong>执行上下文栈</strong>（Execution Context Stack，简称 ESC），它是用于执行代码的调用栈。</p></li><li><p>为了全局代码能够正常执行，首先需要创建一个**全局执行上下文 **（Global Execution Context，简称GEC），全局代码需要被执行时才会创建</p></li><li><p>然后全局执行上下文会被放入执行上下文栈中执行，包含两个部分：</p><ul><li>在代码执行前，会将全局定义的变量，函数等加入到 <strong>GlobalOject</strong> 中，但是并不会赋值（也称为<strong>变量的作用域提升</strong>）</li></ul></li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/848e146926d641b99e2b502e31c08913~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325191605422.png"></p><ul><li><p>开始依次执行代码：</p><p>title = “hello” // 赋值</p><p>console.log(num1) // undefined, 不会报错</p><p>num1= 20 …</p></li></ul><p><strong>遇到函数如何执行?</strong></p><p>先根据函数体创建一个<strong>函数执行上下文</strong>，并且压入到执行上下文栈中（EC Stack）</p><blockquote><p>在初始化 GO 的时候，函数的 AO 也是会被初始化的</p><p>比如说 ，全局中，有function foo() {}，一开始初始化GO的时候从上到下执行到 foo</p><p>会在内存中创建foo，并且保存作用域链到foo的内部属性[[scope]]，即</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line"> globalContext.<span class="property">VO</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p><strong>作用域链？</strong></p><p>由 VO(变量对象，在函数中就是 AO 对象)和 父级 VO组成，查找时会一层层查找</p><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello Global&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// Hello Global</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;Hello Bar&quot;</span></span><br><span class="line">  <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure><p>比如说这里，当执行 foo 函数的时候， foo 的 AO 中没有message，就会去它的父级 VO 中查找。一定要注意！当第一次代码解析的时候， foo 的函数执行上下文就已经确定了，其中包括三部分：</p><ul><li><p>第一部分：在解析函数成为 AST 树结构的时候，会创建一个 AO（Activation）</p><p>其中包含形参、arguments、函数定义、指向函数对象或定义的变量</p></li><li><p>第二部分：就是作用域链</p></li><li><p>第三部分：this 绑定的值</p></li></ul><p>因此！当foo在自己的AO找不到message的时候，去父级 VO 找，这个父级 VO 就是一开始解析时候保存的 GO，所以message为 “Hello Global”</p><p>简单描述一下这个过程吧：(我不专业的表达)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 GO</span></span><br><span class="line"><span class="attr">GO</span>: &#123;<span class="variable language_">window</span>; <span class="attr">message</span>:<span class="literal">undefined</span>; <span class="attr">foo</span>: 地址<span class="number">1</span>; <span class="attr">bar</span>: 地址<span class="number">2</span>;&#125;</span><br><span class="line"><span class="comment">// 执行代码</span></span><br><span class="line"><span class="attr">GO</span>: &#123;<span class="variable language_">window</span>; <span class="attr">message</span>:<span class="string">&quot;Hello Global&quot;</span>; <span class="attr">foo</span>: 地址<span class="number">1</span>; <span class="attr">bar</span>: 地址<span class="number">2</span>;&#125;</span><br><span class="line">bar函数执行,创建一个函数执行上下文,</span><br><span class="line">其中包括 <span class="variable constant_">VO</span>对象: <span class="attr">AO</span>:&#123;<span class="attr">message</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line">然后开始执行 bar函数</span><br><span class="line"><span class="attr">message</span>:<span class="string">&quot;Hello Bar&quot;</span> (赋值)</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">  foo函数执行，创建一个foo的函数执行上下文</span><br><span class="line">  其中包括：<span class="attr">VO</span>: <span class="attr">AO</span>: &#123;&#125; </span><br><span class="line">  然后开始执行代码</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">  发现自己的<span class="variable constant_">AO</span>没有message,会向上找，即从自己保存的父级<span class="variable constant_">VO</span>中查找，找到<span class="variable constant_">GO</span>中的message为 <span class="string">&quot;Hello Global&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5dfbf8412334fbfbec579813c39c58d~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325231532928.png"><br>(图来源于coderwhy)</p><blockquote><p>JS执行上下文：<a href="https://github.com/mqyqingfeng/Blog/issues/8">https://github.com/mqyqingfeng/Blog/issues/8</a></p><p>写的挺清晰详细的</p></blockquote><h4 id="几道常见的作用域提升面试题：">几道常见的作用域提升面试题：</h4><ol><li></li></ol> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  n = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">200</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">100</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  m = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ol start="5"><li></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">10</span></span><br><span class="line">  <span class="comment">// =&gt; 转成下面的两行代码</span></span><br><span class="line">  <span class="comment">// var a = 10</span></span><br><span class="line">  <span class="comment">// b = 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(a) // 报错 a is not defined(因为当 foo函数执行完之后，foo的函数执行上下文就会弹出栈(没啦！哪里还会有a呢))</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🔫深入JS高级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/29/hello-world/"/>
      <url>/2022/03/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

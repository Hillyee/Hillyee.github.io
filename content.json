{"meta":{"title":"Hillyee-blog","subtitle":"","description":"","author":"Hillyee","url":"https://hillyee.github.io","root":"/"},"pages":[{"title":"Categories","date":"2022-04-04T05:24:16.895Z","updated":"2022-04-04T05:24:16.895Z","comments":false,"path":"categories/index.html","permalink":"https://hillyee.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2022-04-07T09:20:54.207Z","updated":"2022-04-07T09:20:54.207Z","comments":false,"path":"about/index.html","permalink":"https://hillyee.github.io/about/index.html","excerpt":"","text":"🙈🙉🙊🐵🐒 普通二本大三菜菜 正在努力学前端 可以一起交流学习喔 😊 wechat: yuzibbing 不要逃避困难的东西 不要怕 😫 相信自己 我可以！！！🤞"},{"title":"Tags","date":"2022-04-04T05:24:25.480Z","updated":"2022-04-04T05:24:25.480Z","comments":false,"path":"tags/index.html","permalink":"https://hillyee.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-30T05:15:58.514Z","updated":"2022-03-30T05:15:58.514Z","comments":false,"path":"repository/index.html","permalink":"https://hillyee.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"手写promise","slug":"手写promise","date":"2022-04-17T15:24:47.000Z","updated":"2022-04-17T15:28:55.348Z","comments":true,"path":"2022/04/17/手写promise/","link":"","permalink":"https://hillyee.github.io/2022/04/17/%E6%89%8B%E5%86%99promise/","excerpt":"","text":"手写Promise Promise规范 https://promisesaplus.com/ PromiseA+规范 A+规范只有then方法 Promise 类设计 class MyPromise &#123;&#125; function MyPromise() &#123;&#125; 两种方式，我选第一种 构造函数constructor设计 实现： 让executor函数执行起来 定义状态常量 定义resolve，reject回调，执行的时候改变状态 const STATUE_PENDING = &#x27;pending&#x27;const STATUE_FULFILLED = &#x27;fulfilled&#x27;const STATUS_REJECTED = &#x27;rejected&#x27;class MyPromise &#123; constructor(executor) &#123; // 保存状态与值 this.status = STATUE_PENDING // 由于后面的then方法可能会用到这些参数值，需要保存起来 this.value = undefined this.reason = undefined // 定义resolve回调 const resolve = (value) =&gt; &#123; // 改变状态并保存值 this.status = STATUE_FULFILLED this.value = value console.log(&quot;resolve执行&quot;, value); &#125; // 定义reject回调 const reject = (reason) =&gt; &#123; // 改变状态并保存值 this.status = STATUS_REJECTED this.reason = reason console.log(&quot;reject执行&quot;, reason); &#125; executor(resolve, reject) &#125;&#125;const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); resolve(&quot;111&quot;) reject(&quot;222&quot;)&#125;) 为了不让resolve，reject回调可以同时执行，我们需要加一个判断，只有状态为pending的时候才执行回调 const resolve = (value) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; // 加一个判断 this.status = STATUE_FULFILLED this.value = value console.log(&quot;resolve执行&quot;, value); &#125;&#125;const reject = (reason) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; // 加一个判断 this.status = STATUS_REJECTED this.reason = reason console.log(&quot;reject执行&quot;, reason); &#125;&#125; then 方法的实现 简单实现 then方法接收两个参数，分别是成功时的回调onFulfilled，失败时的回调onRejected 把回调保存到当前的promise实例，并在对应的resolve，reject回调时执行 class MyPromise &#123; constructor(executor) &#123; this.status = STATUE_PENDING this.value = undefined this.reason = undefined const resolve = (value) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; this.status = STATUE_FULFILLED this.value = value console.log(&quot;resolve执行&quot;, value); this.onFulfilled(this.value) // 在这里执行 &#125; &#125; const reject = (reason) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; this.status = STATUS_REJECTED this.reason = reason console.log(&quot;reject执行&quot;, reason); this.onRejected(this.reason) // 在这里执行 &#125; &#125; executor(resolve, reject) &#125; then(onFulfilled, onRejected) &#123; this.onFulfilled = onFulfilled // 保存方法 this.onRejected = onRejected // 保存方法 &#125;&#125;const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); resolve(&quot;111&quot;) reject(&quot;222&quot;)&#125;)promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res);&#125;, err =&gt; &#123; console.log(&quot;err: &quot;, err);&#125;) 这时候我们会发现，报错了：this.onFulfilled is not a function 为什么？？ 我们捋一捋代码的执行过程就可以发现，当执行resolve(&quot;111&quot;) 的时候，都还没有到then那一步，也就是说还没执行then方法，那么怎么可能会有 onFulfilled, onRejected 方法呢！ 这时候我们就用到了一个方法：queueMicrotask() MDN：https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask 简单来说，这个方法可以把我们传入的方法加入到微任务队列，让它延迟到当前主线程的任务执行完之后再执行 所以可以在resolve方法执行的时候，先不执行onFulfilled，把它加入到微任务队列，接着就会继续执行下面的then方法，这时候就有onFulfilled, onRejected 方法了，最后主线程任务执行完，再执行微任务队列中的 onFulfilled，，（reject同理） const resolve = (value) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; queueMicrotask(() =&gt; &#123; // 加入到微任务队列 this.status = STATUE_FULFILLED this.value = value this.onFulfilled(this.value) &#125;) &#125;&#125;const reject = (reason) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; queueMicrotask(() =&gt; &#123; // 加入到微任务队列 this.status = STATUS_REJECTED this.reason = reason this.onRejected(this.reason) &#125;) &#125;&#125; 但是这个时候又出现了一个问题，resolve和reject可以同时调用了 因为我们执行resolve的实现，加入到微任务队列，因此状态没有被改变，依然是pending 接着执行reject，判断状态是pending，所以也加入到微任务队列了 解决：在执行微任务的代码一开始加入一个判断，如果状态已经不是pending了，直接return出去，停止执行 const resolve = (value) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; queueMicrotask(() =&gt; &#123; if (this.status !== STATUE_PENDING) return // 添加判断 this.status = STATUE_FULFILLED this.value = value this.onFulfilled(this.value) &#125;) &#125;&#125;const reject = (reason) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; queueMicrotask(() =&gt; &#123; if (this.status !== STATUE_PENDING) return // 添加判断 this.status = STATUS_REJECTED this.reason = reason this.onRejected(this.reason) &#125;) &#125;&#125; 当然，有人可能会说把状态改变放到微任务外面不就行了吗？ 不行！！这样在后面实现链式调用会出现问题 你后面可以试一下，多个then执行和链式调用一起的时候，执行顺序是有问题的 至于为什么，那就自己捋一捋整个代码的执行顺序叭 同时调用多个then的实现 上面的实现是不能同时调用多个then的 promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res);&#125;, err =&gt; &#123; console.log(&quot;err: &quot;, err);&#125;)promise.then(res =&gt; &#123; console.log(&quot;res2: &quot;, res);&#125;, err =&gt; &#123; console.log(&quot;err2: &quot;, err);&#125;) 后面的then会覆盖前面的，因此只会执行 res2 或者 err2 实现思路：我们需要把then传入的回调保存到一个数组，到时候一起执行 class MyPromise &#123; constructor(executor) &#123; this.status = STATUE_PENDING this.value = undefined this.reason = undefined this.onFulfilledCallbacks = [] // 定义数组存放成功的回调 this.onRejectedCallbacks = [] // 定义数组存放失败的回调 const resolve = (value) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; queueMicrotask(() =&gt; &#123; // 加入到微任务队列 if (this.status !== STATUE_PENDING) return this.status = STATUE_FULFILLED this.value = value // 用forEach遍历执行数组中的回调 this.onFulfilledCallbacks.forEach(fn =&gt; &#123; fn(this.value) &#125;) &#125;) &#125; &#125; const reject = (reason) =&gt; &#123; if (this.status === STATUE_PENDING) &#123; queueMicrotask(() =&gt; &#123; // 加入到微任务队列 if (this.status !== STATUE_PENDING) return this.status = STATUS_REJECTED this.reason = reason // 用forEach遍历执行数组中的回调 this.onRejectedCallbacks.forEach(fn =&gt; &#123; fn(this.reason) &#125;) &#125;) &#125; &#125; executor(resolve, reject) &#125; then(onFulfilled, onRejected) &#123; this.onFulfilledCallbacks.push(onFulfilled) // 保存到数组 this.onRejectedCallbacks.push(onRejected) &#125;&#125;const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); resolve(&quot;111&quot;) reject(&quot;222&quot;)&#125;)promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res);&#125;, err =&gt; &#123; console.log(&quot;err: &quot;, err);&#125;)promise.then(res =&gt; &#123; console.log(&quot;res2: &quot;, res);&#125;, err =&gt; &#123; console.log(&quot;err2: &quot;, err);&#125;) 延迟调用then 还有一种情况：resolve或reject执行完之后，延迟执行then const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); resolve(&quot;111&quot;) // reject(&quot;222&quot;)&#125;)setTimeout(() =&gt; &#123; promise.then(res =&gt; &#123; console.log(&quot;res3: &quot;, res); &#125;, err =&gt; &#123; console.log(&quot;err3: &quot;, err); &#125;)&#125;, 1000) setTimeout 会在主线程的任务执行完，并且微任务队列也执行完后才执行 捋一捋执行顺序： 首先主线程 resolve(&quot;111&quot;)执行，先改变状态为fulfilled，保存value，然后在微任务队列中加入一个任务 然后继续往下，setTimeout 被加入到宏任务队列，并未执行then 主线程任务执行完，执行微任务队列中的任务，遍历数组中的函数并执行，但我们可以看到，前面then没有执行，数组中并没有对应回调，所以没有执行 接着执行宏任务队列中setTimeout，也就是then方法被执行， 这个时候才把回调加入数组。。。任务结束 因此可以想到实现思路：在then方法中加入判断，如果当前状态是确定的，（fulfilled或rejected），那么直接执行这个回调，不用添加到数组 then(onFulfilled, onRejected) &#123; if (this.status === STATUE_FULFILLED &amp;&amp; onFulfilled) &#123; onFulfilled(this.value) &#125; if (this.status === STATUS_REJECTED &amp;&amp; onRejected) &#123; onRejected(this.reason) &#125; if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(onFulfilled) this.onRejectedCallbacks.push(onRejected) &#125;&#125; 链式调用then then需要返回一个promise，后面才能继续调用then 并且下一次的then是在上次回调执行完之后才执行的，而且需要拿到上次onFulfilled/onRejected 执行完之后的结果，再去执行resolve，reject then(onFulfilled, onRejected) &#123; if (this.status === STATUE_FULFILLED &amp;&amp; onFulfilled) &#123; onFulfilled(this.value) &#125; if (this.status === STATUS_REJECTED &amp;&amp; onRejected) &#123; onRejected(this.reason) &#125; if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(onFulfilled) this.onRejectedCallbacks.push(onRejected) &#125; return new MyPromise((resolve, reject) =&gt; &#123; resolve() // 这里需要拿到上次回调的结果并且传进去 reject() &#125;)&#125; 现在有个问题，就是怎么拿到上次执行的结果值？ 思路：把上面那一坨代码放到new里面执行，这样就让里边具备了拿到返回结果的能力 then(onFulfilled, onRejected) &#123; return new MyPromise((resolve, reject) =&gt; &#123; if (this.status === STATUE_FULFILLED &amp;&amp; onFulfilled) &#123; // 比如这里就可以拿到结果 const value = onFulfilled(this.value) // 然后再执行(这里已经是下一个promise的resolve了) resolve(value) &#125; if (this.status === STATUS_REJECTED &amp;&amp; onRejected) &#123; const reason = onRejected(this.reason) // 注意这里调用的应该是resolve，除非上一次的错误回调函数抛出了错误 resolve(reason) &#125; if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(onFulfilled) this.onRejectedCallbacks.push(onRejected) &#125; &#125;)&#125; 因为即使我们不链式调用，里面的代码还是会执行的，我们只是想拿到想要的结果，并且在某个时机调用 resolve, reject 两种情况都调用resolve？那什么时候调用reject呢？ 我们知道，只有在上次的then中抛出异常了，下次才会执行reject 所以我们再改进一下：使用try…catch then(onFulfilled, onRejected) &#123; return new MyPromise((resolve, reject) =&gt; &#123; if (this.status === STATUE_FULFILLED &amp;&amp; onFulfilled) &#123; try &#123; const value = onFulfilled(this.value) resolve(value) &#125; catch (err) &#123; reject(err) &#125; &#125; if (this.status === STATUS_REJECTED &amp;&amp; onRejected) &#123; try &#123; const reason = onRejected(this.reason) resolve(reason) &#125; catch (err) &#123; reject(err) &#125; &#125; if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(onFulfilled) this.onRejectedCallbacks.push(onRejected) &#125; &#125;)&#125; 上面都是在状态已经确定之后的情况，我们知道在状态为pending的时候，我们是把回调保存到数组，然后在上面的resolve、reject中遍历数组执行的 this.onFulfilledCallbacks.forEach(fn =&gt; &#123; let value = fn(this.value) // 在这里执行的&#125;) 那这个执行结果怎么拿到呢然后传给下面的resolve、reject呢？ 解决方案：改进我们添加到数组的方式 if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled() &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; onRejected() &#125;) &#125; 我们不直接把回调添加到数组，而是使用一个函数包裹起来，那么到时上面遍历执行的就是这个包裹的函数，然后我们在这里内部执行onFulfilled，就可以在这里拿到onFulfilled的执行结果 if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; const value = onFulfilled(this.value) resolve(value) &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; const reason = onRejected(this.reason) resolve(reason) &#125;) &#125; 同理，try…catch改进一下 if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; try &#123; const value = onFulfilled(this.value) resolve(value) &#125; catch (err) &#123; reject(err) &#125; &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; try &#123; const reason = onRejected(this.reason) resolve(reason) &#125; catch (err) &#123; reject(err) &#125; &#125;) &#125; 测试的时候发现，有一种情况我们没有处理 const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); // resolve(&quot;111&quot;) // reject(&quot;222&quot;) throw new Error(&quot;error message&quot;)&#125;) 改进，在 executor 那里加try…catch，如果抛出了异常直接执行reject try &#123; executor(resolve, reject)&#125; catch (err) &#123; reject(err)&#125; 测试： const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); throw new Error(&quot;error message&quot;)&#125;)promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res); return &quot;aaa&quot;&#125;, err =&gt; &#123; console.log(&quot;err: &quot;, err); // 执行这里 return &quot;bbb&quot;&#125;).then(res =&gt; &#123; console.log(&quot;res2: &quot;, res); // 然后来到这里&#125;, err =&gt; &#123; console.log(&quot;err2: &quot;, err);&#125;) 测试没问题！！ 工具函数 到这里then方法基本就实现完了，但是我们发现很多 try…catch的重复代码 我们可以做一个抽取，定义一个工具函数 function execFunctionWithCatchError(exeFn, value, resolve, reject) &#123; try &#123; const result = exeFn(value) resolve(result) &#125; catch (err) &#123; reject(err) &#125;&#125; 然后优化then方法： then(onFulfilled, onRejected) &#123; return new MyPromise((resolve, reject) =&gt; &#123; if (this.status === STATUE_FULFILLED &amp;&amp; onFulfilled) &#123; // try &#123; // const value = onFulfilled(this.value) // resolve(value) // &#125; catch (err) &#123; // reject(err) // &#125; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125; if (this.status === STATUS_REJECTED &amp;&amp; onRejected) &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125; if (this.status === STATUE_PENDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125;) &#125; &#125;)&#125; catch 方法的实现 catch接收一个参数，也就是失败的回调，因为catch实际上就相当于语法糖，而且也是返回一个新的promise，所以我们可以直接调用then catch(onRejected) &#123; return this.then(undefined, onRejected)&#125; 测试： const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); // resolve(111) reject(222)&#125;)promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res); return &quot;aaa&quot;&#125;).catch(err =&gt; &#123; console.log(&quot;catch&quot;, err);&#125;) 额，报错了 别急，分析原因。 我们可以观察一下，本来我们的失败回调应该是在第一个then中传入的，是作为第一个promise的失败的回调的 promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res); return &quot;aaa&quot;&#125;, err =&gt; &#123; console.log(&quot;catch&quot;, err);&#125;).catch() 但是现在我们写到catch里面，意味着这个catch传入的回调是被加入到一个新的promise中，作为新的promise的失败的回调了，所以执行不到这个回调了 promise1 -&gt; undefined promise2 -&gt; err ={} 那么我们怎么样让promise1执行到err ={} 呢？？ 实现思路：假如说promise1的失败回调没有值，我们直接抛出去，这样就会来到promise2中失败的回调了 promise1 -&gt; err =&gt; {throw err} // 抛出去 promise2 -&gt; err ={} // 就会执行到这里 还有一个地方是，既然onFulfilled或onRejected可能会传进来undefined，那么我们最好加上一个判断 then(onFulfilled, onRejected) &#123; const defaultOnRejected = err =&gt; &#123; throw err &#125; // 添加部分 onRejected = onRejected || defaultOnRejected return new MyPromise((resolve, reject) =&gt; &#123; if (this.status === STATUE_FULFILLED &amp;&amp; onFulfilled) &#123; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125; if (this.status === STATUS_REJECTED &amp;&amp; onRejected) &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125; if (this.status === STATUE_PENDING) &#123; if (onFulfilled) this.onFulfilledCallbacks.push(() =&gt; &#123; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125;) if (onRejected) this.onRejectedCallbacks.push(() =&gt; &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125;) &#125; &#125;)&#125; finally 方法的实现 接收一个参数，无论成功或失败，最后都会执行 也就是说，成功与失败的回调都是你传入的那个函数 // finallyfinally(onFinally) &#123; return this.then(() =&gt; &#123; onFinally() &#125;, () =&gt; &#123; onFinally() &#125;)&#125; 但是还会有一个问题 const promise = new MyPromise((resolve, reject) =&gt; &#123; console.log(&quot;pending~&quot;); resolve(111) // 调用resolve有问题 // reject(222) 调用reject没问题&#125;)promise.then(res =&gt; &#123; console.log(&quot;res: &quot;, res); // 圈1&#125;).catch(err =&gt; &#123; console.log(&quot;catch&quot;, err);// 圈2&#125;).finally(() =&gt; &#123; console.log(&#x27;finally&#x27;); // 圈3&#125;) 分析：捋一捋 如果上面是resolve的话，那么就会执行圈1，然后来到promise2的成功回调 promise1：成功回调是 圈1，失败回调是我们默认的reject promise2：没有成功回调，失败回调是圈2， ​ 没有成功回调，这时候就会出错了，后面也不会继续执行了，因此要给默认的成功回调 value =&gt; { return value } 然后才会执行finally的第一个回调 then(onFulfilled, onRejected) &#123; const defaultOnRejected = err =&gt; &#123; throw err &#125; onRejected = onRejected || defaultOnRejected // 添加部分 const defaultOnFulfilled = value =&gt; &#123; return value &#125; onFulfilled = onFulfilled || defaultOnFulfilled // 来到这里就可以保证 onRejected，onFulfilled 是有值的了，所以下面的判断也可以不要了 return new MyPromise((resolve, reject) =&gt; &#123; if (this.status === STATUE_FULFILLED) &#123; // 改了这里 execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125; if (this.status === STATUS_REJECTED) &#123; // 改了这里 execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125; if (this.status === STATUE_PENDING) &#123; if (onFulfilled) this.onFulfilledCallbacks.push(() =&gt; &#123; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125;) if (onRejected) this.onRejectedCallbacks.push(() =&gt; &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125;) &#125; &#125;)&#125; resolve reject 类方法的实现 resolve 类方法本质就是new了一个 promise，然后直接调用resolve reject同理 static resolve(value) &#123; return new MyPromise((resolve) =&gt; resolve(value))&#125;static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; reject(reason))&#125; 测试： MyPromise.resolve(123).then(res =&gt; &#123; console.log(res); // 123&#125;) all 方法的实现 all方法接收一个promise数组，同样返回一个promise 关键思路：什么时候要执行resolve, 什么时候要执行reject static all(promises) &#123; return new MyPromise((resolve, reject) =&gt; &#123; const values = [] // 定义结果数组 promises.forEach(promise =&gt; &#123; promise.then(res =&gt; &#123; values.push(res)// 当结果的个数等于传入promise个数的时候，表示已经执行完了，然后再回调resolve if (values.length === promises.length) &#123; resolve(values) &#125; &#125;, err =&gt; &#123; reject(err) // 失败直接执行回调reject &#125;) &#125;) &#125;)&#125; 测试： const p1 = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;111&quot;) &#125;, 1000);&#125;)const p2 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;222&quot;) // reject(&quot;222&quot;) &#125;, 2000);&#125;)const p3 = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;333&quot;) &#125;, 3000);&#125;)MyPromise.all([p1, p2, p3]).then(res =&gt; &#123; console.log(res); // [&#x27;111&#x27;, &#x27;222&#x27;, &#x27;333&#x27;]&#125;, err =&gt; &#123; console.log(err); // 如果p2调用reject，就会执行这里，输出 222&#125;) allSettled 方法的实现 与all类型，区别就是无论成功与否都会把结果保存到数组 测试： const p1 = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;111&quot;) &#125;, 1000);&#125;)const p2 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&quot;222&quot;) // reject(&quot;222&quot;) &#125;, 2000);&#125;)const p3 = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;333&quot;) &#125;, 3000);&#125;)MyPromise.allSettled([p1, p2, p3]).then(res =&gt; &#123; console.log(res);&#125;) race 方法的实现 只要状态改变就执行回调 static race(promises) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; // promise.then(res =&gt; &#123; // resolve(res) // &#125;, err =&gt; &#123; // reject(err) // &#125;) // 也可以这么写 promise.then(resolve, reject) &#125;) &#125;)&#125; any 方法的实现 等到第一个fulfilled状态，才执行resolve回调 如果全都是rejected状态，那么抛出异常 static any(promises) &#123; const reasons = [] return new MyPromise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reasons.push(err) // 当全部promise执行完之后 if (reasons.length === promises.length) &#123; reject(new AggregateError(reasons)) &#125; &#125;) &#125;) &#125;)&#125; 测试全都是reject的情况 const p1 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&quot;111&quot;) &#125;, 1000);&#125;)const p2 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&quot;222&quot;) &#125;, 2000);&#125;)const p3 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&quot;333&quot;) &#125;, 3000);&#125;)MyPromise.any([p1, p2, p3]).then(res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err, err.errors);&#125;) 到此，手写promise就差不多大功告成啦！","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://hillyee.github.io/tags/promise/"}]},{"title":"promise详解","slug":"promise详解","date":"2022-04-17T15:22:28.000Z","updated":"2022-04-17T15:24:30.080Z","comments":true,"path":"2022/04/17/promise详解/","link":"","permalink":"https://hillyee.github.io/2022/04/17/promise%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Promise详解 ES6 新增 Promise 介绍 Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息； 从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 1.为什么需要有Promise？ promise主要解决的问题： 回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象 promise可以支持多个并发的请求，获取并发请求中的数据 这个promise可以解决异步的问题，本身不能说promise是异步的 补充一下，什么是回调函数？ 就是我给你传一个函数，你反过来调用我 一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。 // 当参数a大于10且参数fn2是一个方法时 执行fn2function fn1(a, fn2) &#123; if (a &gt; 10 &amp;&amp; typeof fn2 == &#x27;function&#x27;) &#123; fn2() // 回调函数 &#125;&#125;fn1(11, function() &#123; console.log(&#x27;this is a callback&#x27;)&#125;) 2.Promise是什么？怎么使用？ Promise 是一个类，字面意思：承诺、期约 通过 new 可以创建一个 Promise 对象，并且需要传入回调函数（executor） 这个回调函数会被立即执行，并且会传入另外两个回调函数 resolve、reject 当我们调用resolve回调函数时，会执行Promise对象的then方法传入的第一个回调函数，当调用reject的时候，会执行第二个回调 const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success message&quot;) // reject(&quot;failure&quot;)&#125;)promise.then(res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;) Promise的三种状态 Promise使用过程，我们可以将它划分成三个状态： pending：待定，初始状态，既没有被兑现，也没有被拒绝；当执行executor中的代码时，处于该状态； fulfilled：已兑现， 意味着操作成功完成；执行了resolve时，处于该状态； （也有的地方叫resolved状态） rejected：已拒绝，意味着操作失败； 执行了reject时，处于该状态； new Promise((resolve, reject) =&gt; &#123; // pending待定 resolve() // fulfilled(已完成) reject() // rejected(已拒绝)&#125;).then(res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;) 注意：Promise的状态一旦确定，就不可更改，只有两种状态改变： pending -&gt; fulfilled pending -&gt; rejected 另外我们如果抛出异常，状态也是rejected，会回调then的第二个参数 new Promise((resolve, reject) =&gt; &#123; throw new Error(&quot;异常&quot;)&#125;).then(res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err); // Error: 异常&#125;) resolve不同值的区别 resolve(参数)：resolve的参数，三种情况 参数是普通值(数值/字符串/普通对象/undefined)，状态变化 pending -&gt; fulfilled 参数又是一个Promise对象，那么这个新Promise会决定原Promise的状态 const newPromise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;hahhaha&quot;) // reject()&#125;)new Promise((resolve, reject) =&gt; &#123; resolve(newPromise) // 状态由newPromise决定&#125;).then(res =&gt; &#123; console.log(res); // hahhaha&#125;, err =&gt; &#123; console.log(err);&#125;) 参数是一个对象，并且这个对象有实现then方法，那么会执行该then方法，并且根据 then方法的结果来决定Promise的状态 new Promise((resolve, reject) =&gt; &#123; const obj = &#123; then: function(resolve, reject) &#123; resolve(&quot;resolve message&quot;) // reject() &#125; &#125; resolve(obj)&#125;).then(res =&gt; &#123; console.log(res); &#125;, err =&gt; &#123; console.log(err);&#125;) Promise对象方法 then，catch，finally then方法 1. 两个参数 then方法是Promise对象上的方法，实际上是放在Promise的原型上的：Promise.prototype.then then方法接收两个参数： fulfilled的回调函数：当状态变成fulfilled时会回调的函数 reject的回调函数：当状态变成reject时会回调的函数 2. 多次调用 同一个Promise是可以被多次调用then方法的，当resolve方法被回调时，所有的then方法传入的回调函数都会被调用 const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success&quot;)&#125;)// 注意这不是链式调用promise.then(res1 =&gt; &#123; console.log(res1); // success&#125;)promise.then(res2 =&gt; &#123; console.log(res2); // success&#125;)promise.then(res3 =&gt; &#123; console.log(res3); // success&#125;) 3. then的返回值 then方法本身是有返回值的，它的返回值是Promise 如果我们then的第一个回调返回的是一个普通值(数值/字符串/普通对象/undefined), 那么这个普通的值会被作为一个新的Promise的resolve值 const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success&quot;)&#125;)let newPromise = promise.then(res =&gt; &#123; return &quot;aaa&quot; &#125;)console.log(newPromise); 所以我们可以进行链式调用 promise.then(res =&gt; &#123; return &quot;aaa&quot; &#125;).then(res =&gt; &#123; console.log(res); // &quot;aaa&quot; return &quot;bbb&quot;&#125;).then(res =&gt; &#123; console.log(res); // &quot;bbb&quot;&#125;) 如果返回的是一个Promise 那么这个Promise会决定下一个then返回的promise的状态 promise.then(res =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1111) &#125;, 3000) // reject(&#x27;err&#x27;) &#125;)&#125;).then(res =&gt; &#123; console.log(res); // 3秒后打印 1111&#125;, err =&gt; &#123; console.log(err);&#125;) 如果返回的是一个对象, 并且该对象实现了then方法 promise.then(res =&gt; &#123; return &#123; then: function(resolve, reject) &#123; resolve(2222) &#125; &#125;&#125;).then(res =&gt; &#123; console.log(res) // 222&#125;) 其实一样的，既然then返回一个promise，那就跟前面一样的处理，也就是可以继续链式调用then去处理，自己多尝试各种情况看看就都可以理解了 catch方法 catch方法也是Promise对象上的一个方法：它也是放在Promise的原型上的 Promise.prototype.catch() catch方法传入错误（拒绝）捕获的回调函数 catch也可以多次调用 我们可以把catch方法理解为 then 方法的语法糖 const promise = new Promise((resolve, reject) =&gt; &#123; reject(&quot;reject message&quot;)&#125;)promise.catch(err =&gt; &#123; console.log(err);&#125;)// 等价于promise.then(undefined, err =&gt; &#123; console.log(err);&#125;) 注意下面两种情况，catch的处理 const promise = new Promise((resolve, reject) =&gt; &#123; reject(&quot;err message&quot;) // 如果这里调用reject,也就是这个promise的状态是rejected&#125;)promise.then(res =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; reject(&quot;reject2 message&quot;) &#125;)&#125;).catch(err =&gt; &#123; console.log(err); // err message&#125;) const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;aaa&quot;) // 如果这里调用resolve,fulfilled状态&#125;)promise.then(res =&gt; &#123; // 先调用 then 的第一个回调 return new Promise((resolve, reject) =&gt; &#123; reject(&quot;reject2 message&quot;) // then返回的promise的状态是rejected &#125;)&#125;).catch(err =&gt; &#123; console.log(err); // reject2 message catch可以捕获到&#125;) 所以说catch会处理首次出现拒绝状态的Promise catch方法也是会返回一个Promise对象的，所以catch方法后面我们可以继续调用then方法或者catch方法 const promise = new Promise((resolve, reject) =&gt; &#123; reject(&quot;111&quot;)&#125;)promise.then(res=&gt;&#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err); // &quot;111&quot; return &quot;222&quot; // 这个catch返回的promise的状态为 fulfilled&#125;).then(res=&gt;&#123; console.log(res); // 222&#125;).catch(err =&gt; &#123; console.log(err);&#125;) finally方法 finally是在ES9（ES2018）中新增的一个特性：无论Promise对象变成fulfilled还是reject状态，最终都会被执行，所以finally也不需要接收参数 promise.then(res=&gt;&#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err); &#125;).finally(() =&gt; &#123; console.log(&quot;finally&quot;); // &quot;finally&quot;&#125;) finally 也会返回一个promise，但是一般我们不会继续再后面做处理了 Promise类方法 也就是直接通过Promise调用的方法，不需要创建实例 Promise.resolve 直接把某个内容转成Promise来使用 Promise.resolve的用法相当于new Promise，并且执行resolve操作 Promise.resolve(&quot;hello&quot;)// 等价于new Promise((resolve) =&gt; &#123; resolve(&quot;hello&quot;)&#125;) resolve的参数跟前面一样的三种，普通的值，Promise，有then方法的obj Promise.reject 会将Promise对象的状态设置为reject状态 Promise.reject(&quot;hello&quot;)// 等价于new Promise((resolve, reject) =&gt; &#123; reject(&quot;hello&quot;)&#125;) 注意：Promise.reject无论传入的参数是什么形态，都是会直接作为reject状态的参数 const promise = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&quot;123&quot;)&#125;))promise.then(res =&gt; &#123; console.log(&quot;res:&quot;, res)&#125;).catch(err =&gt; &#123; console.log(&quot;err:&quot;, err) // err: Promise &#123;&lt;fulfilled&gt;: &#x27;123&#x27;&#125;&#125;) Promise.all 将多个Promise包裹在一起形成一个新的Promise，新的Promise状态由包裹的所有Promise共同决定： 当所有的Promise状态变成 fulfilled 状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组 const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(222) &#125;, 2000)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(333) &#125;, 3000)&#125;)Promise.all([p1, p2, p3]).then(res =&gt; &#123; console.log(res); // [ 111, 222, 333 ]&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数 ...const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(222) &#125;, 2000)&#125;)...Promise.all([p1, p2, p3]).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); // 222&#125;) Promise.allSettled ES11（ES2022）新增 该方法会在所有的Promise都有结果（无论是fulfilled还是reject）后才会有最终的状态，并且返回的Promise的状态一定是fulfilled const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(222) &#125;, 2000)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(333) &#125;, 3000)&#125;)Promise.allSettled([p1, p2, p3]).then(res =&gt; &#123; console.log(&quot;res:&quot;, res); // 执行的是这里&#125;).catch(err =&gt; &#123; console.log(&quot;err:&quot;, err);&#125;) 打印的结果是一个数组，存放每一个Promise的结果 status：状态，value：值 Promise.race race：竞赛，这个方法可以理解为Promise的竞赛 只要有一个Promise变成fulfilled状态, 那么就结束，并使用这个promise的结果 const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(222) &#125;, 500) // 先执行完&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(333) &#125;, 3000)&#125;)Promise.race([p1, p2, p3]).then(res =&gt; &#123; console.log(&quot;res:&quot;, res); &#125;).catch(err =&gt; &#123; console.log(&quot;err:&quot;, err); // err: 222&#125;) Promise.any ES12新增，和race方法类似 any方法会等到第一个fulfilled状态，才会决定新Promise的状态 如果所有的Promise都是reject的，那么会报一个AggregateError的错误 const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(111) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(222) &#125;, 2000) &#125;)Promise.any([p1, p2]).then(res =&gt; &#123; console.log(&quot;res:&quot;, res); &#125;).catch(err =&gt; &#123; console.log(&quot;err:&quot;, err); // err: 222&#125;)// 输出：// err: AggregateError: All promises were rejected// err.errors可以拿到全部错误信息","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://hillyee.github.io/tags/promise/"}]},{"title":"面试题—JS篇之代码输出结果是什么","slug":"面试题-—-JS篇之代码输出结果是什么","date":"2022-04-15T13:12:15.000Z","updated":"2022-04-15T17:11:21.938Z","comments":true,"path":"2022/04/15/面试题-—-JS篇之代码输出结果是什么/","link":"","permalink":"https://hillyee.github.io/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E2%80%94-JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"包含类型判断、作用域、this指向、原型、事件循环等知识点 请问下面的代码输出结果是什么？ 第1题 let a = 1function b(a) &#123; a = 2 console.log(a)&#125;b(a)console.log(a) 答案：2 1 第2题 function a (b = c, c = 1) &#123; console.log(b, c)&#125;a() 报错：Cannot access ‘c’ before initialization 第3题 let a = b = 10;(function()&#123; let a = b = 20 &#125;)()console.log(a)console.log(b) 答案：10、20 第4题 var a = &#123;n:1&#125;var b = aa.x = a = &#123;n:2&#125;console.log(a.x)console.log(b.x) 答案：undefined、{n: 2} 第5题 var arr = [0, 1, 2]arr[10] = 10console.log(arr.filter(function (x) &#123; return x === undefined&#125;)) 答案：[ ] 第6题 var name = &#x27;World&#x27;;(function () &#123; if (typeof name === &#x27;undefined&#x27;) &#123; var name = &quot;Jack&quot; console.info(&#x27;Goodbye &#x27; + name) &#125; else &#123; console.info(&#x27;Hello &#x27; + name) &#125;&#125;)() 答案：Goodbye Jack 第7题 console.log(1 + NaN)console.log(&quot;1&quot; + 3)console.log(1 + undefined)console.log(1 + null)console.log(1 + &#123;&#125;)console.log(1 + [])console.log([] + &#123;&#125;) 答案：NaN、13、NaN、1、1[object Object]、1、[object Object] 第8题 var a=&#123;&#125;, b=&#123;key:&#x27;b&#x27;&#125;, c=&#123;key:&#x27;c&#x27;&#125;a[b]=123a[c]=456console.log(a[b]) 答案：456 第9题 var out = 25var inner = &#123; out: 20, func: function () &#123; var out = 30 return this.out &#125;&#125;;console.log((inner.func, inner.func)())console.log(inner.func())console.log((inner.func)())console.log((inner.func = inner.func)()) 答案：25、20、20、25 第10题 let &#123;a,b,c&#125; = &#123; c:3, b:2, a:1 &#125;console.log(a, b, c) 答案：1、2、3 第11题 console.log(Object.assign([1, 2, 3], [4, 5])) [4, 5, 3] 第12题 var x=1switch(x++)&#123; case 0: ++x case 1: ++x case 2: ++x&#125;console.log(x) 答案：4 第13题 console.log(typeof undefined == typeof NULL)console.log(typeof function () &#123;&#125; == typeof class &#123;&#125;) 答案：true、true 第14题 var count = 0console.log(typeof count === &quot;number&quot;)console.log(!!typeof count === &quot;number&quot;) 答案：true、false 第15题 &quot;use strict&quot;a = 1var a = 2console.log(window.a)console.log(a) 答案：2、2 第16题 var i = 1function b() &#123; console.log(i)&#125;function a() &#123; var i = 2 b()&#125;a() 答案：1 第17题 var obj = &#123; name: &#x27;abc&#x27;, fn: () =&gt; &#123; console.log(this.name) &#125;&#125;;obj.name = &#x27;bcd&#x27;obj.fn() 答案：undefined 第18题 const obj = &#123; a: &#123; a: 1 &#125;&#125;;const obj1 = &#123; a: &#123; b: 1 &#125;&#125;;console.log(Object.assign(obj, obj1)) 答案：{a: {b: 1}} 第19题 console.log(a)var a = 1var getNum = function() &#123; a = 2&#125;function getNum() &#123; a = 3&#125;console.log(a)getNum()console.log(a) 答案：undefined、1、2 第20题 var scope = &#x27;global scope&#x27;function a()&#123; function b()&#123; console.log(scope) &#125; return b var scope = &#x27;local scope&#x27;&#125;a()() 答案：undefined 第21题 function fn ()&#123; console.log(this) &#125;var arr = [fn]arr[0]() 答案：打印出arr数组本身 第22题 var a = 1function a()&#123;&#125;console.log(a)var bfunction b()&#123;&#125;console.log(b)function b()&#123;&#125;var bconsole.log(b) 答案：1、b函数本身、b函数本身 第23题 function Foo() &#123; getName = function () &#123; console.log(1) &#125; return this&#125;Foo.getName = function () &#123; console.log(2)&#125;Foo.prototype.getName = function () &#123; console.log(3)&#125;var getName = function () &#123; console.log(4)&#125;function getName() &#123; console.log(5)&#125;//请写出以下输出结果：Foo.getName()getName()Foo().getName()getName()new Foo.getName()new Foo().getName()new new Foo().getName() 答案：2、4、1、1、2、3、3 第24题 const person = &#123; address: &#123; country:&quot;china&quot;, city:&quot;hangzhou&quot; &#125;, say: function () &#123; console.log(`it&#x27;s $&#123;this.name&#125;, from $&#123;this.address.country&#125;`) &#125;, setCountry:function (country) &#123; this.address.country=country &#125;&#125;const p1 = Object.create(person)const p2 = Object.create(person)p1.name = &quot;Matthew&quot;p1.setCountry(&quot;American&quot;)p2.name = &quot;Bob&quot;p2.setCountry(&quot;England&quot;)p1.say()p2.say() 答案：it’s Matthew, from England it’s Bob, from England 第25题 setTimeout(function() &#123; console.log(1)&#125;, 0)new Promise(function(resolve) &#123; console.log(2) for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function() &#123; console.log(4)&#125;)console.log(5) 答案：2、3、5、4、1 第26题 注：process是Node.js提供的一个对象，它代表当前Node.js进程 console.log(&#x27;1&#x27;);setTimeout(function() &#123; console.log(&#x27;2&#x27;); process.nextTick(function() &#123; console.log(&#x27;3&#x27;); &#125;); new Promise(function(resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;5&#x27;); &#125;);&#125;); process.nextTick(function() &#123; console.log(&#x27;6&#x27;);&#125;);new Promise(function(resolve) &#123; console.log(&#x27;7&#x27;); resolve();&#125;).then(function() &#123; console.log(&#x27;8&#x27;);&#125;);setTimeout(function() &#123; console.log(&#x27;9&#x27;); process.nextTick(function() &#123; console.log(&#x27;10&#x27;); &#125;) new Promise(function(resolve) &#123; console.log(&#x27;11&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;12&#x27;) &#125;);&#125;) 答案：1、7、6、8、2、4、9、11、3、10、5、12 1-26 来源：https://mp.weixin.qq.com/s/fks9SuTSY0ivUfPn6G-TOw","categories":[{"name":"😣面试题-js篇","slug":"😣面试题-js篇","permalink":"https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"}]},{"title":"面试题—JS篇之代码输出结果是什么","slug":"面试题—JS篇之代码输出结果是什么","date":"2022-04-15T13:12:15.000Z","updated":"2022-04-15T17:08:20.905Z","comments":true,"path":"2022/04/15/面试题—JS篇之代码输出结果是什么/","link":"","permalink":"https://hillyee.github.io/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"包含类型判断、作用域、this指向、原型、事件循环等知识点 请问下面的代码输出结果是什么？ 第1题 let a = 1function b(a) &#123; a = 2 console.log(a)&#125;b(a)console.log(a) 答案：2 1 第2题 function a (b = c, c = 1) &#123; console.log(b, c)&#125;a() 报错：Cannot access ‘c’ before initialization 第3题 let a = b = 10;(function()&#123; let a = b = 20 &#125;)()console.log(a)console.log(b) 答案：10、20 第4题 var a = &#123;n:1&#125;var b = aa.x = a = &#123;n:2&#125;console.log(a.x)console.log(b.x) 答案：undefined、{n: 2} 第5题 var arr = [0, 1, 2]arr[10] = 10console.log(arr.filter(function (x) &#123; return x === undefined&#125;)) 答案：[ ] 第6题 var name = &#x27;World&#x27;;(function () &#123; if (typeof name === &#x27;undefined&#x27;) &#123; var name = &quot;Jack&quot; console.info(&#x27;Goodbye &#x27; + name) &#125; else &#123; console.info(&#x27;Hello &#x27; + name) &#125;&#125;)() 答案：Goodbye Jack 第7题 console.log(1 + NaN)console.log(&quot;1&quot; + 3)console.log(1 + undefined)console.log(1 + null)console.log(1 + &#123;&#125;)console.log(1 + [])console.log([] + &#123;&#125;) 答案：NaN、13、NaN、1、1[object Object]、1、[object Object] 第8题 var a=&#123;&#125;, b=&#123;key:&#x27;b&#x27;&#125;, c=&#123;key:&#x27;c&#x27;&#125;a[b]=123a[c]=456console.log(a[b]) 答案：456 第9题 var out = 25var inner = &#123; out: 20, func: function () &#123; var out = 30 return this.out &#125;&#125;;console.log((inner.func, inner.func)())console.log(inner.func())console.log((inner.func)())console.log((inner.func = inner.func)()) 答案：25、20、20、25 第10题 let &#123;a,b,c&#125; = &#123; c:3, b:2, a:1 &#125;console.log(a, b, c) 答案：1、2、3 第11题 console.log(Object.assign([1, 2, 3], [4, 5])) [4, 5, 3] 第12题 var x=1switch(x++)&#123; case 0: ++x case 1: ++x case 2: ++x&#125;console.log(x) 答案：4 第13题 console.log(typeof undefined == typeof NULL)console.log(typeof function () &#123;&#125; == typeof class &#123;&#125;) 答案：true、true 第14题 var count = 0console.log(typeof count === &quot;number&quot;)console.log(!!typeof count === &quot;number&quot;) 答案：true、false 第15题 &quot;use strict&quot;a = 1var a = 2console.log(window.a)console.log(a) 答案：2、2 第16题 var i = 1function b() &#123; console.log(i)&#125;function a() &#123; var i = 2 b()&#125;a() 答案：1 第17题 var obj = &#123; name: &#x27;abc&#x27;, fn: () =&gt; &#123; console.log(this.name) &#125;&#125;;obj.name = &#x27;bcd&#x27;obj.fn() 答案：undefined 第18题 const obj = &#123; a: &#123; a: 1 &#125;&#125;;const obj1 = &#123; a: &#123; b: 1 &#125;&#125;;console.log(Object.assign(obj, obj1)) 答案：{a: {b: 1}} 第19题 console.log(a)var a = 1var getNum = function() &#123; a = 2&#125;function getNum() &#123; a = 3&#125;console.log(a)getNum()console.log(a) 答案：undefined、1、2 第20题 var scope = &#x27;global scope&#x27;function a()&#123; function b()&#123; console.log(scope) &#125; return b var scope = &#x27;local scope&#x27;&#125;a()() 答案：undefined 第21题 function fn ()&#123; console.log(this) &#125;var arr = [fn]arr[0]() 答案：打印出arr数组本身 第22题 var a = 1function a()&#123;&#125;console.log(a)var bfunction b()&#123;&#125;console.log(b)function b()&#123;&#125;var bconsole.log(b) 答案：1、b函数本身、b函数本身 第23题 function Foo() &#123; getName = function () &#123; console.log(1) &#125; return this&#125;Foo.getName = function () &#123; console.log(2)&#125;Foo.prototype.getName = function () &#123; console.log(3)&#125;var getName = function () &#123; console.log(4)&#125;function getName() &#123; console.log(5)&#125;//请写出以下输出结果：Foo.getName()getName()Foo().getName()getName()new Foo.getName()new Foo().getName()new new Foo().getName() 答案：2、4、1、1、2、3、3 第24题 const person = &#123; address: &#123; country:&quot;china&quot;, city:&quot;hangzhou&quot; &#125;, say: function () &#123; console.log(`it&#x27;s $&#123;this.name&#125;, from $&#123;this.address.country&#125;`) &#125;, setCountry:function (country) &#123; this.address.country=country &#125;&#125;const p1 = Object.create(person)const p2 = Object.create(person)p1.name = &quot;Matthew&quot;p1.setCountry(&quot;American&quot;)p2.name = &quot;Bob&quot;p2.setCountry(&quot;England&quot;)p1.say()p2.say() 答案：it’s Matthew, from England it’s Bob, from England 第25题 setTimeout(function() &#123; console.log(1)&#125;, 0)new Promise(function(resolve) &#123; console.log(2) for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function() &#123; console.log(4)&#125;)console.log(5) 答案：2、3、5、4、1 第26题 注：process是Node.js提供的一个对象，它代表当前Node.js进程 console.log(&#x27;1&#x27;);setTimeout(function() &#123; console.log(&#x27;2&#x27;); process.nextTick(function() &#123; console.log(&#x27;3&#x27;); &#125;); new Promise(function(resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;5&#x27;); &#125;);&#125;); process.nextTick(function() &#123; console.log(&#x27;6&#x27;);&#125;);new Promise(function(resolve) &#123; console.log(&#x27;7&#x27;); resolve();&#125;).then(function() &#123; console.log(&#x27;8&#x27;);&#125;);setTimeout(function() &#123; console.log(&#x27;9&#x27;); process.nextTick(function() &#123; console.log(&#x27;10&#x27;); &#125;) new Promise(function(resolve) &#123; console.log(&#x27;11&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;12&#x27;) &#125;);&#125;) 答案：1、7、6、8、2、4、9、11、3、10、5、12 1-26 来源：https://mp.weixin.qq.com/s/fks9SuTSY0ivUfPn6G-TOw","categories":[{"name":"😣面试题-js篇","slug":"😣面试题-js篇","permalink":"https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"}]},{"title":"学习TypeScript","slug":"学习TypeScript","date":"2022-04-15T11:22:29.000Z","updated":"2022-04-15T11:24:46.813Z","comments":true,"path":"2022/04/15/学习TypeScript/","link":"","permalink":"https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/","excerpt":"","text":"TypeScript初识 JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题 TS简介 Typescript是拥有类型的JavaScript超集 JavaScript所拥有的特性，TS全部都支持，并且在语言层面上添加了类型约束，还加上一些语法的扩展 TS的编译环境 TS最终还是会被编译成JS代码运行，所以我们需要搭建对应的环境 在电脑上安装Typescript，这样就可以通过TypeScript的Compiler将其编译成JavaScript 全局安装：npm install typescript -g 查看版本：tsc --version TS的运行环境 运行的两个步骤： tsc xxx.ts 把ts文件编译成JS代码 在浏览器或Node环境下运行JS代码 如果每次都要做这两个步骤，那就太麻烦了 有什么简化的方式呢？ 第一种：通过webpack，配置本地的TS编译环境和开启一个本地服务，可以直接运行在浏览器上 第二种：通过ts-node库，为TS的运行提供执行环境 安装 ts-node：npm install ts-node -g 另外 ts-node需要安装依赖 tslib 和 @types/node 两个包 npm install tslib @types/node -g 然后可以直接通过 ts-node 来运行 TS 的代码： ts-node xxx.ts 变量的声明 定义的时候给标识符加类型： var/let/const 标识符: 数据类型 = 赋值 但是 var 不推荐使用 另外注意 string 和 String 的区别 string是TypeScript中定义的字符串类型，String是ECMAScript中定义的一个包装类 let message: string = &quot;abc&quot;console.log(message);const name: string = &#x27;xxx&#x27; 类型推断（推导），就是说我们第一次给变量赋值的时候，会根据这个赋值的内容，自动推断变量的类型 let num = 2 // 自动类型推断为number类型num = &quot;123&quot; // 报错 推荐：如果可以自动推导出变量的类型的时候，不加类型 不确定类型的时候，要自己加上类型 数据类型 我们常说TS是JS的一个超集 JS类型 TS和JS都有的数据类型 number类型 TS 和 JS一样 let num: number = 123num = 222// num = &quot;123&quot; // 报错// TS 也支持进制let num1: number = 100let num2: number = 0b100let num3: number = 0o100let num4: number = 0x100console.log(num1, num2, num3, num4); // 100 4 64 256 boolean类型 true、false let flag: boolean = truelet flag: boolean = trueflag = falseflag = 20 &gt; 30 string类型 let message: string = &quot;hello&quot;message = &#x27;hello ts&#x27;// 同样也支持ES6的模板字符串const info = `hi $&#123;message&#125;`console.log(info); // hi hello ts Array类型 固定数组里面存放的数据类型 const name1: string[] = [] // 推荐// name1.push(1) // 报错const name2: Array&lt;string&gt; = [] // 不推荐(react jsx中是有冲突) Object类型 const info:object = &#123; // 在这里设置了object类型 name: &quot;xxx&quot;, age: 18&#125;info[&quot;name&quot;] = &quot;kkk&quot;console.log(info[&quot;age&quot;]); 设置了object类型不能获取数据也不能设置数据 如果去掉了:object就可以获取，并且里面的属性类型也有推断 const info = &#123; name: &quot;xxx&quot;, age: 18&#125;info[&quot;name&quot;] = 123 // 报错console.log(info[&quot;age&quot;]) // 18 Symbol类型 跟 JS 一样，主要用于设置唯一属性名 let title1: symbol = Symbol(&quot;title&quot;)// title1 = 2 // number赋值给symbol类型,报错let title2 = Symbol(&quot;title&quot;) // 推断const info = &#123; [title1]: &quot;xxx&quot;, [title2]: &quot;kkk&quot;&#125; Null 和 Undefined类型 null： let n1: null = nulln1 = 123 // number -&gt; null 报错let n2 = null // 推断是 any类型n2 = 123 // 不报错 同理：undefined： let n3: undefined = undefinedn3 = 123 // 报错let n4 = undefinedn4 = 123 TypeScript类型 any类型 any表示任意类型 在不确定变量类型的时候，可以使用any类型，但是一旦使用了，意味着我们可以对any类型的变量进行任何的操作，包括赋值任何类型的值；获取不存在的属性、方法 非常不安全，不推荐使用 let message: any = &quot;hello&quot;message = 123message = truemessage = &#123;&#125;message.split(&quot; &quot;) unknown类型 用于描述类型不确定的变量 unknown类型只能赋值给any和unknown类型 function foo() &#123; return &quot;abc&quot;&#125;function bar() &#123; return 123&#125;let flag = truelet result: unknown // 如果使用any就不会报错了if (flag) &#123; result = foo()&#125; else &#123; result = bar()&#125;// 避免拿到结果之后乱用let message: string = result // 不能将类型“unknown”分配给类型“string”console.log(result); void类型 void通常来指定一个函数没有返回值的，那么它的返回值就是void类型 另外，这个函数可以返回 null，undefined 一般都不写的，因为没有返回值默认推断就是void function sum(num1: number, num2: number): void &#123; console.log(num1 + num2); // 这里写不写void都一样的&#125;sum(20, 30) never类型 表示永远不会发生值的类型 never表示函数用于执行不到返回值那一步（抛出异常或死循环）的返回值类型 而void是函数没有返回值，可以返回null，undefined function foo() &#123; // 死循环 while(true) &#123; &#125;&#125;function bar() &#123; throw new Error() // 抛出异常&#125; never 有什么应用场景？ // function handleMessage(message: string | number ) &#123;function handleMessage(message: string | number | boolean ) &#123; switch (typeof message) &#123; case &#x27;string&#x27;: console.log(&#x27;string方式处理message&#x27;); break case &#x27;number&#x27;: console.log(&#x27;number方式处理message&#x27;); break case &#x27;boolean&#x27;: console.log(&#x27;boolean方式处理message&#x27;); break default: // 默认不会执行到返回值那一步,所以如果你没有对应的处理逻辑,就会报错 const check: never = message &#125;&#125;handleMessage(&quot;abc&quot;)handleMessage(123)// 这时候有人想要传入 boolean类型handleMessage(true)// 但发现报错了, 然后就给函数参数加上boolean类型// 然后就不报错了,但是函数里面并没有处理boolean参数的逻辑,他并不知道// 如果, 加上default那一段,就会报错// 这时候这个人就知道里面需要有boolean的处理逻辑,然后就去加上 tuple类型 tuple 是元组类型，元组中每个元素都有自己特定的类型，根据索引值获取到的值可以确定对应的类型 const info: [string, number, number] = [&quot;xxx&quot;, 18, 1.88]const name = info[0]console.log(name.length); // 3 而数组通常建议存放相同类型的值 tuple应用场景 tuple通常可以作为返回的值，在使用的时候会非常的方便 function useState&lt;T&gt;(state: T) &#123; let currentState = state const changeState = (newState: T) =&gt; &#123; currentState = newState &#125; const info: [string, number] = [&#x27;xxx&#x27;, 18] const tuple: [T, (newState: T) =&gt; void] = [currentState, changeState] return tuple&#125;const [counter, setCounter] = useState(10)setCounter(1000)const [title, setTitle] = useState(&quot;abc&quot;)const [flag, setFlag] = useState(true) 函数的参数和返回值类型 // 一般可以不写返回值的类型，会自动推断// function sum(num1: number, num2: number): number &#123;function sum(num1: number, num2: number) &#123; return num1 + num2&#125;sum(123, 321) 匿名函数的参数 const names = [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]// 我们并没有指定item的类型// 但是TypeScript会根据forEach函数的类型以及数组的类型推断出item的类型, 这个时候可以不添加的类型注解names.forEach(function(item) &#123; console.log(item.split(&quot;&quot;));&#125;); 对象类型 如果我们希望限定一个函数接收的参数是一个对象 function printPoint(point: &#123;x: number, y: number&#125;) &#123; console.log(point.x); console.log(point.y);&#125;printPoint(&#123;x: 123, y: 321&#125;) 联合类型 function printId(id: number | string) &#123; // id 可以是number 也可以是 string类型&#125; 使用联合类型 function printID(id: number | string) &#123; // 使用联合类型的值时，需要特别的小心 // narrow：缩小 if (typeof id === &#x27;string&#x27;) &#123; // 确定id是string类型 console.log(id.toUpperCase()); &#125; else &#123; &#125;&#125; 可选类型 对象类型也可以指定哪些属性是可选的，可以在属性后面加一个? function printPoint(point: &#123;x: number, y:number, z?:number&#125;) &#123;&#125; 那么这个属性可传可不传 另外，可选类型可以看做是类型和undefined的联合类型 function foo(message?: string) &#123; console.log(message);&#125;foo() // 什么都不传实际上就是代表undefinedfoo(undefined) 类型别名 我们可以给对象类型起一个别名，方面我们后续使用 用到了关键字 type type IDType = string | numbertype PointType = &#123; x: number y: number z?: number&#125;function printID(id: IDType) &#123;&#125;function printPoint(point: PointType) &#123;&#125; 类型断言 as 将类型转换为更具体的类型 本来不加类型断言的话，TS只会把el推断为HTMLElement类型 const el = document.getElementById(&quot;xxx&quot;) as HTMLImageElementel.src = &quot;url地址&quot; 案例2：Person 是 Student 的父类 function sayHello(p: Person) &#123; // 不断言的话会报错：类型“Person”上不存在属性“studying” (p as Student).studying()&#125; 非空类型断言! ! 用于确定某个标识符是有值的，跳过 ts 在编译阶段时对它的检测 // message 可以是string/undefinedfunction foo(message?: string) &#123; // 当然可以直接if判断 // if(message) &#123; // &#125; // 但是！更简洁 console.log(message!.length);&#125; 可选链 实际上是 ES11 增加的特性 ?. 操作符，作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行 type Person = &#123; name: string, friend?: &#123; f1?: &#123; name: string &#125; &#125;&#125;const info:Person = &#123; name: &#x27;xxx&#x27;,&#125;// console.log(info.friend.f1); // friend不存在,取不到f1,报错console.log(info.friend?.f1); // undefined, 不报错// info.friend存在吗？存在再继续取f1 ?? 和 !! 运算符 ?? 是 ES11新增的特性 **空值合并操作符 ?? **，是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数 const message = nullconst res = message ?? &quot;123&quot; console.log(res); // &quot;123&quot; !!操作符，将一个其他类型转换成boolean类型，类型Boolean(变量) const message = &quot;&quot;let flag1 = Boolean(message)let flag2 = !!messageconsole.log(flag1); // falseconsole.log(flag2); // false 字面量类型 字面量也可以当做类型 let msg:&quot;hello&quot; = &quot;hello&quot; // 但是msg的值只能是&quot;hello&quot;msg = &quot;asd&quot; // 报错 那有什么意义呢？可以将多个类型联合在一起 type Alignment = &#x27;left&#x27; | &#x27;right&#x27; | &#x27;center&#x27;function changeAlign(align: Alignment) &#123; console.log(&#x27;修改方向:&#x27;, align);&#125;changeAlign(&quot;center&quot;) // 只能传入定义的三个字面量类型 字面量推理 下面的代码，默认情况下info 进行类型推断的时候，method是string类型 加上as const 后，methods就是&quot;GET&quot;字面量类型 const info = &#123; url: &quot;https://hillyee.github.io&quot;, method: &quot;GET&quot;&#125; as const // 加上as const 后，methods就是&quot;GET&quot;字面量类型function request(url: string, method: &quot;GET&quot; | &quot;POST&quot;) &#123; console.log(url, method);&#125;request(info.url, info.method) // https://hillyee.github.io GET// 默认：类型“string”的参数不能赋给类型“&quot;GET&quot; | &quot;POST&quot;”的参数。 类型缩小 Type Narrowing 类型缩小 可以通过类似于 typeof padding === “number” 的判断语句，来改变TypeScript的执行路径 在给定的执行路径中，缩小比声明时更小的类型，这个过程称之为 缩小 而我们编写的typeof padding === &quot;number 可以称之为类型保护 常见的类型保护： typeof type IDType = number | stringfunction printID(id: IDType) &#123; // 这外面使用id是 IDtype 类型 if (typeof id === &#x27;string&#x27;) &#123; // 这里面确认id是string类型 console.log(id.toUpperCase()); &#125; else &#123; // 确认是number类型 &#125;&#125; 平等缩小（=== == !== !=/switch） type Direction = &quot;left&quot; | &quot;right&quot; | &quot;top&quot; | &quot;bottom&quot;function printDirection(direction: Direction) &#123; // 1.if判断 // if (direction === &#x27;left&#x27;) &#123; // console.log(direction) // &#125; else if () // 2.switch判断 switch (direction) &#123; case &#x27;left&#x27;: console.log(direction) break; // case ... &#125;&#125; instanceof class Student &#123;&#125;class Teacher &#123;&#125;function work(p: Student | Teacher) &#123; if (p instanceof Student) &#123; &#125; else &#123; &#125;&#125; in 属性是否存在某对象上 type Fish = &#123; swimming: () =&gt; void&#125;type Dog = &#123; running: () =&gt; void&#125;function walk(animal: Fish | Dog) &#123; if (&#x27;swimming&#x27; in animal) &#123; &#125; else &#123; animal.running() &#125;&#125;const fish:Fish = &#123; swimming() &#123;&#125;&#125;walk(fish) TS函数类型 定义常量时，编写函数的类型 (num1: number, num2: number) =&gt; number 就是一个函数类型，并接收两个参数num1，num2，并且都是number类型 type AddFnType = (num1: number, num2: number) =&gt; numberconst add: AddFnType = (a1: number, a2: number) =&gt; &#123; return a1 + a2&#125; 函数作为参数时，在参数中如何编写类型？ function foo() &#123;&#125;type FooFnType = () =&gt; voidfunction bar(fn: FooFnType) &#123; fn()&#125;bar(foo) 参数的可选类型 function foo(x: number, y?: number) &#123;&#125; // y可选 默认参数 function foo(x: number, y: number = 6) &#123;&#125; 剩余参数 将一个不定数量的参数放到一个数组中 function sum(...nums: number[]) &#123; let total = 0 for (const num of nums) &#123; total += num &#125; return total&#125; this类型 当this不确定的时候，通常TS会要求我们明确的指定this的类型 如果不指定的话，非常不安全，因为有可能直接调用函数或者通过别的对象来调用函数 type thisType = &#123; name: string &#125;function eating(this: thisType, message: string) &#123; console.log(this); console.log(this.name + &quot; eating&quot;, message);&#125;const info = &#123; name: &quot;xxx&quot;, eating: eating&#125;// 隐式绑定info.eating(&quot;asd&quot;) // this是info// 显式绑定eating.call(&#123;name: &quot;kkk&quot;&#125;, &quot;hehehe&quot;)// &#123; name: &#x27;kkk&#x27; &#125;// kkk eating hehehe 函数的重载 函数的重载在实际开发也不是必须要用的，如果本来可以用联合类型简单实现的话，优先选择联合类型 例如有一个需求，希望对字符串和数字类型进行相加 function add(a1: number | string, a2: number | string) &#123; if (typeof a1 === &quot;number&quot; &amp;&amp; typeof a2 === &quot;number&quot;) &#123; return a1 + a2 &#125; else if (typeof a1 === &quot;string&quot; &amp;&amp; typeof a2 === &quot;string&quot;) &#123; return a1 + a2 &#125; // return a1 + a2 // TS 会把 string | number 当做是一个类型 // 运算符“+”不能应用于类型“string | number”和“string | number”&#125;add(10, 20) 以上通过联合类型的方式实现有两个缺点： 进行很多的逻辑判断（类型缩小） 返回值的类型依然不确定 函数的重载是什么？ 函数的名称相同，但是参数不同的几个函数就是函数的重载，并且是没有函数执行体的 // 构成函数重载function add(num1: number, num2: number):numberfunction add(num1: string, num2: string):string// 函数的实现// 如果有函数重载，执行体是不能直接被调用的function add(num1: any, num2: any): any &#123; // 如果是 string 就返回长度相加 if (typeof num1 === &#x27;string&#x27; &amp;&amp; typeof num2 === &quot;string&quot;) &#123; return num1.length + num2.length &#125; return num1 + num2&#125;const res1 = add(10, 20) // 先找到函数的声明 再找执行体const res2 = add(&quot;aaa&quot;, &quot;bbb&quot;)console.log(res1); // 30console.log(res2); // 6// add(&#123;name: &quot;xxx&quot;&#125;, &#123;age: 18&#125;) 以上案例确实使用函数重载实现更方便，所以可以选择函数重载 TS类的使用 这部分，实际开发中相对用的少一点，所以笔记暂时记的比较粗糙 类的定义 class Person &#123; name: string age: number constructor(name: string, age: number) &#123; this.name = name this.age = age &#125; eating() &#123;&#125;&#125; 类的继承 extends super 关键字 class Person &#123; name: string age: number constructor(name: string, age: number) &#123; this.name = name this.age = age &#125; eating() &#123;&#125;&#125;class Student extends Person &#123; sno: number constructor(name: string, age: number, sno: number) &#123; super(name, age) this.sno = sno &#125;&#125; 类的多态 不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现 类的成员修饰符 public 共有的，默认编写的属性就是public private 仅在同一类中可见 class Person &#123; private _name: string = &quot;&quot; constructor(name: string) &#123; this._name = name &#125; // 访问器setter/getter set name(newName) &#123; this._name = newName &#125; // getter get name() &#123; return this._name &#125;&#125; 其中 setter/getter 是访问器属性，这样外界就可以存储 const p = new Person(&quot;xxx&quot;)p.name // 会调用get访问器p.name = &quot;kkk&quot; // set protected 仅在类自身及子类中可见、受保护的属性和方法 只读属性readonly 只读属性是可以在构造器中赋值, 赋值之后就不可以修改 属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改 class Person &#123; readonly name: string age?: number constructor(name: string) &#123; this.name = name &#125;&#125; const p = new Person(&quot;xxx&quot;)p.name = &#x27;kkk&#x27; // 报错 静态成员 通过关键字static来定义，直接通过类调用 class Student &#123; static time: string = &quot;20:00&quot; static attendClass() &#123; console.log(&#x27;去上课&#x27;); &#125;&#125;console.log(Student.time);Student.attendClass() 抽象类abstract 抽象类： 以abstract 声明的类是抽象类 抽象类和其他类区别不大，但是不能被实例化（不能通过new调用） 抽象类就是专门用来被继承的类 抽象方法：没有具体实现（没有方法体），抽象方法必须存在于抽象类中 function makeArea(shape: Shape) &#123; return shape.getArea()&#125;abstract class Shape &#123; abstract getArea(): number&#125;class Rectangle extends Shape &#123; private width: number private height: number constructor(width: number, height: number) &#123; super() this.width = width this.height = height &#125; // 重写方法 getArea()&#123; return this.width * this.height &#125;&#125;const rectangle = new Rectangle(20, 30) makeArea(rectangle) 类的类型 类本身可以作为一个类型 class Person &#123; name: string = &#x27;123&#x27;&#125;const p = new Person()const p1: Person = &#123; // p1的类型是Person类，所以必须要传name name: &#x27;xxx&#x27;&#125; TS接口的使用 除了可以通过type开声明一个对象类型，还可以通过接口来声明 interface Point &#123; x: number y: number&#125; 另外，接口中也可以定义可选属性，只读属性 interface IInfoType &#123; readonly name: string age?: number&#125; 索引类型 interface IndexLanguage &#123; [index: number]: string&#125;const frontLanguage: IndexLanguage = &#123; 0: &quot;HTML&quot;, 1: &quot;CSS&quot;, 2: &quot;JavaScript&quot;, 3: &quot;Vue&quot;&#125; 函数类型 用过接口interface来定义函数类型 interface CalcFunc &#123; (num1: number, num2: number):number&#125;const add: CalcFunc = (num1, num2) =&gt; &#123; return num1 + num2&#125; 当然还是推荐使用类型别名来定义函数 type CalcFunc = (num1: number, num2: number) =&gt; number 接口继承 接口和类一样可以进行继承 interface ISwim &#123; swimming: () =&gt; void&#125;interface IRunning &#123; running: () =&gt; void&#125;interface IPerson extends ISwim, IRunning &#123;&#125;const action: IPerson = &#123; swimming() &#123;&#125;, running() &#123;&#125;&#125; 接口的实现 implements 用于指定 class 满足某个接口，而且类可以实现多个接口 不是很懂 面向接口开发 interface ISwim &#123; swimming: () =&gt; void&#125;interface IRun &#123; running: () =&gt; void&#125;class Person implements ISwim, IRun &#123; swimming() &#123;&#125; running() &#123;&#125;&#125;function swim(swimmer: ISwim) &#123; swimmer.swimming()&#125;const p = new Person()swim(p) 交叉类型 一种类型合并，表示需要满足多个类型的条件 type MyType = number &amp; string interface 和 type 区别 interface可以重复对某个接口来定义属性和方法 而type定义的是别名，别名是不能重复的 字面量赋值 interface IPerson &#123; name: string age: number height: number&#125;function printInfo(person: IPerson) &#123; console.log(person);&#125;// printInfo(&#123;// name: &quot;xxx&quot;,// age: 18,// height: 1.88,// address: &quot;广州市&quot; // 报错// &#125;)const info = &#123; // 定义字面量 name: &quot;why&quot;, age: 18, height: 1.88, address: &quot;广州市&quot;&#125;printInfo(info) // 再赋值就不会报错 这是因为TypeScript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。 但是之后如果我们是将一个 变量标识符赋值给其他的变量时，会进行freshness擦除操作 TS枚举类型 枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型 枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型 定义枚举类型的关键字：enum enum Direction &#123; LEFT, RIGHT, TOP, BOTTOM&#125;function turnDirection(direction: Direction) &#123; switch (direction) &#123; case Direction.LEFT: console.log(&quot;改变角色的方向向左&quot;) break; case Direction.RIGHT: console.log(&quot;改变角色的方向向右&quot;) break; case Direction.TOP: console.log(&quot;改变角色的方向向上&quot;) break; case Direction.BOTTOM: console.log(&quot;改变角色的方向向下&quot;) break; default: const foo: never = direction; break; &#125;&#125; TS泛型 非常重要！ 基本使用 简单来说就是，类型参数化 类型决定在调用函数的时候 基本使用：多加一个&lt;Type&gt;参数来接收类型 function sum&lt;Type&gt;(num1: Type):Type &#123; return num1&#125;sum&lt;number&gt;(10)sum&lt;string&gt;(&quot;123&quot;)sum&lt;&#123;name: string&#125;&gt;(&#123;name: &#x27;xxx&#x27;&#125;) 还有一种调用方式，类型推导 sum(50) // 那么类型Type就是字面量50 另外，还可以传入多个类型 function foo&lt;T, E, O&gt;(arg1: T, arg2: E, arg3: O, ...args: T[]) &#123;// ...args: T[] 是剩余参数,放到一个数组，只能选择前面&lt;&gt;定义的类型,&#125;foo&lt;number, string, boolean&gt;(10, &quot;aaa&quot;, true) 开发时常用的名称： T：Type的缩写，类型 K、V：key和value的缩写，键值对 E：Element的缩写，元素 O：Object的缩写，对象 泛型接口 定义接口中使用泛型 interface IPerson&lt;T&gt; &#123; name: T&#125;const p:IPerson&lt;string&gt; = &#123; name: &#x27;xx&#x27;,&#125; 泛型类 定义类使用泛型 class Person&lt;T1, T2&gt; &#123; name: T1 age: T2 constructor(name: T1, age: T2) &#123; this.name = name this.age = age &#125;&#125;// 类型推断let p1 = new Person(&quot;kkk&quot;, 20)// 自己定义类型let p2 = new Person&lt;string, number&gt;(&#x27;xxx&#x27;, 18)let p3:Person&lt;string, number&gt; = new Person(&quot;aaa&quot;, 21) 泛型约束 给类型参数一点约束 关键字 extends interface ILength &#123; length: number&#125;function getLength&lt;T extends ILength&gt;(arg: T) &#123; return arg.length&#125;// 传入的参数必须有length属性getLength(&quot;aaa&quot;)getLength([&quot;aaa&quot;, &quot;bbb&quot;])getLength(&#123;length: 100&#125;) TS其他内容 模块化开发 TS有两种方式控制作用域 模块化 支持ES Module，CommonJS 命名空间namespace 是将一个模块内部再进行作用域的划分，防止一些命名 冲突的问题 // 为了其他文件能使用，这里还要导出export namespace time &#123; // 内部要export导出，才能在这个ts模块中使用 export function format(time: string) &#123; return &quot;2022-4-13&quot; &#125; // 其他的逻辑 export let name: string = &quot;aaa&quot;&#125;export namespace price &#123; function format(price: number) &#123; return &quot;99.99&quot; &#125;&#125; TS早期的东西，个人还是选择模块化 类型的查找 在之前，我们除了自己编写类型，还有用到一些其他的类型，比如说 document.getElementById(&quot;image&quot;) as HTMLImageElement HTMLImageElement 类型来自哪里呢？ 首先我们需要知道一种ts文件：.d.ts为后缀名的文件 这种文件是用来做类型的声明的（declare）。它仅仅用来做类型检测，告诉typescript我们有哪些类型 这种文件是不需要转成js文件来运行的 那么typescript会在哪里查找我们的类型声明呢？ 有三种： 内置类型声明 typescript自带的，帮助我们内置了JS运行时的一些标准化API的声明文件 比如如Math、Date等内置类型，也包括DOM API，比如Window、Document等 内置类型声明通常在我们安装typescript环境中会带有 github:https://github.com/microsoft/TypeScript/tree/main/lib 外部定义类型声明 通常是我们使用一些库时，需要的一些类型声明 这些库有两种类型声明方式 在自己库中进行类型声明（编写.d.ts文件），比如axios 通过社区的一个公有库DefinitelyTyped存放类型声明文件 github链接： 该库的GitHub地址：https://github.com/DefinitelyTyped/DefinitelyTyped/ 该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search= 比如我们需要安装react的类型声明，就可以去查找安装方式 自定义类型声明 比如我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash 这时候我们要自己声明类型文件： 任意一个项目文件夹下定义.d.ts 文件，ts会自己找到的 声明模块关键字：declare // 声明模块declare module &#x27;lodash&#x27; &#123; export function join(arr: any[]): void&#125; 声明变量-函数-类 在.d.ts 文件中声明 declare let myName: stringdeclare let myAge: number// 只是声明类型, 不需要执行体declare function myFoo(): voiddeclare class Person &#123; name: string age: number constructor(name: string, age: number)&#125; 在其他地方使用： let myName = &quot;xxx&quot;let myAge = 18function myFoo() &#123;&#125;function Person(name, age) &#123; this.name = name this.age = age&#125;let p = new Person(&quot;xxx&quot;, 18) 声明模块 声明模块的语法: declare module ‘模块名’ {}。 在声明模块的内部，可以通过export导出对应库的类、函数等 declare module &#x27;lodash&#x27; &#123; export function join(arr: any[]): void&#125; 声明文件 文件会被当成模块使用，然后就可以引入 declare module &#x27;*.jpg&#x27;declare module &#x27;*.jepg&#x27;declare module &#x27;*.png&#x27; 在别的地方import使用 import img from &#x27;./img/xxx.jpg&#x27; 声明命名空间 比如在index.html中直接引入jQuery 然后在声明文件中（.d.ts） declare namespace $ &#123; export function ajax(settings: any):any&#125; 然后就可以在别的文件使用 $.ajax(&#123;...&#125;)","categories":[{"name":"深入Vue3+Typescript学习⚡","slug":"深入Vue3-Typescript学习⚡","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"}],"tags":[{"name":"-TS","slug":"TS","permalink":"https://hillyee.github.io/tags/TS/"}]},{"title":"面试题—JS手写篇","slug":"面试题—JS手写篇","date":"2022-04-14T02:11:41.000Z","updated":"2022-04-14T02:12:34.299Z","comments":true,"path":"2022/04/14/面试题—JS手写篇/","link":"","permalink":"https://hillyee.github.io/2022/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E6%89%8B%E5%86%99%E7%AF%87/","excerpt":"","text":"实现instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值） 要懂原型和原型链 function myInstanceof(target, origin) &#123; // 基本数据类型直接返回false if (typeof target !== &#x27;object&#x27; || target === null) return false // 拿到 target 的__proto__ let proto = Object.getPrototypeOf(target) // proto不为null就继续 while(proto) &#123; // 找到相同的原型对象 if (proto == origin.prototype) return true // 继续沿着原型链找 proto = Object.getPrototypeOf(proto) &#125; return false&#125;console.log(myInstanceof(&quot;111&quot;, String)); //falseconsole.log(myInstanceof(new String(&quot;111&quot;), String));//trueclass People &#123;&#125;class Student extends People &#123;&#125; const stu = new Student();console.log(stu instanceof People); // trueconsole.log(stu instanceof Student); // true JS如何实现继承？ 方式1：借助原型链 // 父类function Person() &#123; this.name = &#x27;pName&#x27; this.age = 18 this.friends = []&#125;Person.prototype.sayHello = function() &#123; console.log(&#x27;Hello&#x27;);&#125;// 子类function Student() &#123; this.height = 1.88&#125;let p = new Person() // 获得Person类的属性方法console.log(p);// 我们让Student的原型指向pStudent.prototype = plet stu = new Student()console.log(stu.name); // pNamestu.sayHello() // Hello// 可见我们已经拿到了父类的属性和方法 这种实现方法存在的问题： 1.当我们打印实例stu的时候，继承的属性不能直观看到，只能在__proto__属性中看到 console.log(stu)// Student &#123;height: 1.88&#125; 2.另外，如果我们创建两个实例对象，并改变friends属性 stu1.friends.push(&#x27;aaa&#x27;)console.log(stu2.friends); // [&#x27;aaa&#x27;] 明明改变的是stu1的属性，为什么stu2也变了？ 因为我们它们的隐式原型指向的是同一个对象，p 3.前面实现的过程都没有传递参数 方式2：借助构造函数 使用call调用构造函数，传入的this为当前实例，并且可以把参数传给父类处理 // 父类function Person(name, age) &#123; this.name = name this.age = age this.friends = []&#125;Person.prototype.sayHello = function() &#123; console.log(&#x27;Hello&#x27;);&#125;// 子类function Student(name, age, height) &#123; Person.call(this, name, age) // 这里可以获得父类的属性 this.height = height&#125;let p = new Person() // 依然需要这里来获得方法Student.prototype = plet stu1 = new Student(&#x27;aaa&#x27;, 18, 1.78)let stu2 = new Student(&#x27;bbb&#x27;, 20, 1.88)stu1.friends.push(&#x27;aaa&#x27;)console.log(stu1);console.log(stu2);stu1.sayHello() // Hello 构造函数的方法可以解决原型链方式的问题，但是依然存在弊端 Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person） stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的） 方式3：寄生组合式继承(最终方案) **Object.create()**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 Object.create(XXX) 也就是传入的对象XXX，作为新对象的原型 // 父类function Person(name, age, friends) &#123; this.name = name this.age = age this.friends = friends&#125;Person.prototype.sayHello = function() &#123; console.log(&#x27;Hello&#x27;);&#125;// 子类function Student(name, age, friends, height) &#123; // 获取父类中的属性和方法 Person.call(this, name, age, friends) this.height = height&#125;// 再获取一份父类的prototype中的属性和方法Student.prototype = Object.create(Person.prototype)Student.prototype.constructor = Studentlet stu = new Student(&#x27;aaa&#x27;, 18, [&#x27;fre1&#x27;], 1.88)console.log(stu); 当然，我们也可以封装一个方法来继承父类prototype中的属性和方法 function inheritPrototype(SubType, SuperType) &#123; SubType.prototype = Object.create(SuperType.prototype) // 当然子类的prototype还需要有constructor指向子构造函数本身 Object.defineProperty(SubType.prototype, &quot;constructor&quot;, &#123; enumerable: false, configurable: true, writable: true, value: SubType &#125;)&#125;...inheritPrototype(Student, Person) JS柯里化实现 要求，传入一个函数，返回一个柯里化的函数 思路：当已经传入的参数 大于等于 所需要的参数时，就执行函数 没有达到个数时，需要返回一个新的函数，继续来收集参数，接收到参数后，递归调用curried来检查函数的个数是否达到 function myCurrying(fn) &#123; function curried(...args) &#123; // 当已经传入的参数 大于等于 需要的参数时, 就执行函数 if (args.length &gt;= fn.length) &#123; // fn() return fn.apply(this, args) &#125; else &#123; // 没有达到个数时, 需要返回一个新的函数,继续来接收参数 function curried2(...args2) &#123; // 接收到参数后, 需要递归调用curried来检查函数的个数是否达到 return curried.apply(this, [...args, ...args2]) &#125; return curried2 &#125; &#125; // 返回一个柯里化的函数 return curried&#125;function add1(x, y, z) &#123; return x + y + z&#125;var curryAdd = myCurrying(add1)console.log(curryAdd(10, 20, 30));console.log(curryAdd(10)(20, 30));console.log(curryAdd(10)(20)(30));","categories":[{"name":"😣面试题-js篇","slug":"😣面试题-js篇","permalink":"https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"}]},{"title":"Proxy-Reflect-响应式原理","slug":"Proxy-Reflect-响应式原理","date":"2022-04-11T09:03:22.000Z","updated":"2022-04-11T09:06:05.734Z","comments":true,"path":"2022/04/11/Proxy-Reflect-响应式原理/","link":"","permalink":"https://hillyee.github.io/2022/04/11/Proxy-Reflect-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"Proxy 监听对象的操作 如果我们希望监听一个对象中的属性被设置或获取的过程 在之前，我们可以通过 Object.defineProperty 的存储属性描述符（get set）来监听到 const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;Object.keys(obj).forEach(key =&gt; &#123; let value = obj[key] Object.defineProperty(obj, key, &#123; get: function() &#123; console.log(`监听到obj对象的$&#123;key&#125;属性被访问了`); return value &#125;, set: function(newValue) &#123; console.log(`监听到obj对象的$&#123;key&#125;属性被设置值`); value = newValue &#125; &#125;)&#125;)obj.name = &#x27;asd&#x27;console.log(obj.name); 但是如果我们想要监听更加丰富的操作，比如说新增属性、删除属性，那么这个方法是无能为力的 而且我们要知道，这个方法的存储描述符设计的初衷也不是为了监听一个完整的对象的 Proxy的基本使用 这也是我们监听对象操作的第二种方式 在 ES6 中，新增了Proxy类，用于帮助我们创建一个代理 如果我们希望监听一个对象的相关操作，我们可以先根据这个对象创建一个代理对象（Proxy对象）。 然后对该对象的所有操作，我们都通过代理对象完成，因为这个代理对象可以帮我们监听我们对原对象进行的操作 怎么来使用这个Proxy代理呢？ const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;const objProxy = new Proxy(obj, &#123; // 获取值时的捕获器 // target:原对象, key:属性 get: function(target, key) &#123; console.log(`监听到对象的$&#123;key&#125;属性被访问了`, target); return target[key] &#125;, // 设置值的捕获器 set: function(target, key, newValue) &#123; console.log(`监听到对象的$&#123;key&#125;属性被设置值`, target); target[key] = newValue &#125;, // 监听in的捕获器 has: function(target, key) &#123; console.log(`监听到对象的$&#123;key&#125;属性in操作`, target); return key in target &#125;, // 监听delete的捕获器 deleteProperty: function(target, key) &#123; console.log(`监听到对象的$&#123;key&#125;属性delete操作`, target); delete target[key] &#125;&#125;)console.log(objProxy.name);// 监听到对象的name属性被访问了 &#123;name: &#x27;xxx&#x27;, age: 18&#125;// xxxobjProxy.name = &#x27;kkk&#x27;// 监听到对象的name属性被设置值 &#123;name: &#x27;xxx&#x27;, age: 18&#125;console.log(obj.name); // kkkconsole.log(&quot;name&quot; in objProxy); // truedelete objProxy.name 为什么我们对代理对象做出的改变，原对象也是会变的？ 因为我们设置值的时候，就是直接对原对象设置的，target[key] = newValue Proxy所有捕获器 有13个捕获器 Proxy 对函数的监听： function foo() &#123;&#125;const fooProxy = new Proxy(foo, &#123; apply: function(target, thisArg, arrArray) &#123; console.log(&quot;对foo函数进行了apply调用&quot;); return target.apply(thisArg, arrArray) &#125;, construct: function(target, arrArray, newTarget) &#123; console.log(&quot;对foo函数进行了new调用&quot;); return new target(...arrArray) &#125;&#125;)fooProxy.apply(&#123;&#125;, [&#x27;aaa&#x27;,&#x27;bbb&#x27;])new fooProxy(&quot;ddd&quot;, &quot;fff&quot;) Reflect 简单介绍 Reflect是什么？ ES6 新增的一个API，它是一个对象，字面意思是反射 有什么用呢？ 主要是提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法 比如：Reflect.getPrototype(target) 类似于 Object.getPrototype(target) 那有Object可以做这些操作，为什么还要新增 Reflect 对象呢？ 因为在早期的 ECMA 规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范，所以将这些API放在 Object 上 但是Object作为一个构造函数，这些操作放到它身上并不合适 另外还包含一些类似于 in、delete操作符，Reflect让原本的命令式变成函数式 .has ()等 所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上 Object和Reflect对象之间的API关系 MDN https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods Reflect常见方法 跟Proxy一一对应的，也是13个 Reflect 和 Proxy 一起使用 我们可以对前面Proxy案例中，对原对象的操作都修改为Reflect来操作 const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;const objProxy = new Proxy(obj, &#123; get(target, key, receiver) &#123; console.log(&quot;get---------&quot;) // return target[key] // 不直接修改原对象了 return Reflect.get(target, key) &#125;, set(target, key, newValue, receiver) &#123; console.log(&quot;set---------&quot;) // target[key] = newValue // 可以拿到设置成功与否的结果,一个布尔值 const result = Reflect.set(target, key, newValue) // 然后就可以根据结果做一些操作 if (result) &#123; &#125; else &#123;&#125; &#125;&#125;)objProxy.name = &#x27;kkk&#x27;console.log(objProxy.name); // kkk Receiver参数的作用 访问器还有一个参数 receiver 作用：如果我们的源对象有setter，getter的访问器属性，那么可以通过receiver来改变里面的this const obj = &#123; _name: &quot;xxx&quot;, age: 18, get name() &#123; return this._name // 改变这里的this &#125;, set name(newValue) &#123; this._name = newValue &#125;&#125;const objProxy = new Proxy(obj, &#123; get(target, key, receiver) &#123; // receiver是创建出来的代理对象 console.log(receiver === objProxy); console.log(&#x27;get方法被访问&#x27;, key, receiver); return Reflect.get(target, key, receiver) &#125;, set(target, key, newValue, receiver) &#123; let res = Reflect.set(target, key, newValue, receiver) console.log(&#x27;set成功&#x27;, res); &#125;&#125;)objProxy.name = &#x27;kkk&#x27;console.log(objProxy.name); 改变this，让它指向代理对象 又对代理对象有操作，所以捕获了两次 Reflect中的construct 很少很少用到叭，ryfES6文档： Reflect.construct(target, args) 等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。 应用场景，直接看例子 function Student(name, age) &#123; this.name = name this.age = age&#125;function Teacher() &#123;&#125;// 执行Student函数中的内容，但是创建出来的对象是Teacher对象const teacher = Reflect.construct(Student, [&quot;xxx&quot;, 18], Teacher)console.log(teacher);// Teacher &#123;name: &#x27;xxx&#x27;, age: 18&#125;console.log(teacher.__proto__ === Teacher.prototype);// true 响应式原理 什么是响应式 先看一段代码： let m = 100// 一段代码console.log(m);console.log(m * 2);console.log(m + 100);m = 200 当 m 发生改变的时候，上面依赖m的一段代码自动重新执行 这种可以自动响应数据变量的代码机制，我们就称之为响应式的 实现响应式 响应式函数设计与封装 首先，需要重新执行的代码可能有很多行，因此我们可以将这些代码放到一个函数中 当数据发生变化的时候，我们让这个函数执行 // 对象的响应式const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;// 依赖obj的代码function objFn() &#123; console.log(&#x27;obj变了&#x27;);&#125;obj.name = &#x27;kkk&#x27;// 当数据发生变化的时候,函数再次执行objFn() 这是我们简单的思想，如果我们有多个响应式函数需要再次执行呢？ 那么我们可以封装一个函数，把这些响应式函数都收集起来 // 封装一个响应式的函数// 把响应式函数收集到数组中 // 改let reactiveFns = []function watchFn(fn) &#123; reactiveFns.push(fn)&#125;// 对象的响应式const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;// 我们把需要响应式的函数传入watchFnwatchFn(function() &#123; // 改 console.log(&#x27;obj变了&#x27;);&#125;)watchFn(function() &#123; console.log(&#x27;name变了&#x27;);&#125;)obj.name = &#x27;kkk&#x27;// 当数据发生变化的时候,执行收集的响应式函数reactiveFns.forEach(fn =&gt; &#123; // 改 fn()&#125;) 响应式依赖的收集 目前我们收集的依赖全都放到一个数组来保存，这存在很大的问题。 实际开发中我们需要监听很多对象的响应式，这些对象需要监听的属性也不止一个，它们都会有对应的响应式函数 所以我们要设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数 class Depend &#123; // 改 constructor() &#123; this.reactiveFns = [] &#125; addDepend(reactiveFn) &#123; this.reactiveFns.push(reactiveFn) &#125; // 通知执行依赖 notify() &#123; this.reactiveFns.forEach(fn =&gt; &#123; fn() &#125;) &#125;&#125;const depend = new Depend() // 改function watchFn(fn) &#123; depend.addDepend(fn)&#125;// 对象的响应式const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;watchFn(function() &#123; console.log(&#x27;obj的name变了&#x27;, obj.name);&#125;)watchFn(function() &#123; console.log(&#x27;name变了&#x27;, obj.name);&#125;)obj.name = &#x27;kkk&#x27;// 当数据发生变化的时候,执行收集的响应式函数depend.notify() // 改 自动监听对象变化 现在我们有一个问题，数据发生改变的时候，我们是手动去调用notify()让依赖函数执行的 我们需要自动监听对象变化 注意，我们创建了代理对象之后，对原对象的操作都通过代理对象完成了 class Depend &#123; constructor() &#123; this.reactiveFns = [] &#125; addDepend(reactiveFn) &#123; this.reactiveFns.push(reactiveFn) &#125; // 通知执行依赖 notify() &#123; this.reactiveFns.forEach(fn =&gt; &#123; fn() &#125;) &#125;&#125;const depend = new Depend()function watchFn(fn) &#123; depend.addDepend(fn)&#125;// 对象的响应式const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;// 自动监听对象的属性变化const objProxy = new Proxy(obj, &#123; // 改 get(target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;, set(target, key, newValue, receiver) &#123; Reflect.set(target, key, newValue, receiver) depend.notify() // 在这里执行 &#125;&#125;)watchFn(function() &#123; console.log(&#x27;obj的name变了&#x27;, objProxy.name);&#125;)watchFn(function() &#123; console.log(&#x27;name变了&#x27;, objProxy.name);&#125;)// 对代理对象操作objProxy.name = &#x27;kkk&#x27; // 改 Vue3 用的Proxy，Vue2用Object.defineProperty() 监听 依赖收集的管理 我们可以看出来，上面只创建了一个depend对象来管理obj.name变化需要监听的响应式函数 如果我们有多个对象，需要监听不同的属性，那么我们可以怎么样来管理不同对象的不同依赖关系呢？ 依赖收集的数据结构，这里必须要理清楚这种结构的设计，我们用到了 Map，WeakMap 伪代码：结构大概就是这样子 const obj1Map = new Map()obj1Map.set(&quot;name&quot;, &quot;name的所有depend&quot;)obj1Map.set(&quot;age&quot;, &quot;age的所有depend&quot;)const obj2Map = new Map()obj2Map.set(&quot;height&quot;, &quot;height的所有depend&quot;)let targetMap = new WeakMap()targetMap(obj1, obj1Map)targetMap(obj2, obj2Map)// 当数据变化obj1.name = &#x27;&#x27;// 拿到obj1的name属性的所有依赖// 根据对象拿对应的map,再根据属性拿依赖函数const depend = targetMap.get(obj).get(&quot;name&quot;) 具体代码实现： 先创建一个weakMap，并封装一个获取depend的函数 class Depend &#123; constructor() &#123; this.reactiveFns = [] &#125; addDepend(reactiveFn) &#123; this.reactiveFns.push(reactiveFn) &#125; // 通知执行依赖 notify() &#123; this.reactiveFns.forEach(fn =&gt; &#123; fn() &#125;) &#125;&#125;// 封装一个响应式的函数 const depend = new Depend()function watchFn(fn) &#123; depend.addDepend(fn)&#125;// 封装一个获取depend的函数 // 改const targetMap = new WeakMap()function getDepends(target, key) &#123; // 根据对象获取map let map = targetMap.get(target) // 如果没有获取到map,说明这个对象是第一次添加依赖 // 我们要给这个对象新建一个map if (!map) &#123; map = new Map() targetMap.set( target, map) &#125; // 根据key获取依赖 let depend = map.get(key) if (!depend) &#123; depend = new Depend() map.set(key, depend) &#125; return depend&#125;// 对象的响应式const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;// 自动监听对象的属性变化const objProxy = new Proxy(obj, &#123; get(target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;, set(target, key, newValue, receiver) &#123; Reflect.set(target, key, newValue, receiver) // 捕获获取值的操作,获取依赖,然后执行 const depend = getDepends(target, key) // 改 depend.notify() // 在这里执行 &#125;&#125;)watchFn(function() &#123; console.log(&#x27;obj的name变了&#x27;, objProxy.name);&#125;)watchFn(function() &#123; console.log(&#x27;name变了&#x27;, objProxy.name);&#125;)// 对代理对象操作objProxy.name = &#x27;kkk&#x27; 现在我们执行会发现，根本没有实现响应式，为什么？ 因为我们在watchFn添加依赖函数的时候，不管三七二十一，全都添加到一个depend里面了 所以当我们获取依赖的时候，根本无法根据对象，key来正确的获取对应key的依赖函数 那么正确的依赖应该在哪里收集呢？ 应该在我们调用Proxy的get捕获器的时候。当我们第一次获取属性值的时候，我们就应该对这个key收集它自己的依赖 另外，当我们在get里面添加依赖的时候出现一个问题，我们怎么拿到这个响应函数呢？ 定义一个全局的变量 activeReactiveFn class Depend &#123; constructor() &#123; this.reactiveFns = [] &#125; addDepend(reactiveFn) &#123; this.reactiveFns.push(reactiveFn) &#125; // 通知执行依赖 notify() &#123; this.reactiveFns.forEach(fn =&gt; &#123; fn() &#125;) &#125;&#125;// 封装一个响应式的函数let activeReactiveFn = nullfunction watchFn(fn) &#123; // 改！！ activeReactiveFn = fn fn() // 用原数据先执行一次函数, 收集依赖 activeReactiveFn = null&#125;// 封装一个获取depend的函数const targetMap = new WeakMap()function getDepends(target, key) &#123; // 根据对象获取map let map = targetMap.get(target) // 如果没有获取到map,说明这个对象是第一次添加依赖 // 我们要给这个对象新建一个map if (!map) &#123; map = new Map() targetMap.set( target, map) &#125; // 根据key获取依赖 let depend = map.get(key) if (!depend) &#123; depend = new Depend() map.set(key, depend) &#125; return depend&#125;// 对象的响应式let obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;// 自动监听对象的属性变化const objProxy = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // 根据target,key获取对应的depend // 改！ const depend = getDepends(target, key) // 给depend对象中添加响应式函数 depend.addDepend(activeReactiveFn) return Reflect.get(target, key, receiver) &#125;, set: function(target, key, newValue, receiver) &#123; Reflect.set(target, key, newValue, receiver) // 捕获获取值的操作,获取依赖,然后执行 const depend = getDepends(target, key) depend.notify() // 在这里执行 &#125;&#125;)watchFn(function() &#123; console.log(&#x27;obj的name&#x27;, objProxy.name);&#125;)watchFn(function() &#123; console.log(&#x27;name&#x27;, objProxy.name);&#125;)watchFn(function() &#123; console.log(&#x27;age&#x27;, objProxy.age);&#125;)console.log(&#x27;----------修改前---&#x27;);objProxy.name = &#x27;kkk&#x27;// objProxy.age = 20 一个注意的地方：在watchFn()函数里面，我们会先调用一次传入的函数，为什么呢？ 因为这个函数如果有对某个属性有get的操作的话，我们就能捕获到，而我们在get里面进行收集依赖的操作，就可以收集到这个属性的依赖了 对 Depend 重构 现在依然存在问题： 如果函数中用到了两次key，那么我们这个函数就会被收集两次，即重复收集了依赖，后面我们执行depend里面的函数的时候，就会重复执行这个函数 watchFn(function() &#123; console.log(&#x27;name&#x27;, objProxy.name); console.log(&#x27;name22&#x27;, objProxy.name);&#125;)console.log(&#x27;----------修改前---&#x27;);objProxy.name = &#x27;kkk&#x27; ​ 解决方法：使用Set来保存依赖函数（Set元素不重复） 还有一个可以优化的地方：我们并不希望将添加 activeReactiveFn 方法放在get里面，因为这是属于 Depend 类的行为 修改后： // 保存当前需要收集的响应式函数let activeReactiveFn = null // 改！class Depend &#123; constructor() &#123; this.reactiveFns = new Set() // 改！ &#125; depend() &#123; if (activeReactiveFn) &#123; this.reactiveFns.add(activeReactiveFn) // 改！ &#125; &#125; notify() &#123; this.reactiveFns.forEach(fn =&gt; &#123; fn() &#125;) &#125;&#125;// 封装一个响应式的函数function watchFn(fn) &#123; activeReactiveFn = fn fn() // 用原数据先执行一次函数, 收集依赖 activeReactiveFn = null&#125;// 封装一个获取depend的函数const targetMap = new WeakMap()function getDepends(target, key) &#123; let map = targetMap.get(target) if (!map) &#123; map = new Map() targetMap.set( target, map) &#125; // 根据key获取依赖 let depend = map.get(key) if (!depend) &#123; depend = new Depend() map.set(key, depend) &#125; return depend&#125;// 对象的响应式let obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;// 自动监听对象的属性变化const objProxy = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // 根据target,key获取对应的depend const depend = getDepends(target, key) // 给depend对象中添加响应式函数 depend.depend() // 改！ return Reflect.get(target, key, receiver) &#125;, set: function(target, key, newValue, receiver) &#123; Reflect.set(target, key, newValue, receiver) const depend = getDepends(target, key) depend.notify() // 在这里执行 &#125;&#125;)watchFn(function() &#123; console.log(&#x27;name&#x27;, objProxy.name); console.log(&#x27;name22&#x27;, objProxy.name);&#125;)console.log(&#x27;----------修改前---&#x27;);objProxy.name = &#x27;kkk&#x27; 对象的响应式操作 最后一个问题，前面我们都是对一个对象（obj）实现响应式，那么如果是多个对象呢？ 所以我们要创建一个函数reactive，针对所有的对象都可以变成响应式对象 也就是实现多个对象的响应式 // 保存当前需要收集的响应式函数let activeReactiveFn = null class Depend &#123; constructor() &#123; this.reactiveFns = new Set() &#125; depend() &#123; if (activeReactiveFn) &#123; this.reactiveFns.add(activeReactiveFn) &#125; &#125; notify() &#123; this.reactiveFns.forEach(fn =&gt; &#123; fn() &#125;) &#125;&#125;// 封装一个响应式的函数function watchFn(fn) &#123; activeReactiveFn = fn fn() // 用原数据先执行一次函数, 收集依赖 activeReactiveFn = null&#125;// 封装一个获取depend的函数const targetMap = new WeakMap()function getDepends(target, key) &#123; let map = targetMap.get(target) if (!map) &#123; map = new Map() targetMap.set( target, map) &#125; // 根据key获取依赖 let depend = map.get(key) if (!depend) &#123; depend = new Depend() map.set(key, depend) &#125; return depend&#125;// 接收一个对象，返回一个响应式对象 // 改！！！function reactive(obj) &#123; return new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // 根据target,key获取对应的depend const depend = getDepends(target, key) // 给depend对象中添加响应式函数 depend.depend() // 改！ return Reflect.get(target, key, receiver) &#125;, set: function(target, key, newValue, receiver) &#123; Reflect.set(target, key, newValue, receiver) const depend = getDepends(target, key) depend.notify() // 在这里执行 &#125; &#125;)&#125;// 把需要响应式的对象传到reactive函数let obj = reactive(&#123; // 改！！ name: &#x27;xxx&#x27;, age: 18&#125;)let info = reactive(&#123; // 改！！ height: 1.88&#125;)watchFn(function() &#123; // 注意这里 因为reactive返回的就是代理对象，我们用obj接收，obj就是响应式的了,所以直接对obj操作 console.log(&#x27;name&#x27;, obj.name); console.log(&#x27;name22&#x27;, obj.name);&#125;)watchFn(function() &#123; console.log(&#x27;height&#x27;, info.height);&#125;)console.log(&#x27;--------------修改前---&#x27;);info.height = 1.78obj.name = &#x27;kkk&#x27; 到此！我们的响应式就实现完成了 Vue2响应式原理 前面所实现的响应式的代码，其实是Vue3中的响应式原理 Vue3主要是通过Proxy来监听数据的变化以及收集相关 的依赖的 而Vue2是通过Object.defineProerty 的方式来实现对象属性的监听 function reactive(obj) &#123; Object.keys(obj).forEach(key =&gt; &#123; let value = obj[key] Object.defineProperty(obj, key, &#123; get() &#123; const depend = getDepends(obj, key) depend.depend() return value &#125;, set(newValue) &#123; const depend = getDepends(obj, key) value = newValue depend.notify() &#125; &#125;) &#125;) return obj&#125; 在传入对象的时候，遍历所有的key，并且通过属性存储描述符来监听属性的获取和修改， 其他的逻辑和前面Vue3的响应式实现是一致的","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"}]},{"title":"10_ES6-ES12知识点","slug":"10_ES6-ES12知识点","date":"2022-04-10T02:57:25.000Z","updated":"2022-04-10T02:58:37.509Z","comments":true,"path":"2022/04/10/10_ES6-ES12知识点/","link":"","permalink":"https://hillyee.github.io/2022/04/10/10_ES6-ES12%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"ES6 字面量的增强 属性（Property Shorthand）、方法（Method Shorthand）的简写，计算属性名（Computed Property Names） var name = &#x27;fks&#x27;var age = 20var obj = &#123; // 1. 属性的简写 // name: name name, age, // 2. 方法的简写 // foo: function() &#123;&#125;, foo() &#123; console.log(this); &#125;, // obj.foo() this是obj // 这是不一样的 // foo: () =&gt; &#123;&#125; // this是全局 // 3.计算属性名 [name + 123]: &#x27;hahahah&#x27;&#125;obj.foo()console.log(obj); // &#123; name: &#x27;fks&#x27;, age: 20, foo: [Function: foo], fks123: &#x27;hahahah&#x27; &#125; 解构Destructuring 解构数组 var names = [&quot;asd&quot;, &#x27;fgd&#x27;, &#x27;dkb&#x27;]// 本来根据索引拿值// var item1 = names[0]// var item2 = names[1]// var item3 = names[2]// 解构var [item1, item2, item3] = namesconsole.log(item1, item2, item3);// 解构后面的元素var [ , , itemz] = namesconsole.log(itemz);// 解构一个元素，后面的元素放到一个新数组var [itemx, ...newNames] = namesconsole.log(itemx, newNames) // asd [ &#x27;fgd&#x27;, &#x27;dkb&#x27; ]// 解构的默认值var [itema, itemb, itemc, itemd = &quot;ddd&quot;] = namesconsole.log(itemd); 解构对象 根据key解构 var obj = &#123; name: &#x27;asd&#x27;, age: 20, height: 1.88&#125;// 不规定顺序，只根据key来解构var &#123;age, name&#125; = objconsole.log(age, name); // 20 asd// 可以对key新命名var &#123; name: newName &#125; = objconsole.log(newName);// 可以设置默认值,如果属性不存在,会使用默认值var &#123; address: newAddress = &#x27;广州&#x27; &#125; = objconsole.log(newAddress); // 广州// 在函数参数中解构function foo(&#123;name, age&#125;) &#123; console.log(name, age);&#125;foo(obj) // asd 20 let/const let/const使用 let 声明一个变量 const 声明一个常量、衡量（constant） var foo = &#x27;foo&#x27;let bar = &#x27;bar&#x27; //定义变量const baz = &#x27;baz&#x27; // 常量// 注意1：const 本质上是传递的值不可以修改，如果传递的是一个引用类型（内存地址），是可以通过引用找到对应的对象去修改内部的属性值的const obj = &#123; name: &#x27;aaa&#x27;&#125;obj.name = &#x27;bbb&#x27; //可以改obj = &#123;&#125; // 不可以改 TypeError: Assignment to constant variable. // let / const 定义的变量名是不可以重复定义的let foo = &#x27;foo&#x27;let foo = &#x27;foo2&#x27; // Identifier &#x27;foo&#x27; has already been declared let/const作用域提升 使用let声明的变量，在声明之前访问会报错 console.log(foo);var foo = &#x27;foo&#x27;console.log(bar); // 声明之前访问会报错// 在这里bar已经被创建出来了let bar = &#x27;bar&#x27; // Reference(引用)Error: Cannot access &#x27;bar&#x27; before initialization 那么是不是意味着foo变量只有在代码执行阶段才会创建呢？ 事实上并不是，我们可以看一下ECMA262对 let 和 const 的描述 这些变量会被创建在包含他们的词法环境被实例化的时候，但是是不可以访问它们的，直到词法绑定被求值 那 let/const有没有作用域提升呢？ 作用域提升：在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升 所以被创建出来了，但不能被访问，不能称之为作用域提升 总结：let、const没有进行作用域提升，但是会在解析阶段被创建出来、 let/const变量保存 let / const 在全局声明变量保存在哪里了？ var foo = &#x27;foo&#x27;console.log(window.foo); // foolet bar = &#x27;bar&#x27;console.log(window.bar); // undefined 所以不在window let, const 是不会给window添加任何属性的 最新的ECMA标准中对执行上下文的描述 也就是说我们声明的变量和环境记录是被添加到变量环境中的（在一个对象保存） 但是标准没有规定这个对象是 window对象或者是其他对象 所以JS引擎在解析的时候，会有自己的实现 比如v8中其实是通过VariableMap的一个hashmap来实现它们的存储的 那么window对象呢？ window对象是早起的GO对象，在最新的实现中其实是浏览器添加的全局对象，并且 一直保持了window和var之间值的相等性 块级作用域 var 的块级作用域 ES5中，JS只会形成两个作用域：全局作用域和函数作用域 var 没有块级作用域 ES5中放到一个代码中定义的变量，外面是可以访问的 &#123; var foo = &quot;foo&quot;&#125;console.log(foo); // foo let / const 的块级作用域 ES6中新增了块级作用域，通过let、const、function、class 声明的标识符是具备块级作用域的限制的 注意函数，某些引擎会对函数的声明进行特殊处理，允许像var那样提升 &#123; let foo = &quot;aaa&quot; function demo() &#123; console.log(&#x27;demo function&#x27;); &#125; class Person &#123;&#125;&#125;// console.log(foo); // ReferenceError: foo is not defined\\// 对于函数,不同的浏览器有不同实现,(大部分浏览器为了兼容以前的代码.让function没有块级作用域) 所以这里可以访问demo// demo() // demo function 可以访问var p = new Person() // ReferenceError: Person is not defined if/switch/for 语句的代码就是块级作用域 // if语句的代码就是块级作用域if (true) &#123; let foo = &#x27;foo&#x27;&#125;console.log(foo); // 不能访问// switchswitch (color) &#123; case &quot;red&quot;: let bar = &quot;bar&quot;&#125;console.log(bar); // 不能访问// forfor (var i = 0; i &lt; 6; i++) &#123;&#125;// 循环执行结束, 全局中 i 是 6console.log(i); // 6 // 如果用letfor(let j = 0; j &lt; 6; j++) &#123;&#125;// 循环结束后, 全局中并不能访问jconsole.log(j); // j is not defined 块级作用域的应用场景 一个循环打印的问题 // 注意setTimeout是宏任务,循环结束后才执行for (var i = 0; i &lt; 6; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); // 打印 6 个 6,打印的是全局的 i &#125;)&#125;// 一种解决方法，立即执行函数for (var i = 0; i &lt; 6; i++) &#123; (function(i) &#123; // 打印的时候往上层作用域查找,找这里的i setTimeout(() =&gt; &#123; console.log(i); // 0 1 2 3 4 5 &#125;) &#125;)(i)&#125;// 如果用let,一次循环一个块,互不影响for(let j = 0; j &lt; 6; j++) &#123; setTimeout(() =&gt; &#123; console.log(j); // 0 1 2 3 4 5 &#125;)&#125; const注意的地方 因为有 i++，第二次循环需要用到第一次循环的i去++，const定义的是常量，是不可以改变的 for (const i = 0; i &lt; 3; i++) &#123; console.log(i);&#125;// TypeError: Assignment to constant variable. 但是ES6新增的 for…of可以 for (const item of names) &#123; console.log(item);&#125; 每次都会有一个新的const item，在不同的块级作用域中 暂时性死区 在一个代码中，使用let、const声明的变量，在声明之前都是不可以访问的 这种现象称之为暂时性死区 function foo() &#123; console.log(bar); // 不可访问 let bar = &#x27;abc&#x27;&#125;foo() 关于字符串 模板字符串 使用： const name = &#x27;sfa&#x27;const age = 18const message = `my name is $&#123;name&#125;, age is $&#123;age&#125;`console.log(message); // my name is sfa, age is 18 ${}里面也可以是表达式，也可以是函数 const str = `age is $&#123;age * 2&#125;`const str2 = `double age is $&#123;doubleAge()&#125;` 标签字符串 应该很少用到 // 第一个参数是模块字符串中的整个字符串，但是被切成多块放到一个数组function foo(m, n, x) &#123; console.log(m, n, x); // [ &#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;aaa&#x27; ] yuzi 18&#125;// 可以这样去调用一个函数// foo``// 当然也可以传参const name = &#x27;yuzi&#x27;const age = 18foo`Hello$&#123;name&#125;World$&#123;age&#125;aaa` 关于函数 函数的默认参数 如果没有传参，就会用默认参数 function foo(m = &#x27;aaa&#x27;, n = &#x27;bbb&#x27;) &#123; console.log(m, n);&#125; 默认参数也可以是对象，并且可以对对象解构，有两种解构方式 function foo(&#123;name, age&#125; = &#123;name: &#x27;asd&#x27;, age: 18&#125;) &#123; console.log(name, age);&#125;function foo2(&#123;name = &#x27;asd&#x27;, age = 18&#125; = &#123;&#125;) &#123;&#125; 另外注意：默认形参最好放到最后 function bar(x, y, z = 30) &#123; console.log(x, y, z)&#125; // 获取 函数的length值的时候，只获取默认形参之前的参数个数console.log(bar.length); // 2 函数的剩余参数 剩余参数必须放到最后 function foo(a, b, ...args) &#123; console.log(a, b, args); // 1 2 [ 3, 4, 5, 6 ]&#125;foo(1,2,3,4,5,6) 箭头函数的补充 没有自己的this，没有arguments 没有显式原型，所以不能作为构造函数，不能使用new创建对象 var bar = () =&gt; &#123; console.log(this, arguments); &#125;const b = new bar() // TypeError: bar is not a constructor 展开语法… const names = [&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;]const name2 = &#x27;kkk&#x27;function foo(x, y, z) &#123; console.log(x, y, z);&#125;// 1. 函数调用时使用foo(...names) // aaa bbb ccc// 2. 构造数组时const newNames = [...names, ...name2]console.log(newNames);// [ &#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;k&#x27;, &#x27;k&#x27;, &#x27;k&#x27; ]// 注意这里把字符串展开了// 3.构建对象字面量时 ES2018(ES9)const info = &#123;name: &#x27;ggg&#x27;, height: 1.88&#125;// 拷贝info的属性，并且可以添加新的属性const obj = &#123;...info, address: &#x27;广州市&#x27;&#125;console.log(obj)// &#123; name: &#x27;ggg&#x27;, height: 1.88, address: &#x27;广州市&#x27; &#125; 注意：展开运算符其实是一种浅拷贝 简单来说就是，拷贝的地址，指向的是同一个对象 const info = &#123; name: &#x27;fff&#x27;, hobby: &#123; h1: &#x27;study&#x27;, h2: &#x27;swim&#x27; &#125;&#125;const newInfo = &#123;...info&#125;newInfo.hobby.h1 = &#x27;sss&#x27;console.log(info.hobby.h1); // sss 原来的info也改了 表示数值的方法(进制) ob开头(binary)：二进制，0o开头(octonary)：八进制，0x开头(hexadecimal)：十六进制 const num1 = 100 // 十进制const num2 = 0b100 // 二进制const num3 = 0o100 // 八进制const num4 = 0x100 // 十六进制console.log(num1, num2, num3, num4); // 100 4 64 256 另外，大的数值有一个连接符，便于阅读(ES2021 ES12) const num = 10_000_000_000_000console.log(num); // 10000000000000 Symbol的使用 主要是用来创建独一无二的key值，注意使用的时候不要用new 创建Symbol const s1 = Symbol()const s2 = Symbol() // s1,s2是不一样的console.log(s1 === s2); // false// ES2019(ES10)中, Symbol还有一个描述(description)// 便于标记是哪个symbol，就像是标签const s3 = Symbol(&#x27;aaa&#x27;)console.log(s3); // Symbol(aaa)// 可以拿到这个描述console.log(s3.description); // &#x27;aaa&#x27; 在对象中作为key使用 const obj = &#123; [s1]: &#x27;yyy&#x27;, [s2]: &#x27;mmm&#x27;&#125;// 获取属性值console.log(obj[s1]); // &#x27;yyy&#x27;// 新增属性值obj[s3] = &#x27;kkk&#x27;// 也可以Object.defineProperty()方法添加属性Object.defineProperty(obj, s4, &#123;&#125;) 注意：获取属性值的时候不能通过 . 语法获取，因为 . 后面的是会被当做字符串 obj.s1，那么就会去找obj上key为’s1’这个属性值 使用Symbol作为key的属性名，在遍历的时候是获取不到的 console.log(Object.keys(obj)); // []console.log(Object.getOwnPropertyNames(obj)); // [] 如果想要获取的话可以使用 Object.getOwnPropertySymbols()方法 const sKeys = Object.getOwnPropertySymbols(obj)console.log(sKeys); // [ Symbol(), Symbol(), Symbol(aaa) ] 怎么让两个Symbol相等？ Symbol.for(key) 方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol 注意这跟 Symbol(‘aaa’) 标签是不一样的哦 // 也就是给symbol一个keyconst sa = Symbol.for(&quot;aaa&quot;)const sb = Symbol.for(&quot;aaa&quot;)console.log(sa === sb); // true 根据 symbol值获取key Symbol.keyFor(sym) 方法用来获取全局symbol 注册表中与某个 symbol 关联的键 const key = Symbol.keyFor(sa)console.log(key); // aaa Set 新增的一种数据结构（存储数据的方式） 是集合，里面的元素不重复 创建set和添加元素 // 1. 创建const set = new Set()// 添加元素set.add(10)set.add(20)set.add(30)console.log(set); // Set(3) &#123; 10, 20, 30 &#125;// 不重复set.add(10)console.log(set);// Set(3) &#123; 10, 20, 30 &#125; 注意添加对象时候的一种情况，因为添加的对象的地址是不一样的 set.add(&#123;&#125;)set.add(&#123;&#125;)console.log(set); // &#123; &#123;&#125;, &#123;&#125; &#125;// 以下添加的才是同一个对象const obj = &#123;&#125;set.add(obj)set.add(obj)console.log(set); // &#123; &#123;&#125; &#125; 最常见的应用：对数组去重 // 去重(把数组放进集合)const arr = [10, 20, 30, 40, 10, 20]const arrSet = new Set(arr)console.log(arrSet); // Set(4) &#123; 10, 20, 30, 40 &#125; Set的属性 set.size 返回元素个数 Set的方法 add() 添加元素clear() 清空集合元素delete(x) 删除某元素has(x) 是否包含x元素遍历：forEacharrSet.forEach(item =&gt; &#123; console.log(item);&#125;)for (const item of arrSet) &#123; console.log(item);&#125; WeakSet 用的很少，对于WeakSet的应用我就不纠结了 WeakSet跟set的区别：WeakSet只能存放对象类型 WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收 另外，WeakSet不能遍历，因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素那么有可能造成对象不能正常销毁，所以存储到WeakSet中的对象是没办法获取的 const weakSet = new WeakSet()weakSet.add(&#123;name: &#x27;asd&#x27;&#125;, &#123;&#125;) &#123; 地址1, 地址2 &#125; 弱引用console.log(weakSet); // WeakSet &#123; &lt;items unknown&gt; &#125; 我对弱引用的理解 关于强引用弱引用的一篇文章：https://juejin.cn/post/6993101968545677319#heading-21 Map 一种数据结构，键值对的形式，并且键可以是对象 普通对象的键不能是对象？不能 const obj1 = &#123; name: &#x27;aaa&#x27; &#125;const obj2 = &#123; name: &#x27;bbb&#x27; &#125;const info = &#123; [obj1]: &#x27;qqq&#x27;, [obj2]: &#x27;kkk&#x27;&#125;console.log(info);// &#123; &#x27;[object Object]&#x27;: &#x27;kkk&#x27; &#125;// 这下懂了吧，这个键会被转成字符串&#x27;[object Object]&#x27;,key重复了，值覆盖了 怎么使用Map？ // 使用const map = new Map()// 添加键值map.set(obj1, &#x27;aaa&#x27;)map.set(obj2, &#x27;bbb&#x27;)map.set(1, &#x27;ccc&#x27;)console.log(map);// 打印// Map(3) &#123;// &#123; name: &#x27;aaa&#x27; &#125; =&gt; &#x27;aaa&#x27;,// &#123; name: &#x27;bbb&#x27; &#125; =&gt; &#x27;bbb&#x27;,// 1 =&gt; &#x27;ccc&#x27;// &#125;// 另一种添加,把键值对放到数组const map2 = new Map([[obj1, &#x27;aaa&#x27;], [obj2, &#x27;bbb&#x27;]])console.log(map2);// Map(2) &#123; &#123; name: &#x27;aaa&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;bbb&#x27; &#125; =&gt; &#x27;bbb&#x27; &#125; 有什么属性和方法？ 属性：size：返回map对象的成员数量 方法： set(key, value) ：添加，设置键值，返回整个Map对象 get(key)：根据key获取值 has(key)：是否存在某一个key，返回布尔值 delete(key)：删除一个键值对，返回布尔值 clear()：清空元素 遍历 forEach() // 遍历map.forEach((item, key) =&gt; &#123; console.log(item, key);&#125;)// for..of遍历注意for (const item of map) &#123; // console.log(item); // 这里把一个键值对放到一个数组了 // [ &#123; name: &#x27;bbb&#x27; &#125;, &#x27;bbb&#x27; ] // 所以可以根据索引值分别拿 key, value console.log(item[0], item[1]);&#125;// 或者进行解构for (const [key, value] of map) &#123; console.log(key, value);&#125; WeakMap 和Map有什么区别呢？ WeakMap的key只能使用对象 WeakMap的key对对象的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收 常见方法： set(key, value)：添加键值，返回整个对象 get(key)：根据key获取值 has(key)：是否包含某个key，返回布尔值 delete(key)：根据key删除键值对，返回布尔值 WeakMap不能遍历 const obj = &#123; name: &#x27;asd&#x27;&#125;const weakMap = new WeakMap()weakMap.set(obj, &#x27;123&#x27;)console.log(weakMap); // WeakMap &#123; &lt;items unknown&gt; &#125; 响应式原理中的WeakMap使用 可以看看Vue3的响应式原理，之前实现mini-vue的时候实现过响应式系统 简单的思想就是： 创建一个WeakMap, key是obj1，值是一个Map结构, 这个Map，键是对象的属性，值是有依赖这个属性的函数， 当这个属性发生什么改变的时候，就执行这个属性所有依赖的函数 一个简单的响应式模拟实现 // 应用场景（vue3响应式原理）const obj1 = &#123; name: &#x27;qwe&#x27;, age: 20 &#125;function obj1NameFn1() &#123; console.log(&#x27;obj1NameFn1被执行&#x27;);&#125;function obj1NameFn2() &#123; console.log(&#x27;obj1NameFn2被执行&#x27;);&#125;function obj1AgeFn1() &#123; console.log(&quot;obj1AgeFn1&quot;)&#125;function obj1AgeFn2() &#123; console.log(&quot;obj1AgeFn2&quot;)&#125;// 1.创建WeakMapconst weakMap = new WeakMap()// 2.收集依赖结构// 2.1.对obj1收集的数据结构const obj1Map = new Map()obj1Map.set(&#x27;name&#x27;, [obj1NameFn1, obj1NameFn2])obj1Map.set(&#x27;age&#x27;, [obj1AgeFn1, obj1AgeFn2])weakMap.set(obj1, obj1Map)// 如果obj1.name发生改变obj1.name = &#x27;ggg&#x27;const targetMap = weakMap.get(obj1)const fns = targetMap.get(&quot;name&quot;)fns.forEach(fn =&gt; &#123; fn()&#125;); ES7 Array Includes 判断数组中是否包含某个元素 在之前我们经常使用 indexOf() 判断，该方法返回元素所在的索引值，没有就返回-1 const names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;ddd&#x27;]if (names.indexOf(&#x27;bbb&#x27;) !== -1) &#123; console.log(&#x27;包含bbb元素&#x27;);&#125; ES7 新增 Includes 方法 if (names.includes(&#x27;bbb&#x27;)) &#123; console.log(&#x27;包含bbb元素&#x27;);&#125; 对于 NaN的处理，indexOf()不能判断，includes可以 const names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;ddd&#x27;, NaN]console.log(names.indexOf(NaN)); // -1console.log(names.includes(NaN)); // true 指数的运算方法 // 在之前,指数运算通过 Math.pow()const res1 = Math.pow(3, 3) // ES7新增：**const res2 = 3 ** 3console.log(res1, res2); // 27 27 ES8 Object.values 之前我们可以通过 Object.keys()来获取一个对象的所有key，ES8提供Object.values() 获取所有值 const obj = &#123; name: &#x27;aaa&#x27;, age: 18&#125;console.log(Object.keys(obj)); // [ &#x27;name&#x27;, &#x27;age&#x27; ]console.log(Object.values(obj)); // [ &#x27;aaa&#x27;, 18 ]// 用的非常少console.log(Object.values([&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;]));console.log(Object.values(&#x27;asd&#x27;)); // [ &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27; ] Object.entries 获取到一个数组，数组中存放可枚举属性的键值对数组 const obj = &#123; name: &#x27;asdf&#x27;, age: 20&#125;const objEntries = Object.entries(obj)console.log(objEntries); // [ [ &#x27;name&#x27;, &#x27;asdf&#x27; ], [ &#x27;age&#x27;, 20 ] ]// 然后可以继续遍历这个数组，获得属性,值objEntries.forEach(item =&gt; &#123; console.log(item[0], item[1]);&#125;)console.log(Object.entries([&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;]));// [ [ &#x27;0&#x27;, &#x27;aaa&#x27; ], [ &#x27;1&#x27;, &#x27;bbb&#x27; ], [ &#x27;2&#x27;, &#x27;ccc&#x27; ] ] 索引值当做key了console.log(Object.entries(&#x27;sdf&#x27;)); // [ [ &#x27;0&#x27;, &#x27;s&#x27; ], [ &#x27;1&#x27;, &#x27;d&#x27; ], [ &#x27;2&#x27;, &#x27;f&#x27; ] ] padStart和padEnd 根据所给长度,和填充元素来往前或往后填充数组 const message = &quot;hello world&quot;const newMessage = message.padStart(15, &quot;*&quot;).padEnd(20, &#x27;-&#x27;)console.log(newMessage); // ****hello world----- 小案例：假设要对银行卡号用*隐藏 // 案例const cardNumber = &quot;123456781231548564321&quot;const lastFourCard = cardNumber.slice(-4) const finalCard = lastFourCard.padStart(cardNumber.length, &quot;*&quot;)console.log(finalCard); // *****************4321 slice 可以传入负数的哦，-4，倒数4位 Trailing-Commas ES8，允许在函数定义和调用时多加一个逗号 没什么，反正我们平时也不会加。trailing：后面的，commas：逗号 function foo(a, b,) &#123;&#125;foo(10, 20,) Object Descriptors ES8中新增对对象的操作，Object.getOwnPropertyDescriptors() 获取一个对象的所有自身属性的描述符 const obj = &#123; age: 18&#125;Object.defineProperty(obj, &#x27;name&#x27;, &#123; value: &#x27;hello&#x27;, enumerable: true, writable: true, configurable: false&#125;)console.log(Object.getOwnPropertyDescriptors(obj));// 打印&#123; age: &#123; value: 18, writable: true, enumerable: true, configurable: true &#125;, name: &#123; value: &#x27;hello&#x27;, writable: true, enumerable: true, configurable: false &#125;&#125; ES8 新增async await 的函数使用，后面另外记 ES9 Async iterators：迭代器，后续另外笔记 Object spread operators：对象展开运算符 const newObj = &#123;...obj, age:18&#125; Promise finally：后续Promise统一记 ES10 flat flatMap flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 // flatconst nums = [10, 20, [30, 40],[[1, 2],[3, 4]]]const newNums = nums.flat()// 默认深度为1console.log(newNums); // [ 10, 20, 30, 40, [ 1, 2 ], [ 3, 4 ] ]const newNums2 = nums.flat(2) //console.log(newNums2); // [10, 20, 30, 40,1, 2, 3, 4] flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组 先进行map，再flat，并且flat的深度为1 const nums2 = [1,2,3,4,5]const newNums2 = nums2.flatMap(item =&gt; &#123; return item * 2&#125;)console.log(newNums2); // [ 2, 4, 6, 8, 10 ] 这样看起来跟map没什么区别呀？那flatMap有什么应用场景吗？ 处理这样的字符串数组，把字符串分成一个个放到数组 const message = [&quot;Hello World&quot;, &quot;hello kk&quot;, &quot;my name is xxx&quot;]const words = message.flatMap(item =&gt; &#123; return item.split(&#x27; &#x27;)&#125;)console.log(words);// [&#x27;Hello&#x27;, &#x27;World&#x27;,&#x27;hello&#x27;, &#x27;kk&#x27;,&#x27;my&#x27;,&#x27;name&#x27;,&#x27;is&#x27;,&#x27;xxx&#x27;] Object fromEntries ES8有Object.entries将一个对象转换成entries ES10有Object.fromEntries 将entries转换成对象 const obj = &#123; name: &#x27;qws&#x27;, age: 18&#125;// ES8 entriesconst entries = Object.entries(obj)console.log(entries); // [ [ &#x27;name&#x27;, &#x27;qws&#x27; ], [ &#x27;age&#x27;, 18 ] ]const newObj = Object.fromEntries(entries)console.log(newObj); // &#123; name: &#x27;qws&#x27;, age: 18 &#125; 有什么应用场景吗？ 可以处理query参数，最终转换成对象使用 看到键值对的数组可以想到这个方法 const queryString = &#x27;name=xxx&amp;age=18&amp;height=1.88&#x27;const queryParams = new URLSearchParams(queryString)console.log(queryParams);// URLSearchParams &#123; &#x27;name&#x27; =&gt; &#x27;xxx&#x27;, &#x27;age&#x27; =&gt; &#x27;18&#x27;, &#x27;height&#x27; =&gt; &#x27;1.88&#x27; &#125;for (const param of queryParams) &#123; console.log(param);&#125;// 打印// [ &#x27;name&#x27;, &#x27;xxx&#x27; ]// [ &#x27;age&#x27;, &#x27;18&#x27; ]// [ &#x27;height&#x27;, &#x27;1.88&#x27; ]// 然后就可以利用fromEntries转成对象const paramObj = Object.fromEntries(queryParams)console.log(paramObj);// &#123; name: &#x27;xxx&#x27;, age: &#x27;18&#x27;, height: &#x27;1.88&#x27; &#125; trimStart trimEnd 单独去除前面或后面的空格 const str = &#x27; hello world &#x27;console.log(str.trim()); // 去除前后的空格console.log(str.trimStart()); // 去除前面的空格console.log(str.trimEnd()); // 去除后面的空格 Symbol description s1.description 这个属性可以获取symbol的描述（标签），前面symbol的笔记有写到 Optional catch binding 后续在try catch部分笔记 ES11 BigInt ES11引入的新的数据类型，用于表示大的整数 使用：加个n，或者 BigInt(num) // ES11前 最大的安全整数const maxInt = Number.MAX_SAFE_INTEGERconsole.log(maxInt); // 9007199254740991// 超过这个安全整数就可能出现表示错误console.log(maxInt + 1); // 9007199254740992console.log(maxInt + 2); // 9007199254740992 (错了)// ES11之后: BigIntconst bigInt = 900719925474099100nconsole.log(bigInt + 10n); // 900719925474099110nconsole.log(BigInt(100)); // 100nconsole.log(bigInt + BigInt(100));// 也可以把bigInt类型转Numberconsole.log(Number(bigInt)); // 900719925474099100 Nullish Coalescing Operator 空值 合并 运算 新增的操作符：?? 处理如果为空，那么使用默认值的判断 之前的 || 不能很好的处理空字符串，空串转为false，执行后面的语句 const foo = &quot;&quot;const res1 = foo || &#x27;default value&#x27;const res2 = foo ?? &#x27;default value&#x27;console.log(res1); // default valueconsole.log(res2); // &#x27;&#x27; Optional Chaining 可选链：让我们的代码在进行 null 和 undefined 判断时更加清晰和简洁 const info = &#123; name: &#x27;xxx&#x27;, // friend: &#123; // f1: &#123; // name: &#x27;mm&#x27; // &#125; // &#125;&#125;// 在之前，如果获取不存在的属性值console.log(info.name.friend); // undefined// 我们会做这样的判断if (info &amp;&amp; info.friend &amp;&amp; info.friend.f1) &#123; console.log(info.friend.f1.name);&#125;// ES11的可选链console.log(info.friend?.f1?.name);// info.friend存在吗?存在再继续 .f1console.log(&#x27;其他代码逻辑&#x27;); Global This 在之前我们想获取JS环境的全局对象，不同环境获取的方式又不一样 比如在浏览器中，通过 this，window来获取 Node中，通过global获取 所以 ES11 中对获取全局对象进行统一的规范：globalThis // 浏览器下console.log(this); // Windowconsole.log(window); // Window// Node下console.log(global);// ES11 各种环境获取全局对象console.log(globalThis); for…in标准化 在ES11之前，虽然很多浏览器支持 for…in 来遍历对象，但是并没有被ECMA标准化 ES11中，对其进行标准化，for…in 用于遍历对象的 key const obj = &#123; name: &#x27;xxx&#x27;, age: 18&#125;for (key in obj) &#123; console.log(key); // name // age&#125; Dynamic Import 后续在 ES Module 模块化中笔记 Promise.allSettled 后续Promise中笔记 import meta 后续在 ES Module 模块化中笔记 ES12 FinalizationRegistry FinalizationRegistry对象可以让你在对象被垃圾回收时请求一个回调 当一个在注册表中注册的对象被回收时，可以请求在某个时间点上调用一个清理回调（清理回调有时被称为 finalizer） 注册：register方法，注册任何想要清理后执行回调的对象，传入该对象，和所含的值 const finalRegistry = new FinalizationRegistry((value) =&gt; &#123; console.log(&quot;注册在finalRegistry的对象,某个被销毁&quot;, value);&#125;)let obj = &#123; name: &#x27;asd&#x27; &#125;let info = &#123; age: 15 &#125;finalRegistry.register(obj, &#x27;obj&#x27;)finalRegistry.register(info, &#x27;val&#x27;)obj = nullinfo = null// 注册在finalRegistry的对象,某个被销毁 val// 注册在finalRegistry的对象,某个被销毁 obj WeakRefs 如果我们默认将一个对象赋值给另一个引用，那么这个引用是强引用 如果我们希望是弱引用，可以使用 WeakRef 注意这里有一个 deref 方法获取弱引用的值 const finalRegistry = new FinalizationRegistry((value) =&gt; &#123; console.log(&quot;注册在finalRegistry的对象,某个被销毁&quot;, value);&#125;)let obj = &#123; name: &#x27;asd&#x27; &#125;let info = new WeakRef(obj)finalRegistry.register(obj, &#x27;obj&#x27;)// obj = null// 注册在finalRegistry的对象,某个被销毁 obj// 那还能获取info吗？// 因为回收要时间，所以这里也做一个延迟才获取属性值setTimeout(() =&gt; &#123; console.log(info.name); // undefined(不能这样获取) console.log(info.deref()?.name); // 如果原对象obj没有被销毁, 可以使用deref()来获取 // 如果被销毁了,获取到的是 undefined&#125;, 10000); logical assignment operators logical：逻辑的 几个逻辑赋值运算符 ||=，&amp;&amp;=（很少用），??= 可读性不是很好 ||= 逻辑或赋值运算 let message = &#x27;&#x27;// message = message || &#x27;default value&#x27;message ||= &#x27;default value&#x27;console.log(message); // default value// 也是不能判断空串的 &amp;&amp;= 逻辑与赋值运算（很少用） let obj = &#123; name: &#x27;xxx&#x27;&#125;// 有值取值info = obj &amp;&amp; obj.nameconsole.log(info); // xxxobj &amp;&amp;= obj.name console.log(obj); // xxx ??= 逻辑空赋值运算 0 “” 感觉是可以填补 || 不能很好的判断&quot;&quot; 0 let message = &quot;&quot;let msg = 0message ??= &quot;default value&quot;msg ??= &quot;default val&quot;console.log(message); // &quot;&quot;console.log(msg); // 0 Numeric Separator Numeric 数值的 Separator 分离器 大的数值有一个连接符 _ ，便于阅读 const num = 10_000_000_000_000console.log(num); // 10000000000000 String.replaceAll 字符串替换，替换所有匹配条件的地方 const res = &#x27;aabbcc&#x27;.replaceAll(&#x27;b&#x27;, &#x27;.&#x27;);console.log(res);// &#x27;aa..cc&#x27; 之前replace只换第一处匹配的地方 const res = &#x27;aabbcc&#x27;.replace(&#x27;b&#x27;, &#x27;.&#x27;);console.log(res);// aa.bcc","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://hillyee.github.io/tags/ES6/"}]},{"title":"09_class定义类_ES6","slug":"09_class定义类-ES6","date":"2022-04-08T06:57:33.000Z","updated":"2022-04-08T09:45:23.623Z","comments":true,"path":"2022/04/08/09_class定义类-ES6/","link":"","permalink":"https://hillyee.github.io/2022/04/08/09_class%E5%AE%9A%E4%B9%89%E7%B1%BB-ES6/","excerpt":"","text":"ES6中类的使用 认识class定义类 按照构造函数的形式创建类，不仅仅和编写普通的函数过于相似，而且代码并不容易理解 在ES6(ECMAScript2015)新的标准中使用了class关键字来直接定义类 但是类的本质上只是构造函数，原型链的语法糖 最终还是会被 babel 工具转换为ES5的代码 定义类的方式 可以发现类和构造函数的特性是一致的 // 类的声明class Person &#123;&#125;// 类的表达式(不怎么用)var Student = class &#123;&#125;// 类的特性console.log(Person) // [class Person]console.log(Person.prototype);// &#123;&#125;console.log(Person.prototype.__proto__); // [Object: null prototype] &#123;&#125;console.log(Person.prototype.constructor); // [class Person]console.log(typeof Person); // function// 创建实例var p = new Person()console.log(p.__proto__ === Person.prototype); // true 类的构造方法 一个类只能有一个构造函数 constructor，如果包含多个会报错 new 的时候： 在内存中创建一个对象 moni = { } 将类的原型prototype赋值给创建出来的对象的[[prototype]]，moni.__ptoto__ = Person.prototype 将对象复制给函数的this：new绑定 this = moni 执行函数体中的代码 自动返回创建出来的对象 class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;var p1 = new Person(&quot;kac&quot;, 12)var p2 = new Person(&quot;awe&quot;, 20)console.log(p1, p2);// Person &#123; name: &#x27;kac&#x27;, age: 12 &#125; Person &#123; name: &#x27;awe&#x27;, age: 20 &#125; 类中的方法定义 三种定义方法 普通的实例方法：实际上是放到原型上的，可以被多个实例共享 类的访问器方法：setter，getter 类的静态方法：直接使用类来调用的方法 Person.xxx()，不需要借助实例来调用，例如Promise.all()，也是类方法 使用 static关键字来定义 var names = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;]class Person &#123; constructor(name, age) &#123; this.name = name this.age = age this._address = &quot;广州市&quot; &#125; // 1.普通的实例方法 eating() &#123; console.log(this.name + &quot; eating~&quot;); &#125; // 2.类的访问器方法（不怎么用） get address() &#123; console.log(&quot;拦截访问操作&quot;); return this._address &#125; set address(newAddress) &#123; console.log(&quot;拦截设置操作&quot;); this._address = newAddress &#125; // 3.类的静态方法（类方法）：直接通过类来访问的方法 // Person.xxx() static randomPerson() &#123; var nameIndex = Math.floor(Math.random() * names.length) var name = names[nameIndex] var age = Math.floor(Math.random() * 100) return new Person(name, age) &#125;&#125;var p = new Person(&quot;axf&quot;, 18)p.eating() // axf eating~console.log(p.address);p.address = &quot;北京市&quot;console.log(p.address);for (var i = 0; i &lt; 50; i++) &#123; console.log(Person.randomPerson());&#125; 类的继承extends ES6中新增了 extends 关键字，可以方便的帮助我们实现继承 super关键字，三个使用位置：子类的构造函数、实例方法、静态方法 子类的构造函数：JS引擎在解析子类的时候就有要求，如果我们有实现继承，那么子类的构造方法中,在使用this之前,要调用super() 否则报错 ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor 子类可以重写父类的方法，在重写方法中使用 super 来复用父类中的逻辑 class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; running() &#123; console.log(&#x27;逻辑1&#x27;); console.log(&#x27;逻辑2&#x27;); console.log(&#x27;逻辑3&#x27;); console.log(this.name + &#x27; running~&#x27;); &#125; static staticMethod() &#123; console.log(&#x27;person staticMethod&#x27;); &#125;&#125;class Student extends Person &#123; constructor(name, age, sno) &#123; // 在使用this前，这里必须使用super() super(name, age) this.sno = sno &#125; // 重写方法一般实例方法 running() &#123; // 复用父类中的逻辑 super.running() console.log(&#x27;逻辑4&#x27;); console.log(&#x27;逻辑5&#x27;); console.log(&#x27;逻辑6&#x27;); console.log(&quot;student &quot; + this.name + &quot; running&quot;); &#125; // 重写父类中的静态方法 static staticMethod() &#123; super.staticMethod() console.log(&#x27;student staticMethod&#x27;); &#125;&#125;let p = new Student(&quot;asx&quot;, 12, 111)console.log(p);// p.running()Student.staticMethod() 继承内置类 让我们的类继承内置类，比如：Array 这样我们就可以得到Array的方法了 class MyArray extends Array&#123; firstItem() &#123; return this[0] &#125; lastItem() &#123; return this[this.length - 1] &#125;&#125;var arr = new MyArray(1,2,3)console.log(arr.firstItem());console.log(arr.concat([33])) // MyArray(4) [ 1, 2, 3, 33 ] 类的混入(少用) JavaScript 的类只支持单继承，也就是只能有一个父类 如果想在一个类中添加更多相似的功能时，可以使用混入 class Person &#123;&#125;// 通过函数去继承一些公共方法function mixinRunner(BaseClass) &#123; class NewClass extends BaseClass &#123; running() &#123; console.log(&#x27;I am running~&#x27;); &#125; &#125; return NewClass&#125;function mixinEater(BaseClass) &#123; class NewClass extends BaseClass &#123; eating() &#123; console.log(&#x27;I am eating~&#x27;); &#125; &#125; return NewClass&#125;// 继承父类class Student extends Person &#123;&#125;// var NewStudent = mixinRunner(Student) // 返回一个已经继承了run方法的新的类// 在继承了run的基础上继续继承eatvar NewStudent = mixinEater(mixinRunner(Student))var stu = new NewStudent()stu.running()stu.eating() JavaScript中的多态 维基百科：多态（英语：polymorphism）指为不同数据类型的实体提供统一的接口，或使用一 个单一的符号来表示多个不同的类型 总结：不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现 所以说，JS也是有多态的，虽然跟别的一些面向对象语言有些区别 function calcArea(foo) &#123; console.log(foo.getArea());&#125;var obj1 = &#123; name: &quot;sfr&quot;, getArea: function() &#123; return 1000 &#125;&#125;class Person &#123; getArea() &#123; return 100 &#125;&#125;var p = new Person()calcArea(obj1)calcArea(p)// 以下也是多态的体现function sum(m, n) &#123; return m + n&#125;sum(20, 30) // 不同数据类型，不同形态sum(&quot;abc&quot;, &quot;asf&quot;) ES6转ES5 可以在 babeljs.io 中看es6通过babel转es5后的代码 有点难度，不要浮躁，慢慢看 可以打 debug 一点点看 例如： class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; eating() &#123; console.log(this.name + &quot; eating~&quot;) &#125;&#125;// babel转换&quot;use strict&quot;;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125;&#125;// target: Person.prototype// props: [&#123;key, value&#125;]function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125;&#125;// Constructor: Person// protoProps: [&#123;key, value&#125;]function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor;&#125;// /*#__PURE__*/ 纯函数// webpack 压缩 tree-shaking// 这个函数没副作用var Person = /*#__PURE__*/ (function () &#123; function Person(name, age) &#123; this.name = name; this.age = age; &#125; _createClass(Person, [&#123; key: &quot;eating&quot;, value: function eating() &#123; console.log(this.name + &quot; eating~&quot;); &#125; &#125;]); return Person;&#125;)();","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://hillyee.github.io/tags/ES6/"}]},{"title":"学习Vuex","slug":"学习Vuex","date":"2022-04-07T03:27:35.000Z","updated":"2022-04-07T04:34:55.638Z","comments":true,"path":"2022/04/07/学习Vuex/","link":"","permalink":"https://hillyee.github.io/2022/04/07/%E5%AD%A6%E4%B9%A0Vuex/","excerpt":"","text":"Vuex的状态管理 vuex介绍 什么是状态管理？ 应用程序的各种数据保存到某个位置进行管理 ​ state：数据 view：最终模块渲染成DOM actions：修改state的行为事件 复杂的状态管理 多个组件共享状态 Vuex的状态管理 将组件的内部状态抽离出来 Vuex使用单一状态树 SSOT：Single Source of Truth，单一数据源 每个应用仅仅包含一个store实例 安装 npm install vuex@next 使用vuex4.x，需要添加next指定版本 使用 创建store（仓库） Vuex和单纯的全局对象有什么区别呢？ Vuex的状态存储是响应式的 不能直接改变store中的状态 改变store中的状态的唯一途径就是提交(commit) mutation 这样方便我们跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态 具体步骤： store/index import &#123; createStore &#125; from &#x27;vuex&#x27;// 创建一个新的store实例const store = createStore(&#123; state() &#123; return &#123; count: 0 // 数据 &#125; &#125;, mutations: &#123; // 方法 increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;,&#125;)export default store 在全局将 store 实例作为插件安装 import store from &#x27;./store/index&#x27;createApp(App).use(store).mount(&#x27;#app&#x27;) 组件中使用store state 使用store中的state数据 在模板中使用 &lt;h2&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; 在options api 中使用 computed: &#123; counter() &#123; return this.$store.state.counter &#125;&#125; 在setup中使用 setup() &#123; const store = useStore() const counter = store.state.counter&#125; mapState 如果需要拿state中的多个数据，在可以借助辅助函数 mapState， setup中使用mapState 默认情况下，Vuex没有提供非常方便的的使用mapState的方式，所以我们进行了一个函数的封装 &lt;template&gt; &lt;div&gt; &lt;h2&gt;Home: &#123;&#123;sCounter&#125;&#125;&lt;/h2&gt; &lt;h2&gt;Home: &#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;h2&gt;Home: &#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;Home: &#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;h2&gt;Home: &#123;&#123;height&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, useStore &#125; from &quot;vuex&quot;import &#123; computed &#125; from &#x27;vue&#x27;export default &#123; // options api使用mapState computed: &#123; // fullName: function() &#123; return xxx&#125;, ...mapState([&quot;counter&quot;, &quot;name&quot;]) &#125;, setup() &#123; const store = useStore() const sCounter = computed(() =&gt; store.state.counter) // 实际上放入mapState这里拿到的是这样形式的一个个函数 // &#123;counter: function(), name: function() ...&#125; const storeStateFns = mapState([&quot;counter&quot;, &quot;name&quot;, &quot;age&quot;, &quot;height&quot;]) // 封装一个函数转化一下,主要思想是把这一个个的函数放到computed里面 // 因为computed就是传入一个函数，然后会给我们返回一个ref // &#123;counter: ref, age: ref, ...&#125; const storeState = &#123;&#125; Object.keys(storeStateFns).forEach(fnKey =&gt; &#123; // 因为内部的computed取数据的时候是通过this.$store... // 但我们这里的fn没有this, undefined.$store 是错的 // 用bind给每个函数绑定this为一个对象,里面需要有$store这个属性 // &#123;$store: store&#125; const fn = storeStateFns[fnKey].bind(&#123; $store: store&#125;) // 然后把函数一个方法computed, 以键值对的方式存储起来 storeState[fnKey] = computed(fn) &#125;) return &#123; sCounter, // 最终在这里用展开运算符展开 ...storeState &#125; &#125;&#125;&lt;/script&gt; 把函数的封装抽离到 hooks/useState.js import &#123; computed &#125; from &#x27;vue&#x27;import &#123; mapState, useStore &#125; from &#x27;vuex&#x27;export function useState(mapper) &#123; const store = useStore() // 获取到对应的对象的functions: &#123;name: function, age: function&#125; const storeStateFns = mapState(mapper) // 对数据进行转换 const storeState = &#123;&#125; Object.keys(storeStateFns).forEach(fnKey =&gt; &#123; const fn = storeStateFns[fnKey].bind(&#123; $store: store &#125;) storeState[fnKey] = computed(fn) &#125;) return storeState&#125; 我们在组件使用就会简便很多 import &#123; useState &#125; from &#x27;../hooks/useState&#x27;export default &#123; setup() &#123; const storeState = useState([&quot;counter&quot;, &quot;name&quot;, &quot;age&quot;, &quot;height&quot;]) // 当然也可以是对象形式(想要重命名的时候使用) const storeState2 = useState(&#123; sCounter: state =&gt; state.counter, sName: state =&gt; state.name &#125;) return &#123; ...storeState, ...storeState2 &#125; &#125;&#125; getters getters 的基本使用 某些属性可能需要经过变化后才使用，（就像store中的计算属性） getters 第二个参数 getters可以接收第2个参数getters，使用getters本身的属性 getters: &#123; totalPrice(state, getters) &#123; return state.books.reduce((pre, cur) =&gt; &#123; return pre + cur.count * cur.price &#125;, 0) + &quot; &quot; + getters.myName &#125;, myName(state) &#123; return state.name &#125;&#125; getters 的返回函数 getters中的函数本身，可以返回一个函数，那么在使用的地方相当于可以调用这个函数 totalPrice(state) &#123; return (price) =&gt; &#123; let totalPrice = 0 for (const book of state.books) &#123; if (book.price &lt; price) continue totalPrice += book.count * book.price &#125; return totalPrice &#125;&#125;, mapGetters 与mapState类似 在setup中使用mapGetters 封装好的 /useGetters import &#123; computed &#125; from &quot;vue&quot;;import &#123; useStore, mapGetters &#125; from &quot;vuex&quot;;export function useGetters(mapper) &#123; const store = useStore() const stateFns = mapGetters(mapper) const state = &#123;&#125; Object.keys(stateFns).forEach(fnKey =&gt; &#123; state[fnKey] = computed(stateFns[fnKey].bind(&#123; $store: store &#125;)) &#125;) return state&#125; 使用： setup() &#123; const storeGetters = useGetters([&quot;nameInfo&quot;, &quot;ageInfo&quot;, &quot;heightInfo&quot;]) return &#123; ...storeGetters &#125;&#125; 封装useMapper 我们发现前面 useState，useGetters的逻辑大部分相同，所以我们可以封装一个新的函数，根据使用的时候的 mapState还是mapGetters 来调用函数 import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useStore &#125; from &#x27;vuex&#x27;// mapFn:使用的mapXXXexport function useMapper(mapper, mapFn) &#123; const store = useStore() const storeStateFns = mapFn(mapper) const storeState = &#123;&#125; Object.keys(storeStateFns).forEach(fnKey =&gt; &#123; const fn = storeStateFns[fnKey].bind(&#123; $store: store &#125;) storeState[fnKey] = computed(fn) &#125;) return storeState&#125; Mutations 更改 Vuex 的store中的状态的唯一方法是提交mutation mutations 基本使用 在store中定义方法 mutations: &#123; increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125;&#125; 在setup中commit事件，提交的是mutations中的方法 import &#123; useStore &#125; from &quot;vuex&quot;setup() &#123; const store = useStore() store.commit(&quot;increment&quot;, xxx) // 可以传参数&#125; mutation携带数据 很多时候提交mutation会携带一些数据，在mutation中第二个参数可以接收 mutations: &#123; addNumber(state, payload) &#123; state.counter += payload &#125;&#125; payload也可以是对象类型 提交的时候：可以用type，指定提交的方法名 $store.commit(&#123; type: &quot;addNumber&quot;, count: 100&#125;) mutations: &#123; addNumber(state, payload) &#123; state.counter += payload.count &#125;&#125; mutation 常量类型 主要是预防粗心的时候，commit的方法名字和mutation定义的方法名不一致 定义常量 // mutation-types.js// 定义常量export const INCREMENT_N = &quot;INCREMENT_N&quot; store中使用 import &#123; INCREMENT_N &#125; from &#x27;../store/mutation-types&#x27;const store = createStore(&#123; state() &#123;...&#125;, mutations: &#123; [INCREMENT_N](state, payload) &#123; state.counter += payload &#125; &#125; 组件中提交事件的时候使用 import &#123; INCREMENT_N &#125; from &#x27;../store/mutation-types&#x27;export default &#123; setup() &#123; ... store.commit(INCREMENT_N, 10) &#125;&#125; mutation重要原则 mutation 必须是同步函数 这是因为devtool工具会记录mutation的日记 每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照 但是在mutation中执行异步操作，就无法追踪到数据的变化 所以Vuex的重要原则中要求 mutation必须是同步函数； mapMutations 我们也可以借助于辅助函数，帮助我们快速映射到对应的方法中 const mutations = mapMutations([&quot;increment&quot;, &quot;decrement&quot;])const mutations2 = mapMutations(&#123; addNumber: ADD_NUMBER&#125;) actions action提交mutation actions 类似于mutations，但是action提交的是mutation，而不是直接变更状态 actions 可以包含任意异步操作 actions有一个很重要的参数 context，里面有很多属性，我们用的时候除了context.xxx使用，也可以解构出来使用 从context获取commit方法来提交一个mutation actions的分发操作（触发actions中的方法） 在组件中使用store上的dispatch进行分发，并且可以传递参数 // store.jsmutations: &#123; increment(state) &#123; state.counter++ &#125;&#125;,actions: &#123; // 1. 可以接收参数 incrementAction(context, payload) &#123; console.log(payload) // payload为接收到的参数 // 模拟异步：1s之后再提交事件 setTimeout(() =&gt; &#123; context.commit(&quot;increment&quot;) // 提交mutation &#125;) &#125;, // 2. context 的属性 decrementAction(&#123; commit, dispatch, state, rootState, getters, rootGetters &#125;) &#123; commit(&quot;decrement&quot;) &#125;&#125; // 组件的setup中const increment = () =&gt; &#123; // 分发actions，并携带参数 store.dispatch(&quot;incrementAction&quot;, &#123;count: 100&#125;)&#125; 另外，也可以以对象的形式进行分发 // 组件的setup中const increment = () =&gt; &#123; store.dispatch(&#123; type: &quot;incrementAction&quot;, count: 100 &#125;)&#125; mapActions actions 也有对应的辅助函数 mapActions // 这样用不行..const actions = mapActions[&quot;incrementAction&quot;, &quot;decrementAction&quot;]// 对象写法(重命名)const actions2 = mapActions(&#123; add: &quot;incrementAction&quot;, sub: &quot;decrementAction&quot;&#125;) actions的异步操作 actions很多时候是异步的，那么当我们组件派发actions的时候，我们也想收到结果，是请求成功了还是失败了，这时候我们可以在actions对应方法中返回 Promise，并对成功失败做处理 actions: &#123; getHomeMultidata(context) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123; console.log(res); context.commit(&quot;addBannerData&quot;, res.data.data.banner.list) resolve(&quot;okok&quot;) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;&#125; onMounted(() =&gt; &#123; const promise = store.dispatch(&quot;getHomeMultidata&quot;) promise.then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;)&#125;) module module的基本使用 什么是module？ 由于使用单一状态树，应用的所有状态都集中到一个比较大的对象，当应用变得复杂时，store对象就变得相当臃肿，不利于管理 所以Vuex允许我们将store分模块 每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块 使用： 模块内部的mutation和getter的第一个参数state是模块的局部状态对象 module的命名空间 默认情况下，模块内部的action，mutation仍然是注册在全局的命名空间中的 如果希望模块具有更高的封装度和复用性，可以在模块中添加namespaced: true 使模块更独立 之后，当模块被注册后它的所有getter、action及mutation都会自动根据模块注册的路径调整命名 module修改或派发根组件 {root: true} actions: &#123; incrementAction(&#123;commit, dispatch,state&#125;) &#123; commit(&quot;rootIncrement&quot;, null, &#123;root: true&#125;) dispatch(&quot;rootIncrementAction&quot;, null, &#123;root: true&#125;) &#125;&#125; module的辅助函数 写法一：通过完整的模块空间名来查找(不是很推荐使用) computed: &#123; ...mapState(&#123; homeCounter: state =&gt; state.home.homeCounter, &#125;), ...mapGetters(&#123; doubleHomeCounter: &quot;home/doubleHomeCounter&quot;, &#125;),&#125;, 写法二：第一个参数写模块名，第二个参数写属性 computed: &#123; ...mapState(&quot;home&quot;, [&quot;homeCounter&quot;])&#125; 写法三：createNamespacedHelpers辅助函数 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数 import &#123; createNamespacedHelpers &#125; from &#x27;vuex&#x27;const &#123; mapState, mapGetters&#125; = createNamespacedHelpers(&quot;home&quot;)...mapState([&quot;homeCounter&quot;]) setup中使用 修改之前的 hooks，useState，useGetters，考虑模块的情况 import &#123; mapState, createNamespacedHelpers&#125; from &#x27;vuex&#x27;import &#123; useMapper &#125; from &#x27;./useMapper&#x27;export function useState(moduleName, mapper) &#123; let mapperFn = mapState if (typeof moduleName === &#x27;string&#x27; &amp;&amp; moduleName.length &gt; 0) &#123; mapperFn = createNamespacedHelpers(moduleName).mapState &#125; else &#123; mapper = moduleName &#125; return useMapper(mapper, mapperFn)&#125; // useGetters同理 import &#123; mapGetters, createNamespacedHelpers &#125; from &quot;vuex&quot;;import &#123; useMapper &#125; from &quot;./useMapper&quot;;export function useGetters(moduleName, mapper) &#123; let mapperFn = mapGetters if (typeof moduleName === &#x27;string&#x27; &amp;&amp; moduleName.length &gt; 0) &#123; mapperFn = createNamespacedHelpers(moduleName).mapGetters &#125; else &#123; mapper = moduleName &#125; return useMapper(mapper, mapperFn)&#125; 使用： setup() &#123; const state = useState([&quot;rootCounter&quot;]) const rootGetters = useGetters([&quot;doubleRootCounter&quot;]) const getters = useGetters(&quot;home&quot;, [&quot;doubleHomeCounter&quot;])&#125;","categories":[{"name":"深入Vue3+Typescript学习⚡","slug":"深入Vue3-Typescript学习⚡","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"},{"name":"vuex","slug":"vuex","permalink":"https://hillyee.github.io/tags/vuex/"}]},{"title":"前端人的数据结构与算法之路","slug":"前端人的数据结构与算法之路","date":"2022-04-04T09:25:17.000Z","updated":"2022-04-04T16:02:01.469Z","comments":true,"path":"2022/04/04/前端人的数据结构与算法之路/","link":"","permalink":"https://hillyee.github.io/2022/04/04/%E5%89%8D%E7%AB%AF%E4%BA%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"学习资料 [前端算法与数据结构面试：底层逻辑解读与大厂真题训练] 链接：https://juejin.cn/book/6844733800300150797 大纲：","categories":[{"name":"数据结构与算法😥","slug":"数据结构与算法😥","permalink":"https://hillyee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%F0%9F%98%A5/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"算法","permalink":"https://hillyee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"VueRouter","slug":"VueRouter","date":"2022-04-04T09:12:34.000Z","updated":"2022-04-14T06:44:41.752Z","comments":true,"path":"2022/04/04/VueRouter/","link":"","permalink":"https://hillyee.github.io/2022/04/04/VueRouter/","excerpt":"","text":"VueRouter路由使用 简单的介绍😏 这一部分了解、理解一下，知道有就行 后端路由阶段： 服务器渲染好整个页面，并且将页面返回给客户端 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化 不利于维护 前后端分离阶段： 后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中 前后端责任清晰，后端专注于数据上，前端专注于交互和可视化上 前端路由是如何做到URL和内容进行映射呢？监听URL的改变 URL的hash URL的hash也就是锚点(#), 本质上是改变window.location的href属性 我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新 (页面一旦刷新，又会向服务器发请求) &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#/home&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt; &lt;div class=&quot;content&quot;&gt;Default&lt;/div&gt;&lt;/div&gt;&lt;script&gt; const contentEl = document.querySelector(&#x27;.content&#x27;) window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123; switch(location.hash) &#123; case &quot;#/home&quot;: contentEl.innerHTML = &quot;Home&quot; break case &quot;#/about&quot;: contentEl.innerHTML = &quot;About&quot; break &#125; &#125;) hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径 HTML5的History history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面： replaceState：替换原来的路径 pushState：使用新的路径（压栈） popState：路径的回退（弹栈） go：向前或向后改变路径 go(1)前进1步，go(2)，前进两步，go(-1)，后退一步 forward：向前一步 back：后退一步 &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;/home&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;/about&quot;&gt;about&lt;/a&gt; &lt;div class=&quot;content&quot;&gt;Default&lt;/div&gt;&lt;/div&gt;&lt;script&gt; const contentEl = document.querySelector(&#x27;.content&#x27;) const changeContent = () =&gt; &#123; switch(location.pathname) &#123; case &quot;/home&quot;: contentEl.innerHTML = &quot;Home&quot; break case &quot;/about&quot;: contentEl.innerHTML = &quot;About&quot; break default: contentEl.innerHTML = &quot;Default&quot;; &#125; &#125; const aEls = document.getElementsByTagName(&quot;a&quot;) for (let aEl of aEls) &#123; aEl.addEventListener(&quot;click&quot;, e =&gt; &#123; e.preventDefault() // 阻止默认行为 const href = aEl.getAttribute(&quot;href&quot;) // history.replaceState(&#123;&#125;, &quot;&quot;, href) history.pushState(&#123;&#125;, &quot;&quot;, href) changeContent() &#125;) &#125; window.addEventListener(&quot;popstate&quot;, changeContent)&lt;/script&gt; vue-router📱 Vue Router 是 Vue.js 的官方路由，便于构建单页面应用 使用vue-router 安装 Vue Router npm install vue-router 路由的使用步骤 创建路由组件 配置路由映射、创建路由对象 import &#123; createRouter, createWebHashHistory, createWebHistory &#125; from &#x27;vue-router&#x27;import Home from &#x27;../pages/Home.vue&#x27;import About from &#x27;../pages/About.vue&#x27;// 配置映射关系const routes = [ &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, component: About &#125;]// 创建一个路由对象routerconst router = createRouter(&#123; routes, // 使用路由的模式，hash / history history: createWebHistory()&#125;)// 最后导出export default router 在全局main.js中注册路由 import router from &#x27;./router&#x27;// 注册路由vue.use(router) 使用路由：&lt;router-link&gt; &lt;router-view&gt; 这种&lt;router-link to&gt;叫 声明式导航 &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;&lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 路由重定向 对 ‘/’ 这个路径，重定向到’/home’ &#123; path: &#x27;/&#x27;, // 重定向 redirect: &#x27;/home&#x27;&#125;, 路由还有其他属性 name：给某个路由起独一无二的名字 meta：配置一些参数，被一起带到router对象中 路由懒加载 把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件 好处：提高首屏的渲染效率 实际就是webpack的分包，而Vue Router默认就支持动态来导入组件 这是因为component可以传入一个组件，也可以接收一个函数，该函数需要返回一个Promise 而import函数就是返回一个Promise 不采用直接import Home from '../pages/Home.vue'的方式 另外还可以对分包命名：/*webpackChunkName: &quot;xxx&quot;*/ &#123; path: &#x27;/home&#x27;, component: () =&gt; import(&quot;../pages/Home.vue&quot;)&#125;,&#123; path: &#x27;/about&#x27;, // 还可以对分包命名 component: () =&gt; import(/*webpackChunkName: &quot;ahout-chunk&quot; */&quot;../pages/About.vue&quot;)&#125;, 打包后的效果 router-link的属性 to：字符串（‘/home’）或者对象（配置路径+参数） replace：替代 设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push() active-class属性：可以在这个class加样式啥的 设置激活a元素后应用的class，默认是router-link-active(一般 不去修改) exact-active-class属性 链接精准激活时，应用于渲染的 的 class，默认是router-link-exact-active 在嵌套路由中，例如有一个嵌套路由是：/home/message 那么这个class只会在message那个子路由中 动态路由 动态，即这个路由的路径是动态改变的 在Vue Router中，我们可以在路径中使用一个动态字段来实现，我们称之为路径参数 &#123; path: &#x27;/user/:username/id/:id&#x27;, component: () =&gt; import(&quot;../pages/User.vue&quot;)&#125; :username? 加？表示可有可无，否则必须有 如何获取动态路由的值？ 在template中：$route.params 在created中：this.$route.params 在setup中：要使用 vue-router库给我们提供的一个hook useRoute import &#123;useRoute&#125; from &#x27;vue-router&#x27;setup() &#123; // 直接调用useRoute()，会返回一个路由对象 const route = useRoute() console.log(route); console.log(route.params); &#125; NotFound 对于那些没有匹配到的路由，我们通常会匹配到固定的某个页面 可编写一个动态路由用于匹配所有的页面 &#123; path: &#x27;/:pathMath(.*)&#x27;, // 用到正则 .*匹配任意字符0或多个 component: () =&gt; import(&quot;../pages/NotFound.vue&quot;)&#125; 可以通过$route.params.pathMath获取传入的参数 还有一种写法 &#123; path: &#x27;/:pathMath(.*)*&#x27; // 这里多加一个* component: () =&gt; import(&quot;../pages/NotFound.vue&quot;)&#125; 区别在于解析的时候，是否解析 /： 把路径中的/…/ 分成一个个的 路由的嵌套 某个路由页面本身也存在路由的来回切换 配置子路由，同样在home中使用router-link,router-view &#123; path: &#x27;/home&#x27;, component: () =&gt; import(&quot;../pages/Home.vue&quot;), children: [ &#123; path: &#x27;message&#x27;, // 这里不需要/ component: () =&gt; import(&quot;../pages/Message.vue&quot;) &#125;, &#123; path: &#x27;goods&#x27;, component: () =&gt; import(&quot;../pages/Goods.vue&quot;) &#125; ]&#125; 编程式路由 不通过router-link的方式实现跳转，比如点击的是一个按钮等 setup() &#123; // 获取router对象 const router = useRouter() const gotoMessage = () =&gt; &#123; router.push(&#x27;/home/message&#x27;) // 可以直接传字符串 &#125; const gotoGoods = () =&gt; &#123; router.push(&#123; path: &#x27;/home/goods&#x27; // 也可以是对象 &#125;) &#125;&#125; 另外还有 router.replace、router.go、back、forward vue2中：this.$router.push query(查询)方式的参数 传递query参数： router.push(&#123; path: &#x27;/home/goods&#x27;, query:&#123; name: &#x27;hello&#x27;, age: 18 &#125;&#125;) 在对应页面中获取query参数： &lt;h2&gt;&#123;&#123;$route.query.name&#125;&#125;---&#123;&#123;$route.query.age&#125;&#125;&lt;/h2&gt; router-link的v-slot 用到查文档就好 &lt;!-- v-slot可以拿到router-link给我们传递过来的属性(可以自己命名 props)custom:表示自定义router-link，外部不会给我们包裹a元素了props.navigate：所以当我们想点击某个元素跳转的时候可以使用navigate(当然用编程式导航也是可以的)props.route：路由对象props.href: 解析后的urlprops: isActive 是否当前处于活跃的状态 (true,false)props: isExactActive 是否当前处于精确的活跃状态 --&gt;&lt;router-link to=&quot;/home&quot; v-slot=&quot;props&quot; custom&gt; &lt;button&gt;首页&lt;/button&gt; &lt;p&gt;href: &#123;&#123;props.href&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;props.navigate&quot;&gt;跳转home&lt;/button&gt; &lt;p&gt;&#123;&#123;props.route&#125;&#125;&lt;/p&gt; &lt;span :class=&quot;&#123;&#x27;active&#x27;: props.isActive&#125;&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;&#123;&#x27;active&#x27;: props.isActive&#125;&quot;&gt;&#123;&#123;props.isExactActive&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; router-view的v-slot router-view也提供给我们一个插槽，可以用于&lt;transition&gt;和&lt;keep-alive&gt;组件来包裹你的路由组件（用于加动画，缓存） Component：要渲染的组件 route：解析出的标准化路由对象 &lt;router-view v-slot=&quot;props&quot;&gt; &lt;transition name=&quot;abc&quot;&gt; &lt;!-- 可以拿到router-view给我们传过来的组件 --&gt; &lt;keep-alive&gt; &lt;component :is=&quot;props.Component&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/transition&gt;&lt;/router-view&gt; 动态添加路由 比如说我们要根据不同的权限来决定是否添加路由 路由对象router上有方法：addRoute()动态添加路由 // 定义要添加的动态路由（可以先定义const momentRoute = &#123; path: &#x27;/moment&#x27;, component: () =&gt; import(&quot;../pages/HomeMoment.vue&quot;)&#125;router.addRoute(momentRoute)// 也可以添加的时候作为addRoute的第二个参数）// 给home动态添加子路由cart 路径:/home/cartrouter.addRoute(&#x27;home&#x27;, &#123; path: &#x27;cart&#x27;, component: () =&gt; import(&quot;../pages/Cart.vue&quot;)&#125;) 动态删除路由 三种方式： 添加一个同名路由，相当于覆盖 通过removeRoute方法，传入路由的名称 通过addRoute方法的返回值回调 router.addRoute(&#123;path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: About&#125;)// 方式1router.addRoute(&#123;path: &#x27;/other&#x27;, name: &#x27;about&#x27;, component: Other&#125;)// 方式2router.removeRoute(&#x27;about&#x27;)// 方式3const removeRoute = router.addRoute(&#123;path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: About&#125;)removeRoute() 路由其他方法补充 router.hasRoute()：检查路由是否存在。 router.getRoutes()：获取一个包含所有路由记录的数组 路由导航守卫👮 vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航 全局前置守卫beforeEach 在导航触发时会被回调 它有两个参数： to：即将进入的路由对象 from：即将离开的Route对象 返回值： false：取消当前导航 不返回或者返回undefined：进行默认导航 返回一个路由地址： 路径字符串：‘/home’ 对象：类似于 router.push({path: “/login”, query: …}) 小案例：如果没登录就跳转到登录页面 router.beforeEach((to, from) =&gt; &#123; if (to.path !== &#x27;/login&#x27;) &#123; const token = window.localStorage.getItem(&#x27;token&#x27;) if(!token) &#123; return &quot;/login&quot; &#125; &#125;&#125;) 更多导航守卫看官网 https://router.vuejs.org/zh/guide/advanced/navigation-guards.html 完整的导航解析流程 其他补充 historyApiFallback 开发中一个非常常见的属性，主要作用是解决SPA页面在路由跳转之后，进行页面刷新时，返回404的错误 如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容 因为我们使用的是前端路由，刷新页面时访问的资源在服务端找不到，因为vue-router设置的路径不是真实存在的路径。 注：我们使用 vue-cli的时候，默认已经帮我们设置为true了 module.exports = &#123; //... devServer: &#123; historyApiFallback: true, &#125;&#125;; https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback","categories":[{"name":"深入Vue3+Typescript学习⚡","slug":"深入Vue3-Typescript学习⚡","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"}],"tags":[{"name":"vue路由","slug":"vue路由","permalink":"https://hillyee.github.io/tags/vue%E8%B7%AF%E7%94%B1/"}]},{"title":"随笔✍","slug":"随笔","date":"2022-04-03T04:57:12.000Z","updated":"2022-04-04T16:06:41.551Z","comments":true,"path":"2022/04/03/随笔/","link":"","permalink":"https://hillyee.github.io/2022/04/03/%E9%9A%8F%E7%AC%94/","excerpt":"","text":"待完善…","categories":[{"name":"其他","slug":"其他","permalink":"https://hillyee.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"关于JS数据类型","slug":"关于JS数据类型","date":"2022-04-03T03:09:28.000Z","updated":"2022-04-03T04:32:34.281Z","comments":true,"path":"2022/04/03/关于JS数据类型/","link":"","permalink":"https://hillyee.github.io/2022/04/03/%E5%85%B3%E4%BA%8EJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"JS 数据类型转换 类型转换可以分为两种：隐式类型转换 和 显式类型转换 显式：比如 Number(value) String(value) … 隐式：对不同类型的值使用运算符时，值可以自动转换，比如 1 == null 我们需要知道：在 JS 中只有3中类型的转换：转换为 Number，String，Boolean类型 所以我们只需要弄清楚在什么场景下应该转成哪种类型就可以了 转换为boolean 显式：Boolean() 方法可以直接用来将值转换成布尔型 Boolean(2) // true 隐式：通常在逻辑判断或者有逻辑运算符时被触发 if(2) &#123;&#125; // 逻辑判断!!2 // 逻辑运算2 || &#x27;hello&#x27; // 逻辑运算let x = &#x27;hello&#x27; &amp;&amp; 123 // x === 123// 逻辑运算符（比如 || 和 &amp;&amp;）是在内部做了 boolean 类型转换，但实际上返回的是原始操作数的值 boolean类型转换只有 true，false两种结果。 除了 0、NaN、空字符串、null、undefined五个值是false，其余都是true 额外补充： 逻辑或 ||：一真为真，a || b，只要a为真就返回a的执行结果，b不执行；a为假则执行b，并返回b执行后的结果 逻辑与 &amp;&amp;：一假为假，a &amp;&amp; b，只要a为假就返回a的执行结果，b不执行；a为真则执行b，并返回b执行后的结果 转换为为string 显式：String() 方法可以用来显式将值转为字符串。 String([1,2,3]) // &quot;1,2,3&quot;String(&#123;&#125;) // &#x27;[object Object]&#x27;String(true) // &#x27;true&#x27; 隐式：隐式转换通常在有 + 运算符并且只是至少有一个操作数是 string 类型时被触发，即字符串拼接 1 + &#x27;123&#x27; //&quot;1123&quot; 1 + &#123;&#125; // &#x27;1[object Object]&#x27;&#x27;1&#x27; + null // &#x27;1null&#x27; 把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型] null 与字符串拼接时null直接转为 ‘null’ (内部的实现) 转换为number 显式：Number()方法可以用来显式将值转换成数字类型 字符串转换为数字：空字符串变为0，如果出现任何一个非有效数字字符，结果都是NaN Number(&quot;&quot;) //0Number(&quot;10px&quot;) //NaNNumber(&quot;10&quot;) //10 布尔转换为数字 Number(true) // 1Number(false) // 0 null 和 undefined 转换成数字 Number(null) // 0Number(undefined) // NaN Symbol无法转换为数字 Number(Symbol()) // Cannot convert a Symbol value to a number BigInt Number(BigInt(10)) // 10Number(10n) // 10 BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。BigInt 可以表示任意大的整数。 可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()（但不包含 new 运算符）并传递一个整数值或字符串值,如BigInt(10) 对象转换为数字，会按照下面的步骤执行 先调用对象的 Symbol.toPrimitive 这个方法，如果不存在这个方法 MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive 再调用对象的 valueOf() 获取原始值，如果获取的值依然不是数字 valueOf() 方法返回指定对象的原始值。 再调用对象的 toString() 把其变为字符串 把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型] 最后再把字符串基于Number()方法转换为数字 let obj = &#123; name:&#x27;xxx&#x27;&#125;console.log(obj-10) // 数学运算：先把obj隐式转换为数字，再进行运算//运行机制obj[Symbol.toPrimitive] //undifined obj.valueof() // &#123;name:xxx&#125;obj.toString() // &#x27;[object Object]&#x27;Number (&quot;[object object]&quot;) // NaNNaN-10 // NaN 隐式 number 的隐式类型转换是比较复杂的，因为它可以在下面多种情况下被触发 比较操作（&gt;, &lt;, &lt;=, &gt;=） 按位操作（| &amp; ^ ~） 算数操作（- + * / %）， 注意：当 +存在任意的操作数是 string 类型时，转换到string类型为止，不会触发 number 类型的隐式转换 一元 + 操作 一元就是只有一个操作数，+5 +[] +[] --&gt; 0 相当于Number([]) +{} --&gt; NaN 相当于String({})=‘[object,Object]’；Number(‘[object,Object]’) --&gt;NaN 需要注意的情况 javascript中加法会触发3种类型转换，即将值转换为原始值，转换为字符串，转换为数字。这刚好对应了javascript引擎内部的转换操作：ToPrimitive(),toString(),toNumber() &#123;&#125; + [] === 0 // true[] + &#123;&#125; === 0 // false// &#123;&#125; + []，对于编译器来说,&#123;&#125;在开头，被解析成代码块，不会返回任何值// 所以&#123;&#125; + []实际上就是 +[]// []通过ToPrimitive(),toString() 变成 &quot;&quot;// 最后 toNumber() --&gt; 0[] + &#123;&#125; // 这里&#123;&#125;就是一个对象// String([])=&#x27;&#x27; String(&#123;&#125;)=&#x27;[object Object]&#x27; // 有string类型不会触发number转换了,两边都是string直接拼接// 所以 &#x27;&#x27; + &#x27;[object Object]&#x27; --&gt; &#x27;[object Object]&#x27; 操作符 == 两边的隐式转换 如果两边的数据类型不同，需要先转为相同类型再进行比较 对象 == 字符串 [1,2,3] == &#x27;1,2,3&#x27; // true// 转为字符串// [1,2,3].toString() --&gt; &#x27;1,2,3&#x27;&#123;name:&#x27;helo&#x27;&#125; == &quot;&#123;name:&#x27;helo&#x27;&#125;&quot; // false// &#123;name:&#x27;helo&#x27;&#125;.valueOf().toString() --&gt; &#x27;[object Object]&#x27; null/ undefined null == undefined // truenull === undefined // false//null/undefined和其他任何值都不相等 对象 == 对象 &#123;&#125; == &#123;&#125; // false 比较的是堆内存地址，地址相同才相等 NaN NaN == xxx 都是false 除了以上的四种情况，只要两边类型不一致，都是转换为数字再进行比较 最后，看题： let result = 100 + true + 21.2 + null + undefined + &quot;Tencent&quot; + [] + null + 9 + false 参考资料： https://juejin.cn/post/6956170676327677966 数据类型的判断 https://juejin.cn/post/7061588533214969892#heading-29 把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型] Object.prototype.toString.call() 有显式绑定， 因此 Object.prototype.toString.call(xxx)就是 找到xxx中的toString方法，输出的对象的类型就是根据xxx来的 神奇的加法 https://blog.csdn.net/dk2290/article/details/86534595","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"08_JS面向对象","slug":"08-JS面向对象","date":"2022-04-02T08:37:13.000Z","updated":"2022-04-10T05:51:04.487Z","comments":true,"path":"2022/04/02/08-JS面向对象/","link":"","permalink":"https://hillyee.github.io/2022/04/02/08-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"深入JS面向对象 面向对象初识 创建对象的方式 // 方式一：通过new Object()创建var obj = new Object()obj.name = &quot;hill&quot;obj.age = 18obj.running = function() &#123; console.log(this.name + &quot; is running&quot;);&#125;// 方式二：字面量形式var info = &#123; name: &#x27;hill&#x27;, age: 18, eating: function() &#123; console.log(this.name + &#x27;is&#x27; + this.age); &#125;&#125; 对属性的操作 var obj = &#123; name: &quot;yuzi&quot;, age: 18&#125;// 1.获取属性console.log(obj.name); // yuzi// 2.给属性赋值obj.name = &quot;jackson&quot;console.log(obj.name); // jackson// 3.删除属性// delete obj.name// console.log(obj); // &#123;age: 18&#125;// 4.遍历属性for (var key in obj) &#123; console.log(key); // name age&#125; 这种直接定义在对象内部或者直接添加到对象内部的属性，我们不能对其做出限制：比如这个属性是否可以通过delete删除，是否可以在for-in遍历的时候被遍历出来 Object.defineProperty() 如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符 通过属性描述符可以精准的添加或修改对象的属性 属性描述符需要使用 Object.defineProperty 来对属性进行添加或修改 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象 接收三个参数 obj:要定义属性的对象 prop: 要定义或修改的属性的名称或Symbol descriptor：要定义或修改的属性描述符 第三个参数的属性描述符分为两类： 数据属性描述符 configurable，enumerable，writable，value // 直接在一个对象上定义某个属性时，描述符的默认值为// value: 赋值的value// configurable: true// enumerable: true// writable: truevar obj = &#123; name: &#x27;jackson&#x27;, age: 18&#125;Object.defineProperty(obj, &quot;height&quot;, &#123; value: 1.88, // 属性值(默认为 undefined) enumerable: true, // 对应属性是否可以枚举(默认为false) writable: true, // 是否可以修改属性值(默认为false) configurable: true, // 属性能否被删除(默认为false),属性的描述符能否被改变&#125;)// 枚举for(var key in obj) &#123; console.log(key); // name age height 可枚举&#125;console.log(Object.keys(obj)); // [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;height&#x27; ] 可枚举// 修改属性值obj.height = 2console.log(obj.height); // 2 可修改// 删除属性delete obj.heightconsole.log(obj.height); // undefined 删除成功 存取属性描述符 enumerable，configurable，get，set 不用value,writable，而是用 get,set var obj = &#123; name: &#x27;jackson&#x27;, age: 18, _address: &quot;广东&quot; &#125;// 私有属性，js里面是没有严格意义的私有属性的，所以我们实际上也能直接访问，但是在社区人们约定 下划线_开头的属性定义为私有属性// 1.隐藏某一个私有属性(address)不希望直接被外界使用和赋值// 2.如果我们希望截获某个属性被访问和设置值的过程时，也会使用存储属性描述符Object.defineProperty(obj, &quot;address&quot;, &#123; enumerable: true, // 可枚举 configurable: true, // 可删除，可修改描述符 get: function() &#123; console.log(&quot;获取了一次address的值&quot;) return this._address &#125;, set: function(value) &#123; console.log(&quot;设置了address的值&quot;) this._address = value &#125;&#125;)console.log(obj.address); // 广东 可枚举属性的补充 var obj = &#123; name: &quot;why&quot;, age: 18&#125;Object.defineProperty(obj, &quot;address&quot;, &#123; value: &quot;北京市&quot;&#125;)console.log(obj)// address属性默认是不可枚举的，但是我们在浏览器上面是可以看到的（稍微浅色一点），这是浏览器为了方便我们调试做的处理 Object.defineProperties() Object.defineProperties() 方法可以直接在一个对象上定义多个新的属性 var obj = &#123; _age: 18&#125;Object.defineProperties(obj, &#123; name: &#123; writable: true, value: &#x27;jackson&#x27; &#125;, age: &#123; get: function() &#123; return this._age &#125; &#125;&#125;) 对象方法补充(了解) 获取对象的属性描述符 getOwnPropertyDescriptor getOwnPropertyDescriptors 禁止对象扩展新属性 preventExtensions：给一个对象添加新的属性会失败(在严格模式下会报错) 密封对象，不允许配置和删除属性：seal 实际是调用preventExtensions 并且将现有属性的configurable:false 冻结对象，不允许修改现有属性：freeze 实际上是调用seal 并且将现有属性的writable: false 创建多个对象的方式 通过想要创建多个对象的目的，来引出后面的构造函数 前面我们通过 new Object，字面量的方式创建对象，但是这两种方式有一个很大的弊端： 创建同样的对象时，需要编写重复代码 比如说字面量： var p1 = &#123;name: , age: &#125;var p2 = &#123;name: , age: &#125;var p3 = &#123;name: , age: &#125; // 它们有同样的属性或者方法 创建对象的方式 - 工厂模式 工厂模式其实是一种常见的设计模式 通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象 工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型 但是从某些角度来说，这些对象应该有一个他们共同的类型 function createPerson(name, age, height) &#123; var p = &#123;&#125; // 定义一个对象 p.name = name p.age = age p.height = height p.eating = function() &#123; console.log(this.name + &quot;is eating&quot;); &#125; return p // 把对象返回&#125;var p1 = createPerson(&quot;张三&quot;, 18, 1.88)var p2 = createPerson(&quot;李四&quot;, 20, 1.98)var p3 = createPerson(&quot;王五&quot;, 30, 1.78)// 工厂模式的缺点：获取不到对象最真实的类型console.log(p1, p2, p3); // 我只知道你是一个对象，但我不知道你是person类型 认识构造函数 什么是构造函数？ 构造函数也称之为构造器（constructor），通常我们在创建对象时会调用的函数 JavaScript 中，如果一个普通的函数被使用 new 操作符来调用了，那么这个函数就称之为是一个构造函数 所以说构造函数也是一个普通函数，只不过用 new 去调用，就称为构造函数 new也是可以调用函数的喔 new操作符 如果一个函数被使用new操作符调用了，那么它会执行如下操作： 在内存中创建一个新的对象（空对象） 这个对象内部的 **[[prototype]]**属性会被赋值为该构造函数的 prototype属性 构造函数的 this ，会指向创建出来的新对象 执行函数的内部代码 如果构造函数没有返回非空对象，则返回创建出来的新对象 构造函数创建对象 // 规范：构造函数的首字母一般是大写function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address this.eating = function() &#123; console.log(this.name + &quot;is eating&quot;); &#125; this.running = function() &#123; console.log(this.name + &#x27;is running&#x27;); &#125;&#125;var p1 = new Person(&quot;张三&quot;, 18, 1.88, &#x27;广州&#x27;)var p2 = new Person(&quot;李四&quot;, 20, 1.78, &#x27;北京&#x27;)console.log(p1); // Person &#123;...&#125; 是可以看见类型的console.log(p2); 这个构造函数可以确保我们的对象是有Person的类型的 但是也有缺点：我们需要给每个对象的函数去创建一个函数对象实例（开辟新的内存空间） 对象的原型 [[prototype]] JavaScript 中，每个对象都有一个特殊的内置属性 [[prototype]]，这个属性称之为对象的原型（隐式原型）（只要是对象，就会有这个内置属性） [[prototype]] 指向一个对象（也就是说它也是一个对象） 那么这个对象有什么用呢？ 当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作 这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它 如果对象中没有该属性， 那么会沿着它的原型去查找 [[prototype]] 如果通过字面量直接创建一个对象，那么这个对象也有[[prototype]]这个属性 如何查看这个属性呢 var obj = &#123; name: &quot;jackson&quot;&#125;var info = &#123;&#125;// 创建出来的对象上都有 [[prototype]]属性// 如何查看这个属性？// 早期的ECMA是没有规范如何去查看 [[prototype]]// 给对象中提供了一个属性 __proto__, 可以让我们查看一下这个原型对象(浏览器提供)console.log(obj.__proto__);// [Object: null prototype] &#123;&#125;// 相当于(伪代码)var obj = &#123;name: &#x27;jackson&#x27;, __proto__: &#123;&#125;&#125;// ES5之后提供的Object.getPrototypeOf()查看console.log(Object.getPrototypeOf(obj)); // &#123;&#125;// 例如找 age 这个属性，该对象本身没有，沿着原型查找obj.__proto__.age = 18console.log(obj.age); // 18 函数的原型 prototype 所有的函数都有一个 prototype 属性（显式原型） function Foo() &#123;&#125;// 函数也是一个对象，所以它也是有[[prototype]]隐式属性// 另外，函数还会多出来一个显式原型属性：prototypeconsole.log(Foo.prototype); 再看回new操作符其中的一个步骤： 这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性 也就意味着我们通过 Foo 构造函数创建出的所有对象的 [[prototype]] 都指向 Foo.prototype var f1 = new Foo()var f2 = new Foo()console.log(f1.__proto__ === Foo.prototype); // trueconsole.log(f2.__proto__ === Foo.prototype); // true 创建对象的内存表现 可以看到： 构造函数的 prototype 属性指向该函数的原型对象 原型对象身上有一个 constructor 属性指回构造函数本身 new出来的实例对象 p1，p2 对象身上有 __proto__属性也指向构造函数的原型对象 函数原型上的属性constructor 默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象 function Foo() &#123;&#125;// 1. constructor属性// Foo.prototype这个对象中有一个constructor属性console.log(Foo.prototype); // &#123;&#125; 为什么没看到constructor？// 那换一种方式看console.log(Object.getOwnPropertyDescriptors(Foo.prototype));//打印 // &#123;// constructor: &#123;// value: [Function: Foo],// writable: true, // enumerable: false,// configurable: true// &#125;// &#125;// 可以看到enumerable为false，所以第一种方式不能看到constructor// 既然这样，我们能不能重写这个对象的属性constructor呢？肯定可以呀Object.defineProperty(Foo.prototype, &quot;constructor&quot;, &#123; enumerable: true, //可枚举 configurable: true, // 可删除，描述符可修改 writable: true, // 可写 value: &#x27;hahahha&#x27;&#125;)// 这个时候我们再来直接打印，就可以看到constructor了(被我们改成可枚举了)console.log(Foo.prototype);// &#123; constructor: &#x27;hahahha&#x27; &#125; 我们也可以在prototype上添加自己的属性 Foo.prototype.name = &quot;jackson&quot;Foo.prototype.age = 18Foo.prototype.eating = function() &#123;&#125;// 我们再new对象的时候，这些属性都可以通过实例的原型__proto__找到var f1 = new Foo()console.log(f1.name); // jacksonconsole.log(f1.__proto__); // 打印// &#123;// constructor: &#x27;hahahha&#x27;,// name: &#x27;jackson&#x27;,// age: 18,// eating: [Function (anonymous)]// &#125; 直接修改整个prototype对象（赋值，新开内存空间） Foo.prototype = &#123; constructor: Foo, // 让它指回本身(但这样它默认是可枚举的) name: &quot;jackson&quot;, age: 20&#125;var f1 = new Foo()console.log(f1.name); // &quot;jackson&quot;// 为了可以自定属性描述符,真实开发中我们可以通过Object.defineProperty添加constructorObject.defineProperty(Foo.prototype, &quot;constructor&quot;, &#123; enumerable: false, configurable: true, writable: true, value: Foo&#125;) 原来的foo函数的原型对象因为没有对它的引用，会被回收的 创建对象的方式 — 构造函数和原型组合 function Person(name, age, address) &#123; this.name = name this.age = age this.address = address // this.fn = function() // 为了不给每个实例都新开内存空间保存相同的方法，我们不把共同的方法定义在这&#125;// 我们可以把一些公共的方法直接通过原型对象添加Person.prototype.eating = function() &#123; console.log(this.name + &#x27;is eating&#x27;); // 这里的this怎么找到实例对象的？ // 调用函数的时候隐式绑定啊&#125;Person.prototype.running = function() &#123; console.log(this.name + &#x27;is running&#x27;);&#125;var p1 = new Person(&quot;jackson&quot;, 18, &quot;guangdong&quot;)var p2 = new Person(&quot;yuzi&quot;, 18, &quot;beijing&quot;)p1.eating()p2.eating() JavaScript中的类和对象 function Person() &#123;&#125; 在 JS 中，Person应该被称之为是一个构造函数 但是从很多面向对象语言的开发者习惯称之为类，因为类可以帮我们创建出来实例对象，也是可以的 面向对象的特性 - 继承 面向对象有三大特性：封装、继承、多态 封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程 继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中） 多态：不同的对象在执行时表现出不同的形态 JavaScript原型链 原型链的理解 var obj = &#123; name: &quot;jackson&quot;, age: 18&#125;// 当我们&quot;.&quot;的时候就是[[get]]操作// 1.在当前的对象中查找属性// 2.如果没有找到，这个时候会去原型链(__proto__)对象上查找obj.__proto__ = &#123; // address: &quot;广州市&quot;&#125;// 原型链obj.__proto__.__proto__= &#123; // address: &quot;广州市&quot;&#125;obj.__proto__.__proto__.__proto__= &#123; address: &quot;广州市&quot;&#125;console.log(obj.address); // &quot;广州市&quot;// 只要在原型链上都可以找到的 这样一直向上找的话，那么顶层原型究竟是什么呢？ var obj = &#123;name: &quot;Jackson&quot;&#125;// 找到那一层对象之后会停止继续查找呢？console.log(obj.__proto__); // 可以看到字面量obj的原型是 [Object: null prototype] &#123;&#125;// 我们继续往上看看console.log(obj.__proto__.__proto__); // null// 所以我们可以说 [Object: null prototype] &#123;&#125; 就是顶层的原型 顶层对象有什么特别吗？该对象上有很多默认的属性和方法 顶层原型又来自哪里呢？下面我们创建Object对象看看 // 创建一个对象(这种方式相当于下面一种方式的语法糖，本质都是创建一个对象)var obj1 = &#123;&#125; var obj2 = new Object() // 创建了一个对象// 创建对象的话，其中有一步是：将Object函数的显式原型prototype赋值给实例的隐式原型// 相当于这里// Object.prototype = obj2.__proto__// 因此（我们知道这里obj1/2.__proto__已经是到顶层了）console.log(Object.prototype === obj1.__proto__); // trueconsole.log(Object.prototype === obj2.__proto__); // true// Object.prototype也是一个对象，那么它应该也有 __proto__console.log(Object.prototype.__proto__); // null// 因此Object.prototype指向的已经是顶层原型了console.log(Object.getOwnPropertyDescriptors(Object.prototype)) // 有constructor,toString等属性和方法 因此，原型链最顶层的原型对象就是Object的原型对象 也就是说，Object是所有类的父类 function Person(name) &#123; this.name = name&#125;// 看看构造函数Person的原型console.log(Person.prototype);// &#123;&#125; 看不到！应该是不可枚举吧console.log(Object.getOwnPropertyDescriptors(Person.prototype));//输出 &#123;constructor: &#123;...&#125;&#125;console.log(Person.prototype.__proto__);//[Object: null prototype] &#123;&#125; 通过原型链实现继承 为什么需要有继承？ 如果没有继承，我们想创建多个类，类里面的属性和方法很多是一样的，那么我们就会写很多重复的代码，所以主要是为了代码的复用 // Studentfunction Student(name, age, sno) &#123; this.name = name this.age = age this.sno = sno&#125;Student.prototype.running = function() &#123;&#125;// Teacherfunction Teacher(name, age, title) &#123; this.name = name this.age = age this.title = title&#125;Teacher.prototype.running = function() &#123;&#125; 原型链的继承方案 自己画画图更好理解 // 父类：公共属性和方法function Person() &#123; this.name = &quot;Jackson&quot;, this.friends = []&#125;Person.prototype.eating = function() &#123; console.log(this.name + &quot;is eating&quot;);&#125;// 子类：特有属性和方法function Student() &#123; this.sno = 111&#125;// new一个personvar p = new Person()Student.prototype = p var stu = new Student()// console.log(stu.sno); // 111// console.log(stu.name);// Jackson// stu.eating()// 原型链实现继承的弊端：// 1.打印stu对象，继承的属性是不能直观看到的// console.log(stu); // Person &#123; sno: 111 &#125;// 前面显示的 Person 类型,实际上是实例的name属性，显然这里应该是Student// 2.创建出来两个stu对象var stu1 = new Student()var stu2 = new Student()// 获取引用，修改引用中的值，会相互影响// 因为这个fre1被加到p对象，而stu1,stu2的__proto__都指向pstu1.friends.push(&quot;fre1&quot;)console.log(stu1.friends); // [ &#x27;fre1&#x27; ]console.log(stu2.friends); // [ &#x27;fre1&#x27; ]// 3. 在前面实现类的过程中都没有传递参数var stu3 = new Student(&quot;jeccy&quot;, 112)// 直接在function Student(name,age)&#123;this.name = name this.age = age&#125;？// 肯定不行啊，我们是想要把name的处理放在Person的 借用构造函数实现继承 使用call调用构造函数， // 父类：公共属性和方法function Person(name, age, friends) &#123; this.name = name, this.age = age this.friends = friends&#125;Person.prototype.eating = function() &#123; console.log(this.name + &quot;is eating&quot;);&#125;// 子类：特有属性和方法function Student(name, age, friends, sno) &#123; // 我们在这里调用Person,并把需要Person处理的参数传过去 // this 就是Student的实例 Person.call(this, name, age, friends) // 这里可以获得父类的属性 this.sno = sno&#125;// new一个personvar p = new Person() // 依然需要这里来获得方法Student.prototype = p // 解决弊端3var stu1 = new Student(&quot;aaa&quot;, 18, [&#x27;fred1&#x27;], 111)console.log(stu1); // Person &#123; name: &#x27;aaa&#x27;, age: 18, friends: [ &#x27;fred1&#x27; ], sno: 111 &#125; 解决弊端1var stu2 = new Student(&quot;vvv&quot;, 20, [&#x27;fred2&#x27;], 112)stu1.friends.push(&quot;hahaha&quot;)console.log(stu1.friends); // [ &#x27;fred2&#x27; ]console.log(stu2.friends); // [ &#x27;fred1&#x27;, &#x27;hahaha&#x27; ]// 解决弊端2 但是这种方法依然存在弊端： Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person） stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的） 注意： 那么我们换一种获得父类方法的方法，直接将父类原型赋值给子类？ 肯定是不行的，因为以后给某个子类添加方法的时候，会使所有的子类都有该方法，显然是不行的 因为所有子类的prototype都指向同一个父类的原型 原型式继承函数 - 对象 我们先实现对象的继承，后面再扩展到类 var obj = &#123; name: &quot;Jackson&quot;, age: 18&#125;// 原型式继承函数// 这个函数要做到的是，你给我传入的对象，作为新对象的原型function createObject(o) &#123; var newObj = &#123;&#125; // 这个方法是把o设置为newObj的原型 Object.setPrototypeOf(newObj, o) return newObj&#125;// Douglas 的实现(当时还没有setPrototypeOf这个方法)function createObject2(o) &#123; function Fn() &#123;&#125; Fn.prototype = o var newObj = new Fn() // 因此 newObj.__proto__ = Fn.prototype = o return newObj&#125;// 现在，我们想要新建的对象info的原型指向obj（后面扩展到类）// var info = createObject(obj)// 但是 新的ECMA 给我们提供了新的方法：Object.create(obj)// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__// 实际上这个方法跟我们上面的两种实现方法实现的功能是一样的var info = Object.create(obj)console.log(info);// 已经实现了我们的目的console.log(info.__proto__); // &#123; name: &#x27;Jackson&#x27;, age: 18 &#125; Object.create() ：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create 寄生式继承函数（了解） 寄生式继承的思路是结合原型类继承和工厂模式的一种方式 即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回 var personObj = &#123; running: function() &#123; console.log(&#x27;running&#x27;); &#125;&#125;// 目的：继承 personObj里面的方法function createStudent(name) &#123; var stu = Object.create(personObj) stu.name = name stu.studying = function() &#123; console.log(&quot;studying&quot;); &#125; return stu&#125;var stuObj = createStudent(&quot;why&quot;) 寄生组合式继承(最终方案) 利用寄生式继承将组合式继承的两个问题解决 首先我们需要明确，当我们在子类的构造函数中调用父类.call(this，参数)的时候，就会将父类的属性和方法复制一份到子类中，所以父类本身里面的内容我们是不需要的 然后，我们还需要获取到一份父类的原型对象中的属性和方法 // 如果不想使用Object.create这个方法的话，我们可以定义前面说过的方法function createObject(o) &#123; function Fn() &#123;&#125; Fn.prototype = o return new Fn()&#125;function inheritPrototype(SubType, SuperType) &#123; // SubType.prototype = Object.create(SuperType.prototype) SubType.prototype = createObject(SuperType.prototype) // 当然子类的prototype还需要有constructor指向子构造函数本身 Object.defineProperty(SubType.prototype, &quot;constructor&quot;, &#123; enumerable: false, configurable: true, writable: true, value: SubType &#125;)&#125;// 父类function Person(name, age, friends) &#123; this.name = name this.age = age this.friends = friends&#125;Person.prototype.running = function() &#123; console.log(&quot;running~&quot;)&#125;// 子类function Student(name, age, friends, sno) &#123; Person.call(this, name, age, friends) // 获取一份Person中的属性和方法 this.sno = sno&#125;// Student类还需要获取一份父类的prototype的属性和方法inheritPrototype(Student, Person)var stu = new Student(&quot;why&quot;, 18, [&quot;kobe&quot;], 111)console.log(stu); // 打印 Student &#123; name: &#x27;why&#x27;,age: 18,friends: [ &#x27;kobe&#x27; ],sno: 111,&#125; JS原型的补充 hasOwnProperty 判断对象是否有某个属于自己的属性，不包括在原型上的 in/ for in 操作符 判断某个属性是否在某个对象或者对象的原型上 var obj = &#123; name: &#x27;jackson&#x27;, age: 18&#125;// 第二个参数是info添加属于自己的属性var info = Object.create(obj, &#123; address: &#123; value: &quot;北京&quot;, enumerable: true &#125;&#125;)// hasOwnPropertyconsole.log(info.hasOwnProperty(&quot;address&quot;)); // trueconsole.log(info.hasOwnProperty(&quot;name&quot;)); // false// in 操作符: 不管在当前对象还是原型中返回的都是trueconsole.log(&quot;address&quot; in info); // trueconsole.log(&quot;name&quot; in info); // true// for in (包括原型上的属性都可以遍历到)for(var key in info) &#123; console.log(key); // address name age&#125; instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 function Person() &#123;&#125;function Student() &#123;&#125;// 使用前面的寄生组合式继承inheritPrototype(Student, Person)console.log(Person.prototype.__proto__); // [Object: null prototype] &#123;&#125;var stu = new Student()// stu是否出现在构造函数 Student 的原型链上console.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // trueconsole.log(stu instanceof Object); // true isPrototypeOf(了解) 用于检测某个对象，是否出现在某个实例对象的原型链上 var info = Object.create(obj)// obj是否出现在info的原型链上console.log(obj.isPrototypeOf(info)) 对象-函数-原型之间的关系 var obj = &#123; name: &quot;jackson&quot;&#125;// 只要是对象，里面就会有一个__proto__对象（隐式原型对象）console.log(obj.__proto__);// [Object: null prototype] &#123;&#125;function Foo() &#123;&#125;// 所有的 function xx() &#123;&#125;// 我们都可以认为 xx 是 new Function 创建出来的// 相当于 var xxx = new Function// 只要是函数，那么它就会有一个显式原型对象：Foo.prototype// 那 Foo.prototype 这个对象又来自哪里呢？// 创建函数的时候，JS内部就会创建一个对象,并添加到函数的prototype属性中：Foo.prototype = &#123;constructor: Foo&#125;// Foo也是一个对象，只要是对象，就会有隐式原型对象 Foo.__proto__// Foo.__proto__来自哪里？// var Foo = new Function() console.log(Foo.__proto__ === Function.prototype); // true// 而 Function.prototype对象是我们创建Function函数的时候创建出来的// Function.prototype = &#123;constructor: Function&#125;// 创建Function函数// function Function() &#123;&#125;// Function.prototype// Function 又是一个对象// Function.__proto__// 唯一一个比较特殊的东西console.log(Function.__proto__ === Function.prototype); // true// 另外还有 function Object() &#123;&#125;// Object作为函数, 就会有Object.prototype// Object作为对象, 就会有Object.__proto__// Object函数是Function创建出来的，所以// Objcet.__proto__ === Function.prototype// 最后就是每个函数的原型prototype都会有一个constructor指回函数本身 最后 上图！","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"07_严格模式","slug":"07_严格模式","date":"2022-04-01T16:47:09.000Z","updated":"2022-04-17T15:26:42.730Z","comments":true,"path":"2022/04/02/07_严格模式/","link":"","permalink":"https://hillyee.github.io/2022/04/02/07_%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"严格模式 如何开启严格模式？ 在文件或者函数开头使用 “use strict” 严格模式常见的限制 &quot;use strict&quot;&quot;use strict&quot;// 1.禁止意外创建全局变量// 在全局中不使用关键字直接定义变量message = &quot;hello&quot;message is not defined// 2. 不允许函数有相同的参数名称function foo(x, y, x) &#123;&#125;// Duplicate parameter name not allowed in this context// 3.使静默错误(不报错但也没有任何效果)的赋值操作抛出异常true.name = &quot;abc&quot;NaN = 123var obj = &#123;&#125;Object.defineProperty(obj, &quot;name&quot;, &#123; configurable: false, writable: false, // 不可写 value: &quot;hillyee&quot;&#125;)obj.name = &quot;jenny&quot;// 试图删除不可删除的属性，报错delete obj.name// Cannot delete property &#x27;name&#x27; of #&lt;Object&gt;// 4.不允许使用原先的八进制格式var num = 0o123 // 八进制var num2 = 0x123 // 十六进制var num3 = 0b100 // 二进制 严格模式下的this &quot;use strict&quot;// 在严格模式下，独立函数调用this默认绑定不是window，而是undefinedfunction foo() &#123; console.log(this); // undefined&#125;foo()var obj = &#123; name: &quot;hill&quot;, foo: foo&#125;var bar = obj.foobar()// setTimeout的this// 内部 fn.apply(this=window)setTimeout(function() &#123; console.log(this); // window&#125;, 1000)","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"06_纯函数-柯里化-组合","slug":"06_纯函数-柯里化-组合","date":"2022-04-01T16:44:34.000Z","updated":"2022-04-14T02:11:10.836Z","comments":true,"path":"2022/04/02/06_纯函数-柯里化-组合/","link":"","permalink":"https://hillyee.github.io/2022/04/02/06_%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88/","excerpt":"","text":"纯函数 - 柯里化 - 组合 纯函数 什么是纯函数？ 确定的输入，一定会产生确定的输出 函数在执行过程中，不能产生副作用 什么是副作用？ 在执行一个函数时，除了返回值函数之外，还对调用函数产生了附加的影响，比如说修改了全局变量，修改参数或者改变外部的存储 纯函数例子 var names = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;, &quot;dna&quot;]// slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值// slice函数本身它是不会修改原来的数组// 所以slice函数本身就是一个纯函数var newNames1 = names.slice(0, 3)console.log(newNames1)// splice不是一个纯函数var newNames2 = names.splice(2)console.log(newNames2)console.log(names) // [ &#x27;abc&#x27;, &#x27;cba&#x27; ] 改变了原数组 JavaScript柯里化 什么是柯里化？ 把接收多个参数的函数变成接收一个单一参数的函数 “如果你固定某些参数，你将得到接受余下参数的一个函数” 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数，这个过程称之为柯里化 柯里化的结构 function add(x, y, z) &#123; return x + y + z&#125;var result = add(10, 20, 30)console.log(result); // 60function sum1(x) &#123; return function(y) &#123; return function(z) &#123; return x + y + z &#125; &#125;&#125;var result2 = sum1(10)(20)(30) // 60console.log(result2);// 简化var sum2 = x =&gt; y =&gt; z =&gt; x + y + z 柯里化让函数的职责单一 每次接收的一个参数，都做它自己的逻辑 可以更好的复用参数逻辑 function makeAdder(count) &#123; count = count * count return function(num) &#123; return count + num &#125;&#125;// 比如说我们想要每次的count都是5var adder5 = makeAdder(5)adder5(10)adder5(13) 柯里化函数的实现 function myCurrying(fn) &#123; function curried(...args) &#123; // 当已经传入的参数 大于等于 需要的参数时, 就执行函数 if (args.length &gt;= fn.length) &#123; // fn() return fn.apply(this, args) &#125; else &#123; // 没有达到个数时, 需要返回一个新的函数,继续来接收参数 function curried2(...args2) &#123; // 接收到参数后, 需要递归调用curried来检查函数的个数是否达到 return curried.apply(this, [...args, ...args2]) &#125; return curried2 &#125; &#125; // 返回一个柯里化的函数 return curried&#125;function add1(x, y, z) &#123; return x + y + z&#125;var curryAdd = myCurrying(add1)console.log(curryAdd(10, 20, 30));console.log(curryAdd(10)(20, 30));console.log(curryAdd(10)(20)(30)); 组合函数 什么是组合函数？ 组合函数是在 JavaScript 开发过程中一种对函数的使用技巧、模式 组合函数的例子 function double(num) &#123; return num * 2&#125;function square(num) &#123; return num ** 2&#125;var count = 10var result = square((double(count))) 实现组合函数 function hyCompose(...fns) &#123; // 如果不是函数,直接报错 let length = fns.length for (let i = 0; i &lt; length; i++) &#123; if(typeof fns[i] !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Expected a function&#x27;) &#125; &#125; // 取出所有的函数一次调用 return function(...args) &#123; let index = 0 let result = length ? fns[index].apply(this, args) : args while(++index &lt; length) &#123; result = fns[index].call(this, result) &#125; return result &#125;&#125;function double(m) &#123; return m * 2&#125;function square(n) &#123; return n ** 2&#125;let newFn = hyCompose(double, square)console.log(newFn(10))","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"05_认识arguments","slug":"05_认识arguments","date":"2022-04-01T16:43:02.000Z","updated":"2022-04-17T15:26:35.850Z","comments":true,"path":"2022/04/02/05_认识arguments/","link":"","permalink":"https://hillyee.github.io/2022/04/02/05_%E8%AE%A4%E8%AF%86arguments/","excerpt":"","text":"认识 arguments 什么是 arguments arguments 是一个对应于传递给函数的参数的类数组对象。(MDN) 类数组对象，就说明它本质上是一个对象类型 类数组表示它长得像数组，并且拥有数组的一些特性，比如说 length，可以通过 index 访问 但是却没有数组的一些方法，比如说 forEach，map 等 function foo() &#123; // 会帮你接收所有传递给函数的参数 console.log(arguments); // [Arguments] &#123; &#x27;0&#x27;: 10, &#x27;1&#x27;: 20, &#x27;2&#x27;: 30 &#125; // 获取参数的长度 console.log(arguments.length); // 3 // 根据索引值获取某一个参数 console.log(arguments[1]); // 20 // 获取当前 arguments 所在的函数 console.log(arguments.callee); // [Function: foo] // arguments.forEach() 是不可以的&#125;foo(10,20,30) arguments 转成数组 如果我们需要遍历里面的参数呢？或者说使用一些数组的方法呢？ 所以在开发中，我们经常会把 arguments 转成数组 第一种方法: 自己遍历 function foo() &#123; // 我们可以通过索引值拿到 arguments 的每一个值 // 然后添加到新的数组 let newArr = [] for (let i = 0; i &lt; arguments.length; i++) &#123; newArr.push(arguments[i]) &#125; console.log(newArr); // [ 10, 20, 30, 40, 50 ]&#125;foo(10, 20, 30, 40, 50) 第二种方法：Array.prototype.slice function foo() &#123; let newArr = Array.prototype.slice.call(arguments) console.log(newArr); // [1, 2, 3, 4, 5, 6]&#125;foo(1,2,3,4,5,6) Array.prototype.slice.call(arguments) ？什么意思呀？ 首先，我们一般使用 slice 的时候，是 arr.slice(start, end)，那如果没有这个arr呢？我们怎么才能拿到 slice 这个方法 是不是可以在 Array 的原型上面找这个方法，所以 Array.prototype.slice() 那为什么要用 call 来调用？ 我们先来模拟一下 Array 中的 slice 是怎么实现的 Array.prototype.myslice = function(start, end) &#123; // 如果我们直接 Array.prototype.myslice() 这样调用的话, this 指向的就是prototype了 // 而我们希望的是, 这里的 this 是指向调用 slice 这个方法的数组 let arr = this start = start || 0 end = end || arr.length let newArray = [] // 从start到end(不包括end),把元素添加到数组 for (let i = start; i &lt; end; i++) &#123; newArray.push(arr[i]) &#125; return newArray&#125; 所以，我们要使用 call 来显式绑定这个 this，让this指向数组 let newArr = Array.prototype.myslice.call([1,2,3,4,5,6])console.log(newArr); // [1, 2, 3, 4, 5, 6]// 当然可以传递参数let newArr2 = Array.prototype.myslice.call([1,2,3,4,5,6], 2, 4)console.log(newArr2); // [3, 4] 那跟我们 arguments 有什么关系？ Array内部 slice 的实现只不过是对 this，也就是需要使用 slice 的数组进行遍历，然后把需要的部分加入到新数组 那遍历 arguments 也可以啊，把元素一个个加入到一个数组里面，再把这个数组返回，最后不就实现了 arguments 转数组了吗 function foo() &#123; let newArr = Array.prototype.slice.call(arguments) console.log(newArr); // [1, 2, 3, 4, 5, 6] // 同样道理的还有一种方法, 我们目的就是拿到 slice 这个方法,并且让 this 绑定 arguments,让内部遍历arguments let newArr2 = [].slice.call(arguments)&#125;foo(1,2,3,4,5,6) 再看回这个，应该理解了吧 Array.from (ES6) Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例（MDN） function foo() &#123; let newArr = Array.from(arguments) console.log(newArr); // [1, 2, 3, 4, 5, 6]&#125;foo(1,2,3,4,5,6) 展开运算符 (ES6) function foo() &#123; // 因为展开运算符实际上也是遍历，把遍历的元素一个个放到数组 let newArr = [...arguments] console.log(newArr); // [1, 2, 3, 4, 5, 6]&#125;foo(1,2,3,4,5,6) 箭头函数没有 arguments 箭头函数是不绑定 arguments 的，如果在箭头函数中使用 arguments，会去找上层作用域中的arguments 注意，全局作用域是没有 arguments 的 var foo = () =&gt; &#123; // 找上层作用域，找到 window console.log(arguments); // arguments is not defined&#125;foo() function foo() &#123; // arguments 有 123 console.log(arguments); // Arguments [123] var bar = () =&gt; &#123; console.log(arguments); // Arguments [123] &#125; return bar&#125;var fn = foo(123)fn() 那如果想传递多个参数呢？用 ES6 的剩余参数 var foo = (a, b, ...args) =&gt; &#123; console.log(a, b); // 1 2 console.log(args); // [3,4,5,6]&#125;foo(1,2,3,4,5,6)","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"Vue3源码学习","slug":"Vue3源码学习","date":"2022-03-31T11:42:30.000Z","updated":"2022-04-09T11:06:58.213Z","comments":true,"path":"2022/03/31/Vue3源码学习/","link":"","permalink":"https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue3源码学习 第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭 1. 真实的DOM渲染 传统的前端开发中，我们是编写自己的HTML，最终被渲染到浏览器上的，这个过程大概是： 解析 html 转化成 DOM 树，然后渲染到页面 2. 虚拟DOM 2.1 渲染过程 3. Vue 源码的三大核心系统 Complier模块：编译模板系统 Runtime模块：也可以称之为 Renderer模块，真正渲染的模块 Reactivity模块：响应式系统 三大系统协同工作 4. 实现 Mini-Vue mini-vue的实现也是，后面有时间得回来重新看看 包括三部分： 渲染系统模块 可响应式系统模块 应用程序入口模块 4.1 渲染系统实现 包含三个功能： h 函数，返回一个 VNode 对象 mount 函数，用于将 VNode 挂载到 DOM 上 patch 函数，用于对比两个 VNode，决定如何处理新的VNode（diff） h函数生成 VNode // 生成 VNode// 直接返回一个 VNode对象即可const h = (tag, props, children) =&gt; &#123; return &#123; tag, props, children &#125;&#125; mount函数挂载 vnode // mount函数, 挂载VNodeconst mount = (vnode, container) =&gt; &#123; // 1.根据tag创建HTML元素,并且存储到vnode的el中 const el = vnode.el = document.createElement(vnode.tag) // 2.处理props属性 // 2.1 如果以on开头,那么监听事件 // 2.2 普通属性直接通过 setAttribute 添加 if (vnode.props) &#123; for (const key in vnode.props) &#123; const value = vnode.props[key] if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value) &#125; else &#123; el.setAttribute(key, value) &#125; &#125; &#125; // 3.处理children if (vnode.children) &#123; if (typeof vnode.children === &#x27;string&#x27;) &#123; el.textContent = vnode.children &#125; else &#123; vnode.children.forEach(item =&gt; &#123; mount(item, el) &#125;); &#125; &#125; // 4.将 el挂载到container上 container.appendChild(el)&#125; patch函数 - 对比两个VNode // patch,对比两个 VNodeconst patch = (n1, n2) =&gt; &#123; // 1. tag不同,直接加入新的节点 if (n1.tag !== n2.tag) &#123; const n1Elparent = n1.el.parentElement n1Elparent.removeChild(n1.el) mount(n2, n1Elparent) &#125; else &#123; // 1. 取出element对象,并且在n2中进行保存 const el = n2.el = n1.el // 2. 处理props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; // 2.1 获取所有的newProps添加到el for (const key in newProps) &#123; const oldValue = oldProps[key] const newValue = newProps[key] if (newValue !== oldValue) &#123; if (key.startsWith(&quot;on&quot;)) &#123; // 对事件监听的判断 el.addEventListener(key.slice(2).toLowerCase(), newValue) &#125; else &#123; el.setAttribute(key, newValue) &#125; &#125; &#125; // 2.2删除旧的props for(const key in oldProps) &#123; if (key.startsWith(&quot;on&quot;)) &#123; const value = oldProps[key] el.removeEventListener(key.slice(2).toLowerCase(), value) &#125; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.处理children const oldChildren = n1.children || [] const newChildren = n2.children || [] if (typeof newChildren === &quot;string&quot;) &#123; // 3.1newChildren本身是一个string // 边界情况 如果oldChildren也是一个字符串 if (typeof oldChildren === &quot;string&quot;) &#123; if (newChildren !== oldChildren) &#123; el.textContent = newChildren &#125; &#125; else &#123; el.innerHTML = newChildren &#125; &#125; else &#123; // 3.2 newChildren本身是一个数组 if (typeof oldChildren === &quot;string&quot;) &#123; el.innerHTML = &quot;&quot; newChildren.forEach(item =&gt; &#123; mount(item, el) &#125;) &#125; else &#123; // oldChildren 也是数组 // 1. 前面有相同节点的 const commonLength = Math.min(oldChildren.length, newChildren.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oldChildren[i], newChildren[i]) &#125; // 2.如果新节点的length更长，那么剩余的新节点进行挂载操作 if (newChildren.length &gt; oldChildren.length) &#123; newChildren.slice(oldChildren.length).forEach(item =&gt; &#123; mount(item, el) &#125;) &#125; // 3.如果旧节点的length更长，那么移除剩余的旧节点进行 if (newChildren.length &lt; oldChildren.length) &#123; oldChildren.slice(newChildren.length).forEach(item =&gt; &#123; el.removeChild(item.el) &#125;) &#125; &#125; &#125; &#125;&#125; 4.2 响应式系统 依赖收集系统 + vue2响应式系统 class Dep &#123; constructor() &#123; // 只要new Dep,就会给你添加subscribes属性 this.subscribers = new Set() // 创建集合(里面放某属性依赖的函数) &#125; depend() &#123; // 收集依赖 if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach(effect =&gt; &#123; effect() &#125;) &#125;&#125;let activeEffect = nullfunction watchEffect(effect) &#123; activeEffect = effect effect() // 原始数据先执行一次 activeEffect = null&#125;const targetMap = new WeakMap()function getDep(target, key) &#123; // 1.根据对象(target)取出对应的Map对象 let depsMap = targetMap.get(target) if (!depsMap) &#123; depsMap = new Map() targetMap.set(target, depsMap) &#125; // 2.取出具体的dep对象 let dep = depsMap.get(key) if (!dep) &#123; dep = new Dep() depsMap.set(key, dep) &#125; return dep&#125;// vue2对raw进行数据劫持function reactive(raw) &#123; // 根据对象拿到所有key,组成数组 Object.keys(raw).forEach(key =&gt; &#123; // 获取key对应的依赖 const dep = getDep(raw, key) let value = raw[key] Object.defineProperty(raw, key, &#123; get() &#123; // 用到了某个key,调用get,所以可以在这里收集依赖 dep.depend() return value &#125;, set(newValue) &#123; // 当属性被重新赋值的时候,会调用set,所以在这里执行这个属性依赖的函数 // raw[key] = newValue 不能这样设置,否则递归了(又对raw操作,又劫持,又来到set这里了) if (value !== newValue) &#123; value = newValue dep.notify() &#125; &#125; &#125;) &#125;) return raw&#125;// 测试代码const info = reactive(&#123; counter: 100, name: &#x27;hillyee&#x27;&#125;)// watchEffect1watchEffect(function () &#123; console.log(info.counter * 2, info.name, &#x27;w1&#x27;);&#125;)// watchEffect2watchEffect(function () &#123; console.log(info.counter * info.counter, &#x27;w2&#x27;);&#125;)// info.counter++ // 修改数据的时候,所有对这个数据有依赖的函数都应该被执行一次// info.name = &quot;hahahhahah&quot; 响应式系统 vue3-proxy实现 // vue3对raw进行数据劫持function reactive(raw) &#123; // Proxy(原对象,代理对象) return new Proxy(raw, &#123; get(target, key) &#123; const dep = getDep(target, key) // 获取该属性的依赖 dep.depend() return target[key] &#125;, set(target, key, newValue) &#123; const dep = getDep(target, key) target[key] = newValue dep.notify() &#125; &#125;)&#125; 为什么 Vue3 选择 Proxy 呢？ Object.definedProperty 是劫持对象的属性时，如果新增元素， 那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理 修改对象的不同： 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截； 而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截； 4.3 框架外层 API 设计 createApp() 用于创建一个app对象，该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上 function createApp(rootComponent) &#123; return &#123; mount(selector) &#123; const container = document.querySelector(selector) let isMounted = false let oldVNode = null watchEffect(function() &#123; if (!isMounted) &#123; // rootComponent.render() 返回根组件的vnode oldVNode = rootComponent.render() mount(oldVNode, container) isMounted = true &#125; else &#123; const newVNode = rootComponent.render() patch(oldVNode, newVNode) oldVNode = newVNode &#125; &#125;) &#125; &#125;&#125; 使用案例–计数 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../mini_vue/renderer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../mini_vue/reactive.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.创建根组件 const App = &#123; data: reactive(&#123; counter: 0 &#125;), render() &#123; return h(&quot;div&quot;, null, [ h(&quot;h2&quot;, null, `当前计数:$&#123;this.data.counter&#125;`), h(&quot;button&quot;, &#123; onClick: () =&gt; &#123; this.data.counter++ console.log(this.data.counter); &#125; &#125;, &quot;+1&quot;) ]) &#125;, &#125; // 2.挂载根组件 const app = createApp(App) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt; Vue3源码阅读 根据图的流程，加上源码，多看看叭，第一次看源码确实有点吃力了 先看熟悉流程，然后可以 debugger 在浏览器上简单过一下整个流程 createApp 源码阅读之挂载根组件 const app = &#123;props: &#123;message: String&#125;instance// 1.处理props和attrsinstance.propsinstance.attrs// 2.处理slotsinstance.slots// 3.执行setupconst result = setup()instance.setupState = proxyRefs(result);// 4.编译template -&gt; compile&lt;template&gt; -&gt; render函数instance.render = Component.render = render函数// 5.对vue2的options api进行知识data/methods/computed/生命周期 组件化的初始化 Compile过程 对于不会改变的静态节点进行作用于提升 我都没找到这部分函数。。。 Block Tree 分析 vue3的一个优化：对于不会改变的静态节点进行作用域提升，仅对新的vnode进行创建 生命周期回调 template中数据的使用顺序 如果setup跟data中有同一个属性,首先选择setup的,内部做了一个判断吧","categories":[{"name":"深入Vue3+Typescript学习⚡","slug":"深入Vue3-Typescript学习⚡","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"}]},{"title":"Vue3_compositionAPI","slug":"Vue3-compositionAPI","date":"2022-03-31T08:10:18.000Z","updated":"2022-04-07T04:03:46.875Z","comments":true,"path":"2022/03/31/Vue3-compositionAPI/","link":"","permalink":"https://hillyee.github.io/2022/03/31/Vue3-compositionAPI/","excerpt":"","text":"Composition API 1. setup 1.1 setup函数有两个参数：props，context props：其实就是父组件传递过来的属性，但是在setup外面依然需要用props接收 context：里面包含三个属性： attrs：父组件传递过来的没有被prop接收的属性 slots：父组件传递过来的插槽 emit：当组件内部需要发出事件的时候用（vue2里面是this.$emit，但是vue3中，setup不能访问this） 1.2 setup 函数的返回值 setup() &#123; let a = 1 return &#123; a &#125;&#125; setup的返回值可以在模板 template 中使用，也就是可以代替data 但是直接这么返回变量，是没有响应式的 1.3 setup 不可以使用 this this 并没有指向当前组件实例 在 setup 被调用之前，data、computed、等都没有被解析 所以无法在 setup 中获取this 2. reactive API 为setup中定义的数据提供响应式的特性 reactive API 传入的类型必须是对象或者数组 const state = reactive(&#123; name: &quot;why&quot; // 这时候这个name就是响应式的&#125;) 3. ref API 3.1 ref API 基本使用 可以传入基本数据类型，在开发中推荐使用 ref，便于代码的抽离，当然如果属性关系很紧密的时候，我们也可以用 reactive ref 会返回一个可变的响应式对象 const message = ref(&quot;hello world&quot;) 在 template 中引用 ref 的值时，Vue会自动帮我们进行解包，就是说我们不需要在模板中 xxx.value 来使用 但是在 setup 内部，它依然是一个 ref 的引用，所以要使用 ref.value 3.2 ref API 的补充 toRefs 和 toRef let info = reactive(&#123; name: &#x27;why&#x27;, age: 18&#125;)// 当我们想解构的时候// let &#123;name, age&#125; = info // 不再是响应式的了// 如果希望响应式的话// 1. toRefs: 将 reactive 对象中所有属性都转成 ref// let &#123;name, age&#125; = toRefs(info)// 只希望单个响应式的话// 2. toReflet &#123;name&#125; = info // 不是响应式let age = toRef(info, &quot;age&quot;)const change = () =&gt; &#123; age.value++&#125; shallowRef：创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的 triggerRef：手动触发和 shallowRef 相关联的副作用 let info = shallowRef(&#123; name: &quot;why&quot;&#125;)const change = () =&gt; &#123; // info.value = &quot;hello&quot; 响应式 info.value.name = &quot;james&quot; // 不是响应式 // 手动触发和 shallowRef 相关联的副作用(变成响应式) triggerRef(info)&#125; customRef 自定义 ref 4. readonly 当我们希望我们给其他组件传递数据时，希望其他组件只是使用我们的内容，但是不允许它们修改的时候，可以用readonly 实际上，readonly 会返回原生对象的只读代理，也就是它依然是一个 Proxy，但是set方法被劫持 开发中常见的readonly方法会传入三个类型的值 普通对象 reactive 返回的对象 ref 的对象 readonly 使用时，readonly 返回的对象不允许修改，但是经过 readonly 处理的原来的对象是可以修改的 const info = &#123; name: &quot;why&quot;&#125;const state = readonly(info)state.name = &quot;aaa&quot; // 不可以info.name = &quot;aaa&quot; // 可以 5. computed 用法一：传入一个getter函数,computed的返回值是一个只读的ref对象(不能修改) const fullName = computed(() =&gt; firstName.value + &quot;-&quot; +lastName.value)const changeData = () =&gt; &#123; firstName.value = &quot;james&quot; // 可修改 fullName.value = &quot;yuzi bing&quot; // 不可修改&#125; 用法二：传入一个对象,对象包含 getter/setter,返回一个可读写的ref 对象 const fullName = computed(&#123; get: () =&gt; firstName.value + &quot;-&quot; +lastName.value, set(newValue) &#123; const names = newValue.split(&#x27; &#x27;) firstName.value = names[0] lastName.value = names[1] &#125;&#125;)const changeData = () =&gt; &#123; fullName.value = &quot;yuzi bing&quot; // 可修改&#125; 6. watchEffect 6.1 watchEffect 基本使用 watchEffect 传入的函数会被立即执行一次, 并在执行的过程中自动收集依赖（相当于你在这个函数使用了什么变量，它会自动收集到） 只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行 下面案例中，name 的改变会被侦听到，而 age 不会被侦听 // watchEffect: 自动收集响应式的依赖const name = ref(&quot;jenny&quot;)const age = ref(18)const changeName = () =&gt; name.value = &quot;tony&quot;const changeAge = () =&gt; age.value = 20watchEffect(() =&gt; &#123; console.log(&quot;name:&quot;, name.value);&#125;) 6.2 watchEffect 停止侦听 如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可 const age = ref(18)// watchEffect 会返回一个函数,供我们停止侦听使用const stop = watchEffect(() =&gt; &#123; console.log(&quot;age:&quot;, age.value);&#125;)const changeAge = () =&gt; &#123; age.value++ // 案例：age 到25的时候就停止侦听 if (age.value &gt; 25) &#123; stop() &#125;&#125; 6.3 watchEffect 清除副作用 清除副作用？ 比如我们需要在侦听器中执行网络请求，但是在网络请求还没完成之前，我们停止了侦听器或者修改了数据让侦听器侦听函数再次执行了，这时候我们应该清除上一次的副作用（数据改变了要重新发送请求或者说不需要发了） const stop = watchEffect((onInvalidate) =&gt; &#123; const timer = setTimeout(() =&gt; &#123; console.log(&#x27;网络请求成功~&#x27;); // 定时器模拟网络请求 &#125;, 2000); // 在传入的回调函数中执行一些清除工作 onInvalidate(() =&gt; &#123; clearTimeout(timer) console.log(&#x27;onInvalidate&#x27;); &#125;) console.log(&quot;age:&quot;, age.value);&#125;) 6.4 watchEffect 执行时机 首先补充一下：在 setup 中如何属于 ref 或者元素或者组件？ 定义一个 ref 对象，绑定到元素或组件的ref属性上 &lt;h2 ref=&quot;title&quot;&gt;hello&lt;/h2&gt; // 绑定到元素的ref属性const title = ref(null) // 定义 ref 对象 watchEffect 执行时机 如果我们希望在副作用函数中获取元素，我们会发现打印结果有两个 watchEffect(() =&gt; &#123; console.log(title.value);&#125;) 这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null 当 DOM 挂载时，会给 title 的 ref 对象赋新的值，副作用函数会再次执行 调整 watchEffect 的执行时机 watchEffect(() =&gt; &#123; console.log(title.value);&#125;, &#123; // flush: &quot;pre&quot; // 在元素挂载或更新之前执行 flush: &quot;post&quot; // 元素挂载更新之后执行, 这时候只打印一次&lt;h2&gt;&lt;/h2&gt;&#125;) 7. watch 7.1 侦听单个数据源 侦听一个 getter 函数 const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)// 1. watch侦听时,传入一个getter函数, 具体监听某个属性watch(() =&gt; info.name, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // Tom jenny&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot;&#125; 直接侦听一个可响应式的对象，reactive 或 ref （ref更常用） // 传入一个可响应式对象: reactive对象/ref对象const title = ref(&quot;hello&quot;)const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)watch(info, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // Proxy &#123;name: &#x27;Tom&#x27;, age: 18&#125;&#125;)watch(title, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // world hello&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot; title.value = &quot;world&quot;&#125; 7.2 侦听多个数据源 注：如果我们希望侦听一个数组或者对象，那么可以使用一个getter函数，并且对可响应对象进行解构 (不解构也行,不解构n,o就是一个Proxy对象) const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)const title = ref(&quot;hello&quot;)// 同时侦听多个数据源watch([() =&gt; (&#123;...info&#125;), title], ([newInfo, newTitle], [oldInfo, oldTitle]) =&gt; &#123; console.log(newInfo, newTitle, oldInfo, oldTitle); // &#123;name: &#x27;Tom&#x27;, age: 18&#125; &#x27;world&#x27; // &#123;name: &#x27;jenny&#x27;, age: 18&#125; &#x27;hello&#x27;&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot; title.value = &quot;world&quot;&#125; 7.3 watch 的选项 const info = reactive(&#123; name: &quot;jenny&quot;, hobby: &#123; title: &#x27;haha&#x27; &#125;&#125;)watch(() =&gt; (&#123;...info&#125;), (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue);&#125;, &#123; deep: true, // 深度监听 immediate: true // 立即执行一次&#125;)const changeData = () =&gt; &#123; // info.name = &quot;Tom&quot; info.hobby.title = &quot;hehe&quot; // 开启深度监听&#125; 8. 生命周期钩子 // 在挂载开始之前被调用：相关的 render 函数首次被调用。onBeforeMount(() =&gt; &#123;&#125;)// 实例挂载完毕后调用onMounted(() =&gt; &#123;&#125;)// 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。onBeforeUpdate(() =&gt; &#123;&#125;)// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。onUpdated(() =&gt; &#123;&#125;)// 卸载组件实例前调用, 这个阶段,实例仍然是完全正常的onBeforeUnmount(() =&gt; &#123;&#125;)// 卸载组件实例后调用,调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。onUnmounted(() =&gt; &#123;&#125;),// 被 keep-alive 缓存的组件激活时调用。onActivated(() =&gt; &#123;&#125;)// 被 keep-alive 缓存的组件失活时调用。onDeactivated(()=&gt;&#123;&#125;) 9. Provide 和 Inject 父组件通过 provide 来提供数据（必须要在父组件中使用过子组件，建立联系才能提供数据） provide(属性名，属性值) const name = ref(&quot;jenny&quot;)// 给后代组件提供属性或方法(为了不让子组件随意修改父组件的数据,可以使用readonly)provide(&quot;name&quot;, readonly(name)) 后代组件可以通过 Inject 来注入需要的属性和对应值 inject(要注入的属性名, 默认值) ，默认值就是如果父组件没有提供改数据的话就使用默认值 const name = inject(&quot;name&quot;) 10. composition API 练习 自定义 hooks 1. useTitle 改变页面标题 import &#123; ref, watch &#125; from &#x27;vue&#x27;export default function(title = &quot;默认的title&quot;) &#123; const titleRef = ref(title) watch(titleRef, (newValue) =&gt; &#123; document.title = newValue &#125;, &#123; immediate: true &#125;) return titleRef&#125; 2. useScrollPosition 监听页面滚动位置 import &#123; ref &#125; from &#x27;vue&#x27;export default function useScrollPosition() &#123; const scrollX = ref(0) const scrollY = ref(0) document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; scrollX.value = window.scrollX scrollY.value = window.scrollY &#125;) return &#123; scrollX, scrollY &#125;&#125; 3. useMousePosition 监听鼠标位置 import &#123; ref &#125; from &#x27;vue&#x27;export default function useMousePosition() &#123; const mouseX = ref(0) const mouseY = ref(0) window.addEventListener(&#x27;mousemove&#x27;, (event) =&gt; &#123; mouseX.value = event.pageX mouseY.value = event.pageY &#125;) return &#123; mouseX, mouseY &#125;&#125; 4. useLocalStorage 使用 localStorage 存储和获取数据 export default function(key, value) &#123; const data = ref(value) // 如果有传value,表示要存储值,否则是获取值 if (value) &#123; window.localStorage.setItem(key, JSON.stringify(value)) &#125; else &#123; data.value = JSON.parse(window.localStorage.getItem(key)) &#125; watch(data, (newValue) =&gt; &#123; window.localStorage.setItem(key, JSON.stringify(newValue)) &#125;) return data&#125; 使用： // 在浏览器存取值let data = useLocalStorage(&quot;name&quot;, &quot;jenny&quot;)const changeData = () =&gt; data.value = &quot;hahaha&quot; 5. useCounter import &#123; ref, computed &#125; from &#x27;vue&#x27;;export default function() &#123; const counter = ref(0); const doubleCounter = computed(() =&gt; counter.value * 2); const increment = () =&gt; counter.value++; const decrement = () =&gt; counter.value--; return &#123; counter, doubleCounter, increment, decrement &#125;&#125; 11. 认识自定义指令 11.1 简单使用 除了 v-for, v-show，等指令，Vue也允许我们自定义指令 自定义指令分为两种 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用 自定义全局指令：app的 directive 方法，可以在任意组件中被使用 简单的案例：当某个元素挂载完成后可以自定获取焦点 默认方式的实现 &lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref, onMounted&#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const input = ref(null) onMounted(() =&gt; &#123; input.value.focus() &#125;) return &#123; input &#125; &#125;&#125; 自定义局部指令 v-focus &lt;input type=&quot;text&quot; ref=&quot;input&quot; v-focus&gt;export default &#123; directives: &#123; // 自定义属性的名称(这里不需要写 v-) focus: &#123; mounted(el) &#123; el.focus() &#125; &#125; &#125;,&#125; 自定义全局指令 v-focus (main.js中) app.directive(&quot;focus&quot;, &#123; mounted(el) &#123; el.focus() &#125;&#125;) 11.2 指令的生命周期 一个指令定义的对象，Vue提供了如下的几个钩子函数： created：在绑定元素的 attribute 或事件监听器被应用之前调用； beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用 mounted：在绑定元素的父组件被挂载后调用 beforeUpdate：在更新包含组件的 VNode 之前调用 updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次 指令的生命周期可以拿到几个参数 app.directive(&quot;focus&quot;, &#123; // el: &lt;input&gt; // bindings: 包含一些属性的对象 // vnode: 一个真实 DOM 元素 // preVnode: 上一个虚拟节点 mounted(el, bindings, vnode, preVnode) &#123; console.log(&quot;focus created&quot;, el, bindings, vnode, preVnode); console.log(bindings.value); // 拿到传入的参数 console.log(bindings.modifiers); // 指令的修饰符 el.focus() &#125;&#125;) 11.3 指令的参数和修饰符 指令接受参数或者修饰符 v-指令名:参数名.修饰符=&quot;具体值&quot;&lt;button v-why:info.aaa.bbb=&quot;&#123;title: &#x27;hello&#x27;, name: &#x27;me&#x27;&#125;&quot;&gt;&lt;/button&gt; 11.4 自定义指令练习 自定义时间格式化的指令 v-format-time import dayjs from &quot;dayjs&quot;;export default function(app) &#123; app.directive(&quot;format-time&quot;, &#123; created(el, bindings) &#123; // 默认格式 bindings.formatString = &quot;YYYY-MM-DD HH:mm:ss&quot; // 如果有传入格式的参数，那么使用传入的格式 if (bindings.value) &#123; bindings.formatString = bindings.value &#125; &#125;, mounted(el, bindings) &#123; const textContent = el.textContent // 节点及其后代的文本内容 let timestamp = parseInt(textContent) if (textContent.length === 10) &#123; timestamp = timestamp * 1000 // 转成毫秒 &#125; el.textContent = dayjs(timestamp).format(bindings.formatString) &#125;, &#125;)&#125; 12. nextTick 将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它 案例：当message更新时，拿到它的高度 如果不放到 nextTick执行，拿到的就是未更新之前的数据，比如第一次点添加内容，输出0 &lt;template&gt; &lt;div&gt; &lt;h2 class=&quot;title&quot; ref=&quot;titleRef&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;addContent&quot;&gt;添加内容&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, nextTick &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const message = ref(&quot;&quot;) const titleRef = ref(null) const addContent = () =&gt; &#123; message.value += &quot;哈哈哈哈哈哈哈哈哈&quot; // console.log(titleRef.value.offsetHeight); nextTick(() =&gt; &#123; console.log(titleRef.value.offsetHeight); &#125;) &#125; ... &#125;&#125;&lt;/script&gt; nextTick的回调函数会被加入到微任务队列之后，在微任务队列中，DOM更新完之后才轮到它执行 其他补充 1. render函数 1.1 认识 h 函数 绝大多数情况下，我们的HTML都是用模板&lt;template&gt;创建的，如果在一些特殊的场景，真的需要JavaScript的完全编程能力，这个时候可以使用 渲染函数，它比模板更接近编译器 Vue在生成真实的 DOM 之前，会将我们的节点转换成 VNode（虚拟节点），而VNode组合在一起形成一棵树结构，就是虚拟DOM（VDOM） 你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode h()函数是一个用于创建 VNode 的函数 1.2 h 函数基本使用 h() 函数接收三个参数，（标签名，组件名…）（属性）（子节点，内容） h 函数可以在两个地方使用，render 函数选项中或者 setup 函数选项中 // render 函数选项中&lt;script&gt; import &#123; h &#125; from &#x27;vue&#x27; export default &#123; render() &#123; return h(&quot;h2&quot;, &#123;class: &quot;title&quot;&#125;, &quot;Hello Render&quot;) &#125;, &#125;&lt;/script&gt; setup() &#123; return () =&gt; h(&quot;h2&quot;, &#123;class: &quot;title&quot;&#125;, &quot;Hello Render&quot;)&#125; 1.3 h 函数实现计数器案例 import &#123; h &#125; from &#x27;vue&#x27;;export default &#123; data() &#123; return &#123; counter: 0 &#125; &#125;, render() &#123; return h(&quot;div&quot;, &#123;class: &quot;app&quot;&#125;, [ h(&quot;h2&quot;, null, `当前计数:$&#123;this.counter&#125;`), h(&quot;button&quot;, &#123;onClick: () =&gt; this.counter++&#125;, &quot;+1&quot;), h(&quot;button&quot;, &#123;onClick: () =&gt; this.counter--&#125;, &quot;-1&quot;) ]) &#125;,&#125; 2. jsx 在项目中使用 jsx 需要添加对 jsx 的支持 安装Babel支持Vue的jsx插件 npm install @vue/babel-plugin-jsx -D 在 babel.config.js 配置文件中配置插件 module.exports = &#123; plugins: [ &quot;@vue/babel-plugin-jsx&quot; ]&#125; 基本使用：计数器案例 export default &#123; data() &#123; return &#123; counter: 0 &#125; &#125;, render() &#123; const increment = () =&gt; this.counter++; const decrement = () =&gt; this.counter--; return ( &lt;div&gt; &lt;h2&gt;当前计数: &#123;this.counter&#125;&lt;/h2&gt; &lt;button onClick=&#123;increment&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;decrement&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 3. 认识 Teleport (先了解一下) 在组件化开发中，我们封装一个组件A，在另外一个组件B中使用，p 那么组件A中template的元素，会被挂载到组件B中template的某个位置，最终形成一棵 DOM 树结构 但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置，这个时候就可以通过teleport完成 4. 认识 Vue 插件 通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行 export default &#123; install(app) &#123; // app.config.globalProperties.$name = &quot;hillyee&quot; &#125;&#125; 函数类型：一个function，这个函数会在安装插件时自动执行 // plugins_function.jsexport default function(app) &#123; console.log(app);&#125; main.js app.use(pluginsFunction)app.use(pluginsObject)","categories":[{"name":"深入Vue3+Typescript学习⚡","slug":"深入Vue3-Typescript学习⚡","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"}],"tags":[]},{"title":"面试题 — JS篇","slug":"面试题—JS篇","date":"2022-03-31T01:17:39.000Z","updated":"2022-04-14T02:13:22.300Z","comments":true,"path":"2022/03/31/面试题—JS篇/","link":"","permalink":"https://hillyee.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87/","excerpt":"","text":"面试题 — JS篇 问：JS 原始数据类型有哪些？引用数据类型有哪些？ 答：在JS中,存在7中原始数据类型,分别是： boolean,null,undefined,number,string,symbol,bigint 引用类型：Object(包含普通对象 Object, 数组对象 Array, 正则对象 RegExp,日期对象 Date,数字函数 Math,函数对象 Function) Symbol表示独一无二的值，主要是用来定义对象的唯一属性名 bigint 可以表示任意大小的整数 问：请说出下面代码的运行结果，并解释原因 function test(person) &#123; person.age = 26 person = &#123; name: &#x27;hzj&#x27;, age: 18 &#125; return person&#125;const p1 = &#123; name: &#x27;fyq&#x27;, age: 19&#125;const p2 = test(p1)console.log(p1) // -&gt; &#123;name: &#x27;fyq&#x27;,age: 26&#125;console.log(p2) // -&gt; &#123; name: &#x27;hzj&#x27;,age: 18 &#125; 答：因为在test函数传参的时候，实际上传递的是p1对象在堆中的内存地址值，所以通过调用person.age = 26确实改变了p1的值，但是随后person变成了另一块内存空间的地址，并且在最后将这个内存空间的地址返回，然后赋值给了p2 问：下面代码的输出结果是什么？(. 和 = 操作符的优先级) let a = &#123;n : 1&#125;let b = aa.x = a = &#123;n: 2&#125; console.log(a.x) // undefinedconsole.log(b.x) // &#123;n:2&#125; 首先我们要知道 在js的运算中&quot;.“和”=“运算符同时出现时，会先执行”.&quot;运算 所以 a.x = a = {n:2} --&gt; a.x = {n:2} --&gt; a = {n:2} 问：0.1+0.2为什么不等于0.3？ 答：(进制转换) js在做数字计算的时候，0.1和0.2都会被转成二进制后无限循环，但是js采用的IEEE 754二进制浮点运算，最大可以存储53位有效数字，于是大于53位后面的会全部截掉，将会导致精度缺失。 (对阶运算) 由于指数位数不相同，运算时需要对阶运算，这部分也可能产生精度缺失 https://juejin.cn/post/6940405970954616839 https://juejin.cn/post/6844903680362151950 你真的了解作用域吗？ var a = 0,b = 0;function A(a) &#123; A = function (b) &#123; console.log(a + b++) &#125; console.log(a++)&#125;A(1) // 1A(2) // 4 ‘1’.toString()为什么可以调用？ 实际上这个语句运行的过程中做了以下几件事： var s = new Object(&quot;1&quot;) // 第一步：创建Object实例。s.toString() // 第二步：调用实例方法s = null // 第三步：执行完方法立即销毁这个实例 创建Object实例。注意为什么不是String？由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类 整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean，Number和String 数据类型的判断 typeof：能判断所有值类型，函数。不可对null、对象、数组进行精确判断，因为都返回object console.log(typeof undefined); // undefinedconsole.log(typeof 2); // numberconsole.log(typeof true); // booleanconsole.log(typeof &quot;str&quot;); // stringconsole.log(typeof Symbol(&quot;foo&quot;)); // symbolconsole.log(typeof 2172141653n); // bigintconsole.log(typeof function () &#123;&#125;); // function// 不能判别console.log(typeof []); // objectconsole.log(typeof &#123;&#125;); // objectconsole.log(typeof null); // object instanceof：可用于判断对象类型 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 const Person = function() &#123;&#125;const p1 = new Person() // p1.__proto__ === Person.prototypep1 instanceof Person // true 即Person构造函数的prototype出现在实例p1的原型链上var str1 = &quot;hello&quot;str1 instanceof String // false（str1不是对象实例）var str2 = new String(&quot;hello&quot;)str2 instanceof String // true Object.prototype.toString.call()：所有原始数据类型都能判断 Object.prototype.toString.call(2); // &quot;[object Number]&quot;Object.prototype.toString.call(&quot;&quot;); // &quot;[object String]&quot;Object.prototype.toString.call(true); // &quot;[object Boolean]&quot;Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(Math); // &quot;[object Math]&quot;Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot;Object.prototype.toString.call([]); // &quot;[object Array]&quot;Object.prototype.toString.call(function () &#123;&#125;); // &quot;[object Function]&quot; 为什么要用call去调用toString方法呢？ 借用Object原型对象上的toString方法，通过this绑定调用，返回&quot;[object 类型]&quot; 如何判断变量是否为数组？ Array.isArray(arr); // truearr.__proto__ === Array.prototype; // truearr instanceof Array; // trueObject.prototype.toString.call(arr); // &quot;[object Array]&quot; == 和 === 有什么区别？ === 叫严格相等，左右两边不仅值要相等，类型也要相等 == 对于一般情况，只要值相等就返回 true，但 == 还涉及一些类型转换，转换规则如下： 两边类型是否相同，相同的话就比较值的大小，如：1==2 false 判断两边是否是 null 和 undefined，是的话就返回true 两边是否是 String 和 Number，是的话，就把String类型转换成 Number，再进行比较 判断其中一边是否是 Boolean，是的话就把Boolean转换成Number，再进行比较 如果其中一边为 Object，而另一边为String、Number或Symbol，会将Object转换成字符串，再进行比较 console.log(&#123;a: 1&#125; == true) // falseconsole.log(&#123;a: 1&#125; == &quot;[object Object]&quot;) // true [ ] == ![ ]的结果是什么？ [] == ![] // 逻辑运算需进行布尔值转换, [] -&gt; true[] == !true[] == false // false -&gt; 0[] == 0 // [] 转换为数值，经过 [].valueOf() --&gt; [] // [].toString -&gt; &quot;&quot; // &quot;&quot;.toNumber() -&gt; 00 == 0 // true 对象转原始类型是根据什么流程运行的？ 对象转原始类型，会调用内置的 [ToPrimitive] 函数，对于该函数，其逻辑如下： Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。 如果有Symbol.toPrimitive()方法，优先调用再返回 调用valueOf()，如果转换后为原始类型，则返回，否则继续 调用toString()，如果转换后为原始类型，则返回 如果都没有返回原始类型，会报错 var obj = &#123; value: 3, valueOf() &#123; return 4 &#125;, toString() &#123; return &#x27;5&#x27; &#125;, [Symbol.toPrimitive]() &#123; return 6 &#125;&#125;console.log(obj + 1); // 7 如何让 if(a == 1 &amp;&amp; a == 2)条件成立？ 如果 a 是对象，则在执行 == 比较的时候，会执行 valueOf 方法(或toString)，因此我们可以重写该方法让条件成立 var a = &#123; value: 0, valueOf: function() &#123; this.value++ return this.value &#125; &#125;console.log(a == 1 &amp;&amp; a == 2); // true 谈谈你对闭包的理解 什么是闭包？ MDN对JS闭包的解释： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。 在JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 也可以说： 闭包是指那些能够访问自由变量的函数。自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量 闭包 = 函数 + 函数能够访问的自由变量 闭包的产生 在某个内部函数的执行上下文创建时，会将父级函数的活动对象(VO)加到内部函数的 [[scope]]中，形成作用域链，所以即使父级函数的执行上下文销毁，但是因为其活动对象实际上还存储在内存中可被内部函数访问到，从而实现了闭包 闭包的应用 函数作为参数被传递 var a = 1;function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; // 这就是闭包 fn();&#125;foo(); // 2 函数作为返回值被返回 function foo() &#123; const a = 100 return function() &#123; console.log(a); &#125;&#125;const fn = foo()const a = 200fn() // 100 闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方 如何解决下面的循环输出问题？ for(var i = 1; i &lt;= 5; i ++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;, 0)&#125; 为什么全部输出6？如何改进让它输出1,2,3,4,5？ 因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，输出i的时候，当前作用域没有，往上一层找，因为循环已结束，上层作用域中的i为6。因此会全部输出6 解决方法： 利用IIFE，每次for循环时，把此时的 i 变量传递到定时器中 IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数 for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;, 0) &#125;)(i)&#125; 给定时器传入第三个参数，作为timer函数的第一个函数参数 定时器从第三个参数开始是附加参数，一旦定时器到期，它们会作为参数传递给function for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function(j) &#123; console.log(j); &#125;, 0, i)&#125; 使用ES6中的let let是块级作用域，用let后，变量只在它所在的代码块生效，没有什么作用域链了 // i = 1&#123; setTimeout(function timer() &#123; console.log(1); &#125;, 0)&#125;// i = 2&#123; setTimeout(function timer() &#123; console.log(2); &#125;, 0)&#125;// i = 3&#123; setTimeout(function timer() &#123; console.log(3); // 3 &#125;, 0)&#125;... 所以可以依次输出1,2,3,4,5 谈谈你对原型链的理解 原型对象和构造函数有何关系？ 在JavaScript中，每当定义一个函数数据类型（普通函数、类）的时候，这个函数就会自带一个prototype属性，这个属性指向函数的原型对象 另外，这个原型对象会有一个constructor属性指回函数本身 当函数被new调用的时候，这个函数就称为了构造函数 new调用会创建一个实例对象，这个实例对象会自带一个__proto__属性，这个属性指向构造函数的原型对象 即o.__proto__ === Foo.prototype 描述一下原型链？ JavaScript对象通过__proto__指向父类原型对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，即原型链 原型链最顶层的原型对象就是Object的原型对象 另外，检查对象自身是否包含某属性，可以使用 hasOwnProperty() 使用 in 的话，即使自身没有，但是原型链中有，也会返回true 绿色箭头，原型链 o.__proto__.__proto__.__proto__ 带着掘金的各种文章一起看,找到自己想要的答案 做了一份前端面试复习计划，保熟～ 链接：https://juejin.cn/post/7061588533214969892 神十三-原生JS灵魂之问, 请问你能接得住几个 链接：https://juejin.cn/post/6844903974378668039 字节跳动最爱考的前端面试题：JavaScript 基础 链接：https://juejin.cn/post/6934500357091360781 「查缺补漏」送你 54 道 JavaScript 面试题 链接：https://juejin.cn/post/6854573211443544078#comment","categories":[{"name":"😣面试题-js篇","slug":"😣面试题-js篇","permalink":"https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"}]},{"title":"TCP三次握手","slug":"TCP三次握手","date":"2022-03-30T12:11:13.000Z","updated":"2022-04-01T00:36:00.738Z","comments":true,"path":"2022/03/30/TCP三次握手/","link":"","permalink":"https://hillyee.github.io/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"1. TCP 三次握手过程 ? （首先，两个概念：SYN：同步标志 ACK：确认标志） 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手： 第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态 第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态 第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态 最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接 2. 为什么需要三次握手？两次不行吗？ 其实这是由 TCP 的自身特点可靠传输决定的。 第一次握手，客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的 第二次握手，服务端发包，客户端收到了。这样客户端就能得出结论：服务端的发送能力、客户端的接收能力是正常的。 第三次握手，客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送，接收能力也正常。 3. (ISN) 是固定的吗? 三次握手的一个重要功能是客户端和服务端交换 ISN ，以便让对方知道接下来接受数据的时候如何按序列号组装数据 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的 4. 三次握手过程中可以携带数据吗 第三次握手的时候可以携带数据。因为假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常。然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，可能会让服务器更加容易受到攻击。 而对于第三次的话，客户端已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的，所以携带数据也没问题 5. 四次挥手？为什么要四次？ 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 刚开始双方都处于established状态，假如是客户端先发起关闭请求 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态 第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。 6. SYN 攻击是什么？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 检测 SYN 攻击？ 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。 常见的防御 SYN 攻击的方法？ 缩短超时时间 增加最大半连接数 过滤网关防护 SYN cookies技术 7. 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_REVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，这种队列称之为半连接队列。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"var_let_const区别","slug":"var-let-const区别","date":"2022-03-30T12:08:54.000Z","updated":"2022-03-31T10:46:51.382Z","comments":true,"path":"2022/03/30/var-let-const区别/","link":"","permalink":"https://hillyee.github.io/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/","excerpt":"","text":"var、let、const 相关 var（ES5）let,const（ES6） 1. 作用域？ 简单来说，作用域就是一个独立的地盘，外层作用域无法读取内层作用域的变量，但是内层作用域可以访问外层作用域的变量或者定义外层作用域的同名变量。 2. var 变量提升？ var 特点？ 无论在全局作用域还是在局部作用域中，使用 var 关键字声明的变量都会被提升到该作用域的最顶部，这就是我们常说的变量提升 在代码预编译的时候，JavaScript 引擎会自动将所有代码里面以var 关键字声明的语句提升到当前作用域的顶端 function fn1() &#123; var name = &quot;jack&quot;&#125;// 等价于function fn1() &#123; var name; name = &quot;jack&quot;&#125; console.log(name) // undefinedvar name = &quot;jack&quot; var 的特点 存在变量提升 在变量未赋值时，变量为 undefined 一个变量可以多次声明，后面的声明会覆盖前面的声明 在函数中使用 var 声明变量的时候，该变量是局部的（因为在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文） function add(num1, num2) &#123; var sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 报错 sum is not defined 如果函数内不使用 var 声明，该变量是全局的，sum 被添加到全局上下文（window）window.sum function add(num1, num2) &#123; sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 30 3. let let 不存在变量提升，let 声明变量前，该变量不能使用(暂时性死区) let 为块级作用域，所有外面的语句块访问不到 console.log(value) // 报错let value = &#x27;hello&#x27; let 不允许重复声明，如果在同一个作用域中某个变量已经存在，再次使用 let 关键字声明的话会报错 4. const 与 let 没什么大不同 const 声明的是常量，常量就是一旦定义完就不能修改的值。 必须初始化值，否则会报错。 需要注意的是：const 变量不能再被重新赋值为其他引用值，但对象的键不受限制 也就是说，并不是变量的值不能改动，而是变量指向的那个内存地址不得改动 const obj1 = &#123;&#125;obj1 = &#123;&#125; // 报错，不能给常量赋值const obj2 = &#123; name: &quot;jack&quot; &#125;obj2.name = &quot;tony&quot; // 没问题 5. 暂时性死区？ 如果区块中存在 let 和 const 命令，以这个命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错 总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”(temporal dead zone 简称 TDZ ) if (true) &#123; // TDZ 开始 tmp = &quot;abc&quot;; console.log(tmp); // 报错 let tmp; // TDZ 结束 console.log(tmp) tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的死区 6. 在 for 循环中使用 var，let 的区别 for(var i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 输出全是10// 因为 i 是全局变量，最后访问的都是全局变量 for(let i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 0123456789; // i 是局部变量，每次循环改变的是对局部变量赋值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"04_实现call_apply_bind","slug":"04_手写call-apply-bind","date":"2022-03-30T11:49:46.000Z","updated":"2022-04-03T07:40:31.531Z","comments":true,"path":"2022/03/30/04_手写call-apply-bind/","link":"","permalink":"https://hillyee.github.io/2022/03/30/04_%E6%89%8B%E5%86%99call-apply-bind/","excerpt":"","text":"call、apply、bind 实现 1. call 实现 首先我们要知道系统的 call 方法主要实现了什么 执行了函数 改变了 this 的指向 先看系统的call方法 function foo() &#123; console.log(&quot;foo函数被执行&quot;, this);&#125;function sum(num1, num2) &#123; console.log(&quot;sum函数被执行&quot;, this); return num1 + num2&#125;// 1. 传入对象foo.call(&#123;&#125;) // 2. 传入null/undefinedfoo.call(null) // this自动替换为指向全局对象// 3. 传入其他，字符串，数字，布尔值等等foo.call(&quot;abc&quot;) // this 指向相应的对象let res = sum.call(&quot;123&quot;, 10,20)console.log(res) // 30 接下来我们开始实现自己的call（主要是实现思路，没有把所有的边缘条件考虑完全，但是基本都有） 1.1 让函数执行起来 Function.prototype.mycall = function() &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着让函数执行起来 fn() // 但是这里是独立函数调用，this指向window&#125;foo.mycall() // 这里相当于mycall隐式绑定了foo,因此 mycall中的this就是foo 2.2 显式绑定this 现在我们要绑定我们指定的this 先看第一种：foo.mycall(&#123;name: 'hello'&#125;)，绑定一个对象 Function.prototype.mycall = function(thisArg) &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着调用这个函数 // 我们的目的是让函数执行的时候绑定thisArg这个对象执行即thisArg.fn()(隐式绑定) // 但是现在 thisArg没有 fn 这个属性呀，怎么调用呢 // 所以我们可以给thisArg添加一个属性 fn, 值就是我们想要执行的函数 thisArg.fn = fn // 然后再调用 thisArg.fn() // 但是这样我们不就让thisArg多出来一个属性fn了吗？ // 没关系，函数执行完 删掉就好 delete thisArg.fn&#125; 如果我们传入的不是对象呢？那就不能给thisArg添加属性啦 foo.mycall(&quot;123&quot;) Function.prototype.mycall = function(thisArg) &#123; let fn = this // 所以要把 thisArg 转成对象类型(Object构造函数可以将给定的值包装为一个新对象) thisArg = Object(thisArg) thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 如果传入的是 null / undefined 呢 Function.prototype.mycall = function(thisArg) &#123; let fn = this // 如果thisArg传入的是 undefined / null, 应该让它指向全局对象 // 所以我们要做一个判断 thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 2.3 接下来要考虑参数了 // rest运算符// ...args 会把我们传入的参数列表组合到一个数组 [num1,num2]// ...args 也可以展开数组, 相当于对数组的一个遍历Function.prototype.mycall = function(thisArg, ...args) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 把参数传入函数，并用 result 接收函数执行完的结果(例子中就是sum函数执行完的结果) let result = thisArg.fn(...args) // ...[num1, num2] --&gt; num1, num2 delete thisArg.fn // 最后把结果返回出去 return result&#125; 到此，基本的call就已经实现了 检验一下叭 foo.mycall(&#123;name: &#x27;hello&#x27;&#125;)foo.mycall(&quot;123&quot;)foo.mycall(undefined)foo.mycall(null)sum.mycall(&#123;name: &quot;hello&quot;&#125;, 10, 20)let res1 = sum.mycall(123, 10, 20)console.log(res1); 2. apply 实现 跟 call 类似，只不过参数的处理有不同 Function.prototype.myapply = function(thisArg, argsArray) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 没有传argArray,那么argsArray默认为 undefined,那么就不能使用展开运算符了 // 所以如果没有传入参数, 那么把它初始化为 [], 空数组也是可以展开的 ...[] argsArray = argsArray || [] let result = thisArg.fn(...argsArray) delete thisArg.fn return result&#125; 3. bind 实现 bind 需要我们返回一个新的函数，并且调用 bind 的时候不需要执行函数 Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn() &#123; thisArg.fn = fn let result = thisArg.fn(...args) delete thisArg.fn // 返回结果 return result &#125; // bind 需要返回一个新的函数 你也可以直接 return function() &#123;...&#125; return newFn&#125; 大体上也差不多，但我们可以就下面这种情况改进一下 function sum2(num1, num2, num3, num4) &#123; console.log(&quot;sum2函数被执行&quot;, this); return num1 + num2 + num3 + num4&#125;let newSum2 = sum2.mybind(&quot;abc&quot;, 10,20) // 绑定的时候传入了两个参数console.log(newSum2(30,40)); // 使用新返回的函数的时候再传入剩余的参数 这种情况，我们就需要把两次传入的参数合并起来，再调用 Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn(...newArgs) &#123; // 合并传入的参数 let allArgs = [...args, ...newArgs] thisArg.fn = fn let result = thisArg.fn(...allArgs) delete thisArg.fn // 返回结果 return result &#125; return newFn&#125; 到此，基本的bind也实现了 最后说明一下，实现的思路是这样，但是方法不唯一的，可能还有一些边边角角没有考虑到的话，可以自己添加进去","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"03_JS函数的this指向","slug":"03_JS函数的this指向","date":"2022-03-30T10:50:46.000Z","updated":"2022-04-04T05:13:14.417Z","comments":true,"path":"2022/03/30/03_JS函数的this指向/","link":"","permalink":"https://hillyee.github.io/2022/03/30/03_JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/","excerpt":"","text":"JS 函数的 this 指向 1. this 在全局作用域下的指向 在浏览器中，this在全局作用域下指向 window console.log(this) // windowvar title = &quot;hello&quot;console.log(this.title) // helloconsole.log(window.title) // hello 2. this 的四个绑定规则 2.1 规则一：默认绑定 在独立函数调用的情况下会使用默认绑定 独立函数调用简单来说就是它没有绑定到某个对象上进行调用，简单看几个例子 // 例1function foo() &#123; console.log(this)&#125;foo() // window // 例2function foo1() &#123; console.log(this);&#125;function foo2() &#123; foo1()&#125;function foo3() &#123; foo2()&#125;foo3() // window // 例3var obj = &#123; name: &#x27;hello&#x27;, foo: function() &#123; console.log(this); &#125;&#125;var bar = obj.foobar() // window 以上的函数调用的时候，都是没有被绑定到对象中调用的，所以 this 都指向 window 2.2 规则二：隐式绑定 函数通过某个对象进行调用的时候，这个对象会被 js 引擎绑定到函数中的 this 里 下面看几个例子： // 1.function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, fn: foo&#125;obj.fn() // obj 对象 // 2.var obj1 = &#123; foo: function() &#123; console.log(this); &#125;&#125;var obj2 = &#123; title: &#x27;hello&#x27;, bar: obj1.foo&#125;obj2.bar() // obj2对象 2.3 显式绑定 利用 call，apply，bind手动指定 this 的绑定，这种明确的绑定称为显式绑定 (1) call，apply call，apply 都是可以调用函数的 fn.call(自定的this指向，参数1，参数2) fn.apply(this指向，[参数1，参数2]) 两者的区别在于传参的方式，下面例子可以看出来 call 传入参数列表，apply是数组 function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;var obj = &#123; title: &quot;hello&quot;&#125;sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;sum.apply(obj, [20,30,40]) // 手动让this指向obj (2) bind bind不会调用函数，而是返回一个新的对象。 function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;// var obj = &#123;// title: &quot;hello&quot;// &#125;// sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;// sum.apply(obj, [20,30,40]) // 手动让this指向objvar newSum = sum.bind(&#x27;aaa&#x27;,10,20,30)newSum() // 60 String &#123;&#x27;aaa&#x27;&#125; 咦？newSum 不也是独立函数调用吗，怎么不指向 window 了 这就是默认绑定和显式绑定bind的冲突，显式绑定的优先级更高！ 2.4 new绑定 function Person(name, age) &#123; this.name = name this.age = age // 实际上这里是会把 this 返回出去的,即return this（默认） // this = 创建出来的对象&#125;// new 会创建一个全新的对象var p1 = new Person(&quot;jenny&quot;, 12)var p2 = new Person(&quot;tony&quot;, 15) 3. 一些内置函数的 this 绑定 有时候我们会调用一些 JS 的内置函数，这些函数要求我们传入另外一个函数，并且我们不会自己去调用这些函数，而是 JS 内部会帮助我们执行。 这个时候，this 的绑定就跟内部帮我们指向函数的方式有关系了。 看几个例子吧 3.1 setTimeout 内部通过 apply 调用函数，并绑定了this对象，是window setTimeout(function() &#123; console.log(this); // window&#125;, 2000) 3.2 数组的内置函数 forEach 默认情况下传入的函数是自动调用函数（默认绑定） var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 window&#125;) 也可以通过传入第二个参数，改变this指向 var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 &#x27;obj&#x27;&#125;, &#x27;obj&#x27;) 3.3 点击事件 在发生点击时，回调函数被调用，会将 this 绑定到该函数中 &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; var box = document.querySelector(&quot;.box&quot;)box.onclick = function() &#123; console.log(this); // box对象&#125; 所以说，某些内置的函数，我们很难确定它内部是如何调用传入的回调函数的，可以自己测试一下，记一下，看源码当然更好啦 4. 几个规则的优先级 从高到低：new绑定 &gt; 显式绑定(bind) &gt; 隐式绑定 &gt; 默认绑定 new绑定和call，apply是不允许同时使用的，（毕竟都会调用函数），所以不存在谁的优先级更高 显式绑定高于隐式绑定 // 显式绑定和隐式绑定function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;obj&#x27;, foo: foo&#125;obj.foo() // obj 对象obj.foo.call(&quot;aaa&quot;) // &#x27;aaa&#x27; new 绑定高于隐式绑定 function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, foo: foo&#125;new obj.foo() // 输出 foo 对象而不是 obj new 绑定高于bind function foo() &#123; console.log(this, title);&#125;var obj = &#123; name: &#x27;hello&#x27;&#125;var bar = foo.bind(obj) // 显式绑定objnew bar() // 打印 foo对象 而不是 obj 5. 两种特殊情况 5.1 在显式绑定中传入 null 或 undefined 这时候，显式绑定会被忽略，使用默认规则 function foo() &#123; console.log(this);&#125;var obj = &#123; name: &quot;hello&quot;, foo: foo&#125;foo.call(obj) // objfoo.call(null) // windowfoo.call(undefined) // window 5.2 间接函数引用 function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;// 先来看一下这个赋值的结果, 是 foo 函数console.log((obj2.foo = obj1.foo)); // foo函数// 这种叫做间接函数引用，是会把赋值语句右边的结果返回，然后直接调用，是独立函数调用(obj2.foo = obj1.foo)() // 相当于直接调用 foo 函数，所以是默认绑定，输出window 6. 箭头函数的this 箭头函数不绑定 this，也就是说它没有自己的 this，而是根据外层作用域来决定this var name = &quot;hello&quot;var foo = () =&gt; &#123; console.log(this); // 在这里this的外层作用域就是 window&#125;var obj = &#123; foo: foo&#125;obj.foo() // windowobj.foo.call(&quot;aaa&quot;) // window 再来看一个案例： 使用setTimeout模拟一个网络请求，如果我们想把返回来的数据保存到 data 中，该怎么做 var obj = &#123; data: &#x27;&#x27;, getData: function() &#123; setTimeout(() =&gt; &#123; console.log(this); // obj 对象 // 这里的 this 不是应该指向window吗？ // 如果我们这里使用的是普通的函数 function() &#123;console.log(this)&#125; // 那么这个函数在内部调用的时候，会绑定this，就是window // 但是我们使用了箭头函数，它不绑定this，会往上层作用域中找到对应的this // 所以找到了 obj this.data = &#x27;hello&#x27; // --&gt; obj.data = &quot;hello&quot; &#125;, 2000); &#125;&#125;obj.getData() 7. this 的面试题 如果每题都会了，那么 this 绑定的问题，就是你的送分题而不是送命题了哈哈哈 建议把我的答案跟注释都删掉，自己一点点理清哦 题一 var name = &quot;window&quot;; // window.name = &quot;window&quot;var person = &#123; name: &quot;person&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;;function sayName() &#123; var sss = person.sayName; sss(); // window 很明显是独立函数调用,没有与任何对象关联 person.sayName(); // person 隐式绑定,与person关联 (person.sayName)(); // person 同上(加括号只是代表这是一个整体) // console.log((b = person.sayName)); // 这里实际上就是sayName这个函数 (b = person.sayName)(); // 间接函数引用，是独立函数调用, 输出 window&#125;sayName(); 题二 var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;// 隐式绑定person1对象person1.foo1(); // person1// 显式绑定person2person1.foo1.call(person2); // person2// 箭头函数不适用任何规则, 向上层作用域中找thisperson1.foo2(); // windowperson1.foo2.call(person2); // window// person1.foo3()返回了一个函数，然后独立调用person1.foo3()(); // window// person1.foo3.call(person2) 返回的是一个函数，然后独立调用person1.foo3.call(person2)(); // window// person1.foo3()返回一个函数，然后显式绑定到 person2person1.foo3().call(person2); // person2// person1.foo4()返回一个箭头函数，往上层作用域找，找到foo4中绑定的this,是 person1person1.foo4()(); // person1// foo4显式绑定到 person2person1.foo4.call(person2)(); // person2// person1.foo4()返回箭头函数，往上层作用域找person1.foo4().call(person2); // person1 题三 var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.foo1 = function () &#123; console.log(this.name) &#125;, this.foo2 = () =&gt; console.log(this.name), this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() // person1 隐式绑定person1.foo1.call(person2) // person2 显式绑定person1.foo2() // person1 隐式绑定// 箭头函数不适用显式绑定规则，直接向上层作用域找person1.foo2.call(person2) // person1 // person1.foo3() 返回一个函数，在全局调用person1.foo3()() // windowperson1.foo3.call(person2)() // window // 同理// person1.foo3() 返回的函数使用 .call 显式绑定 person2person1.foo3().call(person2) //person2 // person1.foo4() 返回一个箭头函数，再调用，向上层作用域找person1.foo4()() // person1// person1.foo4.call(person2) 返回箭头函数，并且foo4显式绑定this为person2// 再调用这个箭头函数，向上找就找到 foo4 的this 为person2person1.foo4.call(person2)() // person2 // person1.foo4() 返回箭头函数,不适用显式绑定，向上找到 person1// 注意这里跟上面的区别，这里的foo4调用不是.call调用的，而是.foo4()这样调用的// call是来调用箭头函数的，而箭头函数不适用显式绑定，向上找到的是person1person1.foo4().call(person2) // person1 题四 var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)// person1.obj.foo1()返回一个函数，在全局中调用person1.obj.foo1()() // window// person1.obj.foo1.call(person2) 返回一个函数 在全局中调用person1.obj.foo1.call(person2)() // window// person1.obj.foo1() 返回一个函数，显式绑定person2person1.obj.foo1().call(person2) // person2// 箭头函数调用，向上找到 foo2 中的this是objperson1.obj.foo2()() // obj// foo2调用的时候显式绑定person2，箭头函数向上层找到的就是person2person1.obj.foo2.call(person2)() // person2// 箭头函数不适用 显式绑定，向上找找到 objperson1.obj.foo2().call(person2) // obj","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"02_JS内存管理和闭包","slug":"02_JS内存管理和闭包","date":"2022-03-30T10:49:50.000Z","updated":"2022-04-03T07:40:20.371Z","comments":true,"path":"2022/03/30/02_JS内存管理和闭包/","link":"","permalink":"https://hillyee.github.io/2022/03/30/02_JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"一、JS 的内存管理 1. JS 的内存管理 JavaScript 会在定义变量时为我们分配内存 内存分配的方式是一样的吗？ JS 对于基本数据类型内存的分配，会在执行时直接在栈空间进行分配 JS 对于复杂数据类型内存的分配，会在堆内存中开辟一块空间，并且将这块空间的地址保存在栈空间 2. JS 的垃圾回收 垃圾回收的英文是 Garbage Collection，简称 GC 对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放出更多的内存空间 JavaScript的运行环境 js引擎都会内存垃圾回收器 3. 常见的两个 GC 算法 GC怎么知道哪些对象是不再使用的呢？这里就要用到 GC 算法了 3.1 引用计数 当一个对象有一个引用指向它的时候，那么这个对象的引用就 +1，当一个对象的引用为 0 时，这个对象就可以被回收掉 但是这个算法有一个很大的弊端，就是会产生循环引用 var obj1 = &#123;friend: obj2&#125;var obj2 = &#123;friend: obj1&#125; 3.2 标记清除 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象 ​ 图中从 A 开始找，找到 D 的时候结束，M,N不可达，被认为是不可用的对象 这个算法可以很好的解决循环引用的问题 注：JS 引擎比较广泛采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，在算法的实现细节上也会结合一些其他的算法 二、JS中的闭包 1. 什么是闭包？ JavaScript 中的一个函数，如果它访问了外层作用域的变量，那么这个函数是一个闭包。 MDN中的一个解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） function foo() &#123; var name = &quot;foo&quot; var age = 18 function bar() &#123; console.log(name)// name访问了外层作用域的变量name console.log(age) // age访问了外层作用域的变量age &#125; return bar // 返回一个函数&#125;var fn = foo()fn() 2. 闭包的访问过程 简单描述上面函数的执行过程： 1. GO: &#123;foo:地址1, fn:undefined&#125;2. 执行代码： 2.1 foo():只要执行函数，就会创建一个函数执行上下文 (1)VO: &#123;AO对象:&#123;name: undefined;age:undefined;bar:地址2&#125;&#125; scopechain:[VO+parent scopes] (2)开始执行代码 &#123;name: &quot;foo&quot;, age:18;&#125; return bar地址2 (3)foo执行完毕 2.2 fn: bar地址2 2.3 fn(),即执行 bar地址2中的函数执行体,创建bar的函数执行上下文 (1)&#123;AO:&#123;&#125;,scopechain&#125; (2)执行代码: console.log(name):在自己的AO中找不到，通过作用域链找到foo的AO，找到name:&quot;foo&quot;,输出 &quot;foo&quot; console.log(age)同理 (3)fn()执行完毕3.执行完毕地址1:foo函数对象: &#123;parentScope: GO&#125;,&#123;foo函数的执行体&#125;地址2:bar函数对象: &#123;parentScope: foo的AO对象&#125;,&#123;bar函数的执行体&#125; 你可能会有疑惑：foo函数执行完毕之后，不是应该弹出栈吗，foo的AO对象不应该被释放了吗？怎么bar还能找到 name，找到 age 呢？ 看下图： 可以看到，当我们执行完 foo 函数的时候，返回的是 bar 函数(或者说是bar的地址)，然后因为 fn = foo()，把这个地址赋值给了fn，因此会存在 fn 指向 bar函数对象，而bar的父作用域又指向了 foo 的AO对象，因此foo的AO是不会被释放的 3. 闭包的内存泄漏 为什么总说闭包是有内存泄漏的呢？什么是内存泄漏？ 拿上面的例子说，如果后续我们不会再用 foo，bar 这些函数了，但是在全局作用域下 fn 变量对bar函数对象有引用，而bar的作用域中AO对foo的AO有引用，所以会造成这些内存都是无法被释放的。 这就是我们所说的内存泄漏，其实就是刚才的引用链中的对象无法释放 怎么解决这个问题呢？ 很简单，设置 fn = null，就不再对 bar 函数对象有引用，那么从GO出发，bar是不可达的，那么对应的AO对象(foo) 同样也就不可达。 在下一次 GC 的的检测中，它们就会被销毁掉 还有一个问题，形成闭包之后，是不是所有的属性都不会被释放呢？ 还是这个例子 function foo() &#123; var name = &quot;why&quot; var age = 18 function bar() &#123; console.log(name) // console.log(age) &#125; return bar&#125;var fn = foo()fn() 如果age不使用了，会不会被销毁掉呢？ 答案是会的，测试如下： 这是因为 V8 引擎做的优化，因为规范中闭包的属性应该是不会被销毁的","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"01_深入JS运行原理","slug":"01_深入JS运行原理","date":"2022-03-30T10:49:46.000Z","updated":"2022-04-10T13:44:11.830Z","comments":true,"path":"2022/03/30/01_深入JS运行原理/","link":"","permalink":"https://hillyee.github.io/2022/03/30/01_%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"1. 从输入 URL 到页面展示 发生了什么？ ​ 总体分为以下过程： DNS 域名解析：将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 2. 浏览器工作原理 在浏览器中输入查找内容，浏览器是怎样将页面加载出来的？ 大致流程如下： 首先，用户输入服务器地址，与服务器建立连接 服务器返回对应的静态资源（index.html） 然后浏览器拿到 index.html 后进行解析 当解析时遇到 css 或 js 文件，就向服务器请求并下载对应的 css 和 js 文件 最后浏览器对页面进行渲染，执行 js 代码 3. 浏览器渲染过程 HTML Parser 将 HTML解析转换成 DOM 树 CSS Parser 将 样式表转换成 CSS 规则树 合并 DOM 树和 CSS 规则树，生成 render（渲染） 树 布局 render 树（Layout） 通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 绘制 render 树（painting），进行 Display 展示 注意图中顶部的紫色 DOM 三角形，实际上是 js 对 DOM 的相关操作。 4. 一个强大的 JavaScript 引擎 — V8 引擎 在解析 HTML 的过程中，遇到了 JavaScript 标签，该怎么办呢？ 会停止解析 HTML ，而去加载和执行 JavaScript 代码 那么，JavaScript 代码由谁来执行呢？ JavaScript 引擎 高级的编程语言最终都要转成机器指令来执行的， 所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行 （1）V8 引擎的架构 V8 的底层架构主要有三个核心模块（Parse、Ignition、TurboFan） 1. Parse： 该过程主要是对 JavaScript 源代码进行词法分析和语法分析。 词法分析：对代码中的每一个词每一个符号进行解析，最终生成很多 tokens 例如：对 const name = “curry” // 首先对const进行解析，因为const为一个关键字，所以类型会被记为一个关键词，值为consttokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;]// 接着对name进行解析，因为name为一个标识符，所以类型会被记为一个标识符，值为nametokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;, &#123; type: &#x27;identifier&#x27;, value: &#x27;name&#x27; &#125;]// 以此类推... 语法分析：在词法分析的基础上，拿到 tokens 中的一个个对象，根据不同类型，再进一步分析具体语法，最终生成 AST 抽象语法树 可以详细查看通过 Parse 转换后的 AST 的工具：AST Explorer 2. Ignition 一个解析器，可以将 AST 转换成 ByteCode（字节码） 3. TurboFan 一个编译器，可以将字节码编译为 CPU 认识的机器码 （2）V8 引擎的执行过程 Blink 内核将 JS 源码交给 V8 引擎 Stream 获取到 JS 源码进行编码转换 Scanner 进行词法分析，将代码转换成 tokens Parser 和 PreParser Parser ：直接解析，将 tokens 转成 AST 树 PreParser：预解析，对不必要的函数进行预解析，也就是只解析暂时需要的内容，而在函数被调用时才进行函数的全量解析 生成 AST 树后，会被 Ignition 转成字节码，之后就是代码的执行过程 5. JavaScript 的执行过程 假如要执行如下代码： var title = &quot;hello&quot;console.log(num1)var num1 = 20var num2 = 30var result = num1 + num2console.log(result) （1）首先，代码被解析，V8 引擎内部会帮助我们创建一个全局对象：Global Object（GO） GO 可以访问所有的作用域 里面会包含 Date、Array、String、setTimeout等等（所以我们可以直接 new Date() ） GO 还有一个window 属性指向自己（所以window.window.window还是指向 GO自己） 用伪代码表示为： var globalObject = &#123; String: 类, setTimeout: 函数, ... window: globalObject&#125; （2）然后运行代码 首先我们要知道 js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ESC），它是用于执行代码的调用栈。 为了全局代码能够正常执行，首先需要创建一个**全局执行上下文 **（Global Execution Context，简称GEC），全局代码需要被执行时才会创建 然后全局执行上下文会被放入执行上下文栈中执行，包含两个部分： 在代码执行前，会将全局定义的变量，函数等加入到 GlobalOject 中，但是并不会赋值（也称为变量的作用域提升） 开始依次执行代码： title = “hello” // 赋值 console.log(num1) // undefined, 不会报错 num1= 20 … 遇到函数如何执行? 先根据函数体创建一个函数执行上下文，并且压入到执行上下文栈中（EC Stack） 在初始化 GO 的时候，函数的 AO 也是会被初始化的 比如说 ，全局中，有function foo() {}，一开始初始化GO的时候从上到下执行到 foo 会在内存中创建foo，并且保存作用域链到foo的内部属性[[scope]]，即 foo.[[scope]] = [ globalContext.VO] 作用域链？ 由 VO(变量对象，在函数中就是 AO 对象)和 父级 VO组成，查找时会一层层查找 看一个例子： var message = &quot;Hello Global&quot;function foo() &#123; console.log(message) // Hello Global&#125;function bar() &#123; var message = &quot;Hello Bar&quot; foo()&#125;bar() 比如说这里，当执行 foo 函数的时候， foo 的 AO 中没有message，就会去它的父级 VO 中查找。一定要注意！当第一次代码解析的时候， foo 的函数执行上下文就已经确定了，其中包括三部分： 第一部分：在解析函数成为 AST 树结构的时候，会创建一个 AO（Activation） 其中包含形参、arguments、函数定义、指向函数对象或定义的变量 第二部分：就是作用域链 第三部分：this 绑定的值 因此！当foo在自己的AO找不到message的时候，去父级 VO 找，这个父级 VO 就是一开始解析时候保存的 GO，所以message为 “Hello Global” 简单描述一下这个过程吧：(我不专业的表达) // 初始化 GOGO: &#123;window; message:undefined; foo: 地址1; bar: 地址2;&#125;// 执行代码GO: &#123;window; message:&quot;Hello Global&quot;; foo: 地址1; bar: 地址2;&#125;bar函数执行,创建一个函数执行上下文, 其中包括 VO对象: AO:&#123;message: undefined&#125; 然后开始执行 bar函数 message:&quot;Hello Bar&quot; (赋值) foo() foo函数执行，创建一个foo的函数执行上下文 其中包括：VO: AO: &#123;&#125; 然后开始执行代码 console.log(message) 发现自己的AO没有message,会向上找，即从自己保存的父级VO中查找，找到GO中的message为 &quot;Hello Global&quot; (图来源于coderwhy) JS执行上下文：https://github.com/mqyqingfeng/Blog/issues/8 写的挺清晰详细的 几道常见的作用域提升面试题： var n = 100function foo() &#123; n = 200&#125;foo()console.log(n) // 200 function foo() &#123; console.log(n) // undefined var n = 200 console.log(n) // 200&#125;var n = 100foo() var a = 100function foo() &#123; console.log(a) // undefined return var a = 200&#125;foo() function foo() &#123; m = 100&#125;foo()console.log(m) // 100 function foo() &#123; var a = b = 10 // =&gt; 转成下面的两行代码 // var a = 10 // b = 10&#125;foo()//console.log(a) // 报错 a is not defined(因为当 foo函数执行完之后，foo的函数执行上下文就会弹出栈(没啦！哪里还会有a呢))console.log(b) // 10","categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-29T14:25:03.367Z","updated":"2022-03-29T14:25:03.367Z","comments":true,"path":"2022/03/29/hello-world/","link":"","permalink":"https://hillyee.github.io/2022/03/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"🔫深入JS高级语法","slug":"🔫深入JS高级语法","permalink":"https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"},{"name":"😣面试题-js篇","slug":"😣面试题-js篇","permalink":"https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"},{"name":"深入Vue3+Typescript学习⚡","slug":"深入Vue3-Typescript学习⚡","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"},{"name":"数据结构与算法😥","slug":"数据结构与算法😥","permalink":"https://hillyee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%F0%9F%98%A5/"},{"name":"其他","slug":"其他","permalink":"https://hillyee.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://hillyee.github.io/tags/promise/"},{"name":"js","slug":"js","permalink":"https://hillyee.github.io/tags/js/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"-TS","slug":"TS","permalink":"https://hillyee.github.io/tags/TS/"},{"name":"ES6","slug":"ES6","permalink":"https://hillyee.github.io/tags/ES6/"},{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"},{"name":"vuex","slug":"vuex","permalink":"https://hillyee.github.io/tags/vuex/"},{"name":"算法","slug":"算法","permalink":"https://hillyee.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"vue路由","slug":"vue路由","permalink":"https://hillyee.github.io/tags/vue%E8%B7%AF%E7%94%B1/"}]}
{"meta":{"title":"Hillyee-blog","subtitle":"","description":"","author":"Hillyee","url":"https://hillyee.github.io","root":"/"},"pages":[{"title":"About","date":"2022-03-30T15:53:22.543Z","updated":"2022-03-30T15:53:22.543Z","comments":false,"path":"about/index.html","permalink":"https://hillyee.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-03-30T15:45:28.276Z","updated":"2022-03-30T15:45:28.276Z","comments":false,"path":"categories/index.html","permalink":"https://hillyee.github.io/categories/index.html","excerpt":"","text":"categories111"},{"title":"每日一题","date":"2022-03-31T05:15:38.752Z","updated":"2022-03-31T05:15:38.752Z","comments":false,"path":"links/index.html","permalink":"https://hillyee.github.io/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-03-30T10:42:50.892Z","updated":"2022-03-30T10:42:50.892Z","comments":false,"path":"tags/index.html","permalink":"https://hillyee.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-30T05:15:58.514Z","updated":"2022-03-30T05:15:58.514Z","comments":false,"path":"repository/index.html","permalink":"https://hillyee.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue3源码学习","slug":"Vue3源码学习","date":"2022-03-31T11:42:30.000Z","updated":"2022-03-31T11:46:27.769Z","comments":true,"path":"2022/03/31/Vue3源码学习/","link":"","permalink":"https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue3源码学习 第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭 1. 真实的DOM渲染 传统的前端开发中，我们是编写自己的HTML，最终被渲染到浏览器上的，这个过程大概是： 解析 html 转化成 DOM 树，然后渲染到页面 2. 虚拟DOM 2.1 渲染过程 3. Vue 源码的三大核心系统 Complier模块：编译模板系统 Runtime模块：也可以称之为 Renderer模块，真正渲染的模块 Reactivity模块：响应式系统 三大系统协同工作 4. 实现 Mini-Vue mini-vue的实现也是，后面有时间得回来重新看看 包括三部分： 渲染系统模块 可响应式系统模块 应用程序入口模块 4.1 渲染系统实现 包含三个功能： h 函数，返回一个 VNode 对象 mount 函数，用于将 VNode 挂载到 DOM 上 patch 函数，用于对比两个 VNode，决定如何处理新的VNode（diff） h函数生成 VNode // 生成 VNode// 直接返回一个 VNode对象即可const h = (tag, props, children) =&gt; &#123; return &#123; tag, props, children &#125;&#125; mount函数挂载 vnode // mount函数, 挂载VNodeconst mount = (vnode, container) =&gt; &#123; // 1.根据tag创建HTML元素,并且存储到vnode的el中 const el = vnode.el = document.createElement(vnode.tag) // 2.处理props属性 // 2.1 如果以on开头,那么监听事件 // 2.2 普通属性直接通过 setAttribute 添加 if (vnode.props) &#123; for (const key in vnode.props) &#123; const value = vnode.props[key] if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value) &#125; else &#123; el.setAttribute(key, value) &#125; &#125; &#125; // 3.处理children if (vnode.children) &#123; if (typeof vnode.children === &#x27;string&#x27;) &#123; el.textContent = vnode.children &#125; else &#123; vnode.children.forEach(item =&gt; &#123; mount(item, el) &#125;); &#125; &#125; // 4.将 el挂载到container上 container.appendChild(el)&#125; patch函数 - 对比两个VNode // patch,对比两个 VNodeconst patch = (n1, n2) =&gt; &#123; // 1. tag不同,直接加入新的节点 if (n1.tag !== n2.tag) &#123; const n1Elparent = n1.el.parentElement n1Elparent.removeChild(n1.el) mount(n2, n1Elparent) &#125; else &#123; // 1. 取出element对象,并且在n2中进行保存 const el = n2.el = n1.el // 2. 处理props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; // 2.1 获取所有的newProps添加到el for (const key in newProps) &#123; const oldValue = oldProps[key] const newValue = newProps[key] if (newValue !== oldValue) &#123; if (key.startsWith(&quot;on&quot;)) &#123; // 对事件监听的判断 el.addEventListener(key.slice(2).toLowerCase(), newValue) &#125; else &#123; el.setAttribute(key, newValue) &#125; &#125; &#125; // 2.2删除旧的props for(const key in oldProps) &#123; if (key.startsWith(&quot;on&quot;)) &#123; const value = oldProps[key] el.removeEventListener(key.slice(2).toLowerCase(), value) &#125; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.处理children const oldChildren = n1.children || [] const newChildren = n2.children || [] if (typeof newChildren === &quot;string&quot;) &#123; // 3.1newChildren本身是一个string // 边界情况 如果oldChildren也是一个字符串 if (typeof oldChildren === &quot;string&quot;) &#123; if (newChildren !== oldChildren) &#123; el.textContent = newChildren &#125; &#125; else &#123; el.innerHTML = newChildren &#125; &#125; else &#123; // 3.2 newChildren本身是一个数组 if (typeof oldChildren === &quot;string&quot;) &#123; el.innerHTML = &quot;&quot; newChildren.forEach(item =&gt; &#123; mount(item, el) &#125;) &#125; else &#123; // oldChildren 也是数组 // 1. 前面有相同节点的 const commonLength = Math.min(oldChildren.length, newChildren.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oldChildren[i], newChildren[i]) &#125; // 2.如果新节点的length更长，那么剩余的新节点进行挂载操作 if (newChildren.length &gt; oldChildren.length) &#123; newChildren.slice(oldChildren.length).forEach(item =&gt; &#123; mount(item, el) &#125;) &#125; // 3.如果旧节点的length更长，那么移除剩余的旧节点进行 if (newChildren.length &lt; oldChildren.length) &#123; oldChildren.slice(newChildren.length).forEach(item =&gt; &#123; el.removeChild(item.el) &#125;) &#125; &#125; &#125; &#125;&#125; 4.2 响应式系统 依赖收集系统 + vue2响应式系统 class Dep &#123; constructor() &#123; // 只要new Dep,就会给你添加subscribes属性 this.subscribers = new Set() // 创建集合(里面放某属性依赖的函数) &#125; depend() &#123; // 收集依赖 if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach(effect =&gt; &#123; effect() &#125;) &#125;&#125;let activeEffect = nullfunction watchEffect(effect) &#123; activeEffect = effect effect() // 原始数据先执行一次 activeEffect = null&#125;const targetMap = new WeakMap()function getDep(target, key) &#123; // 1.根据对象(target)取出对应的Map对象 let depsMap = targetMap.get(target) if (!depsMap) &#123; depsMap = new Map() targetMap.set(target, depsMap) &#125; // 2.取出具体的dep对象 let dep = depsMap.get(key) if (!dep) &#123; dep = new Dep() depsMap.set(key, dep) &#125; return dep&#125;// vue2对raw进行数据劫持function reactive(raw) &#123; // 根据对象拿到所有key,组成数组 Object.keys(raw).forEach(key =&gt; &#123; // 获取key对应的依赖 const dep = getDep(raw, key) let value = raw[key] Object.defineProperty(raw, key, &#123; get() &#123; // 用到了某个key,调用get,所以可以在这里收集依赖 dep.depend() return value &#125;, set(newValue) &#123; // 当属性被重新赋值的时候,会调用set,所以在这里执行这个属性依赖的函数 // raw[key] = newValue 不能这样设置,否则递归了(又对raw操作,又劫持,又来到set这里了) if (value !== newValue) &#123; value = newValue dep.notify() &#125; &#125; &#125;) &#125;) return raw&#125;// 测试代码const info = reactive(&#123; counter: 100, name: &#x27;hillyee&#x27;&#125;)// watchEffect1watchEffect(function () &#123; console.log(info.counter * 2, info.name, &#x27;w1&#x27;);&#125;)// watchEffect2watchEffect(function () &#123; console.log(info.counter * info.counter, &#x27;w2&#x27;);&#125;)// info.counter++ // 修改数据的时候,所有对这个数据有依赖的函数都应该被执行一次// info.name = &quot;hahahhahah&quot; 响应式系统 vue3-proxy实现 // vue3对raw进行数据劫持function reactive(raw) &#123; // Proxy(原对象,代理对象) return new Proxy(raw, &#123; get(target, key) &#123; const dep = getDep(target, key) // 获取该属性的依赖 dep.depend() return target[key] &#125;, set(target, key, newValue) &#123; const dep = getDep(target, key) target[key] = newValue dep.notify() &#125; &#125;)&#125; 为什么 Vue3 选择 Proxy 呢？ Object.definedProperty 是劫持对象的属性时，如果新增元素， 那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理 修改对象的不同： 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截； 而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截； 4.3 框架外层 API 设计 createApp() 用于创建一个app对象，该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上 function createApp(rootComponent) &#123; return &#123; mount(selector) &#123; const container = document.querySelector(selector) let isMounted = false let oldVNode = null watchEffect(function() &#123; if (!isMounted) &#123; // rootComponent.render() 返回根组件的vnode oldVNode = rootComponent.render() mount(oldVNode, container) isMounted = true &#125; else &#123; const newVNode = rootComponent.render() patch(oldVNode, newVNode) oldVNode = newVNode &#125; &#125;) &#125; &#125;&#125; 使用案例–计数 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../mini_vue/renderer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../mini_vue/reactive.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.创建根组件 const App = &#123; data: reactive(&#123; counter: 0 &#125;), render() &#123; return h(&quot;div&quot;, null, [ h(&quot;h2&quot;, null, `当前计数:$&#123;this.data.counter&#125;`), h(&quot;button&quot;, &#123; onClick: () =&gt; &#123; this.data.counter++ console.log(this.data.counter); &#125; &#125;, &quot;+1&quot;) ]) &#125;, &#125; // 2.挂载根组件 const app = createApp(App) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt; Vue3源码阅读 根据图的流程，加上源码，多看看叭，第一次看源码确实有点吃力了 先看熟悉流程，然后可以 debugger 在浏览器上简单过一下整个流程 createApp 源码阅读之挂载根组件 const app = &#123;props: &#123;message: String&#125;instance// 1.处理props和attrsinstance.propsinstance.attrs// 2.处理slotsinstance.slots// 3.执行setupconst result = setup()instance.setupState = proxyRefs(result);// 4.编译template -&gt; compile&lt;template&gt; -&gt; render函数instance.render = Component.render = render函数// 5.对vue2的options api进行知识data/methods/computed/生命周期 组件化的初始化 Compile过程 对于不会改变的静态节点进行作用于提升 我都没找到这部分函数。。。 Block Tree 分析 vue3的一个优化：对于不会改变的静态节点进行作用域提升，仅对新的vnode进行创建 生命周期回调 template中数据的使用顺序 如果setup跟data中有同一个属性,首先选择setup的,内部做了一个判断吧","categories":[{"name":"深入Vue3+Typescript学习","slug":"深入Vue3-Typescript学习","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"难","slug":"难","permalink":"https://hillyee.github.io/tags/%E9%9A%BE/"},{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"}]},{"title":"Vue3_compositionAPI","slug":"Vue3-compositionAPI","date":"2022-03-31T08:10:18.000Z","updated":"2022-03-31T10:47:45.760Z","comments":true,"path":"2022/03/31/Vue3-compositionAPI/","link":"","permalink":"https://hillyee.github.io/2022/03/31/Vue3-compositionAPI/","excerpt":"","text":"Composition API 1. setup 1.1 setup函数有两个参数：props，context props：其实就是父组件传递过来的属性，但是在setup外面依然需要用props接收 context：里面包含三个属性： attrs：父组件传递过来的没有被prop接收的属性 slots：父组件传递过来的插槽 emit：当组件内部需要发出事件的时候用（vue2里面是this.$emit，但是vue3中，setup不能访问this） 1.2 setup 函数的返回值 setup() &#123; let a = 1 return &#123; a &#125;&#125; setup的返回值可以在模板 template 中使用，也就是可以代替data 但是直接这么返回变量，是没有响应式的 1.3 setup 不可以使用 this this 并没有指向当前组件实例 在 setup 被调用之前，data、computed、等都没有被解析 所以无法在 setup 中获取this 2. reactive API 为setup中定义的数据提供响应式的特性 reactive API 传入的类型必须是对象或者数组 const state = reactive(&#123; name: &quot;why&quot; // 这时候这个name就是响应式的&#125;) 3. ref API 3.1 ref API 基本使用 可以传入基本数据类型，在开发中推荐使用 ref，便于代码的抽离，当然如果属性关系很紧密的时候，我们也可以用 reactive ref 会返回一个可变的响应式对象 const message = ref(&quot;hello world&quot;) 在 template 中引用 ref 的值时，Vue会自动帮我们进行解包，就是说我们不需要在模板中 xxx.value 来使用 但是在 setup 内部，它依然是一个 ref 的引用，所以要使用 ref.value 3.2 ref API 的补充 toRefs 和 toRef let info = reactive(&#123; name: &#x27;why&#x27;, age: 18&#125;)// 当我们想解构的时候// let &#123;name, age&#125; = info // 不再是响应式的了// 如果希望响应式的话// 1. toRefs: 将 reactive 对象中所有属性都转成 ref// let &#123;name, age&#125; = toRefs(info)// 只希望单个响应式的话// 2. toReflet &#123;name&#125; = info // 不是响应式let age = toRef(info, &quot;age&quot;)const change = () =&gt; &#123; age.value++&#125; shallowRef：创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的 triggerRef：手动触发和 shallowRef 相关联的副作用 let info = shallowRef(&#123; name: &quot;why&quot;&#125;)const change = () =&gt; &#123; // info.value = &quot;hello&quot; 响应式 info.value.name = &quot;james&quot; // 不是响应式 // 手动触发和 shallowRef 相关联的副作用(变成响应式) triggerRef(info)&#125; customRef 自定义 ref 4. readonly 当我们希望我们给其他组件传递数据时，希望其他组件只是使用我们的内容，但是不允许它们修改的时候，可以用readonly 实际上，readonly 会返回原生对象的只读代理，也就是它依然是一个 Proxy，但是set方法被劫持 开发中常见的readonly方法会传入三个类型的值 普通对象 reactive 返回的对象 ref 的对象 readonly 使用时，readonly 返回的对象不允许修改，但是经过 readonly 处理的原来的对象是可以修改的 const info = &#123; name: &quot;why&quot;&#125;const state = readonly(info)state.name = &quot;aaa&quot; // 不可以info.name = &quot;aaa&quot; // 可以 5. computed 用法一：传入一个getter函数,computed的返回值是一个只读的ref对象(不能修改) const fullName = computed(() =&gt; firstName.value + &quot;-&quot; +lastName.value)const changeData = () =&gt; &#123; firstName.value = &quot;james&quot; // 可修改 fullName.value = &quot;yuzi bing&quot; // 不可修改&#125; 用法二：传入一个对象,对象包含 getter/setter,返回一个可读写的ref 对象 const fullName = computed(&#123; get: () =&gt; firstName.value + &quot;-&quot; +lastName.value, set(newValue) &#123; const names = newValue.split(&#x27; &#x27;) firstName.value = names[0] lastName.value = names[1] &#125;&#125;)const changeData = () =&gt; &#123; fullName.value = &quot;yuzi bing&quot; // 可修改&#125; 6. watchEffect 6.1 watchEffect 基本使用 watchEffect 传入的函数会被立即执行一次, 并在执行的过程中自动收集依赖（相当于你在这个函数使用了什么变量，它会自动收集到） 只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行 下面案例中，name 的改变会被侦听到，而 age 不会被侦听 // watchEffect: 自动收集响应式的依赖const name = ref(&quot;jenny&quot;)const age = ref(18)const changeName = () =&gt; name.value = &quot;tony&quot;const changeAge = () =&gt; age.value = 20watchEffect(() =&gt; &#123; console.log(&quot;name:&quot;, name.value);&#125;) 6.2 watchEffect 停止侦听 如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可 const age = ref(18)// watchEffect 会返回一个函数,供我们停止侦听使用const stop = watchEffect(() =&gt; &#123; console.log(&quot;age:&quot;, age.value);&#125;)const changeAge = () =&gt; &#123; age.value++ // 案例：age 到25的时候就停止侦听 if (age.value &gt; 25) &#123; stop() &#125;&#125; 6.3 watchEffect 清除副作用 清除副作用？ 比如我们需要在侦听器中执行网络请求，但是在网络请求还没完成之前，我们停止了侦听器或者修改了数据让侦听器侦听函数再次执行了，这时候我们应该清除上一次的副作用（数据改变了要重新发送请求或者说不需要发了） const stop = watchEffect((onInvalidate) =&gt; &#123; const timer = setTimeout(() =&gt; &#123; console.log(&#x27;网络请求成功~&#x27;); // 定时器模拟网络请求 &#125;, 2000); // 在传入的回调函数中执行一些清除工作 onInvalidate(() =&gt; &#123; clearTimeout(timer) console.log(&#x27;onInvalidate&#x27;); &#125;) console.log(&quot;age:&quot;, age.value);&#125;) 6.4 watchEffect 执行时机 首先补充一下：在 setup 中如何属于 ref 或者元素或者组件？ 定义一个 ref 对象，绑定到元素或组件的ref属性上 &lt;h2 ref=&quot;title&quot;&gt;hello&lt;/h2&gt; // 绑定到元素的ref属性const title = ref(null) // 定义 ref 对象 watchEffect 执行时机 如果我们希望在副作用函数中获取元素，我们会发现打印结果有两个 watchEffect(() =&gt; &#123; console.log(title.value);&#125;) 这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null 当 DOM 挂载时，会给 title 的 ref 对象赋新的值，副作用函数会再次执行 调整 watchEffect 的执行时机 watchEffect(() =&gt; &#123; console.log(title.value);&#125;, &#123; // flush: &quot;pre&quot; // 在元素挂载或更新之前执行 flush: &quot;post&quot; // 元素挂载更新之后执行, 这时候只打印一次&lt;h2&gt;&lt;/h2&gt;&#125;) 7. watch 7.1 侦听单个数据源 侦听一个 getter 函数 const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)// 1. watch侦听时,传入一个getter函数, 具体监听某个属性watch(() =&gt; info.name, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // Tom jenny&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot;&#125; 直接侦听一个可响应式的对象，reactive 或 ref （ref更常用） // 传入一个可响应式对象: reactive对象/ref对象const title = ref(&quot;hello&quot;)const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)watch(info, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // Proxy &#123;name: &#x27;Tom&#x27;, age: 18&#125;&#125;)watch(title, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // world hello&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot; title.value = &quot;world&quot;&#125; 7.2 侦听多个数据源 注：如果我们希望侦听一个数组或者对象，那么可以使用一个getter函数，并且对可响应对象进行解构 (不解构也行,不解构n,o就是一个Proxy对象) const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)const title = ref(&quot;hello&quot;)// 同时侦听多个数据源watch([() =&gt; (&#123;...info&#125;), title], ([newInfo, newTitle], [oldInfo, oldTitle]) =&gt; &#123; console.log(newInfo, newTitle, oldInfo, oldTitle); // &#123;name: &#x27;Tom&#x27;, age: 18&#125; &#x27;world&#x27; // &#123;name: &#x27;jenny&#x27;, age: 18&#125; &#x27;hello&#x27;&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot; title.value = &quot;world&quot;&#125; 7.3 watch 的选项 const info = reactive(&#123; name: &quot;jenny&quot;, hobby: &#123; title: &#x27;haha&#x27; &#125;&#125;)watch(() =&gt; (&#123;...info&#125;), (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue);&#125;, &#123; deep: true, // 深度监听 immediate: true // 立即执行一次&#125;)const changeData = () =&gt; &#123; // info.name = &quot;Tom&quot; info.hobby.title = &quot;hehe&quot; // 开启深度监听&#125; 8. 生命周期钩子 // 在挂载开始之前被调用：相关的 render 函数首次被调用。onBeforeMount(() =&gt; &#123;&#125;)// 实例挂载完毕后调用onMounted(() =&gt; &#123;&#125;)// 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。onBeforeUpdate(() =&gt; &#123;&#125;)// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。onUpdated(() =&gt; &#123;&#125;)// 卸载组件实例前调用, 这个阶段,实例仍然是完全正常的onBeforeUnmount(() =&gt; &#123;&#125;)// 卸载组件实例后调用,调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。onUnmounted(() =&gt; &#123;&#125;),// 被 keep-alive 缓存的组件激活时调用。onActivated(() =&gt; &#123;&#125;)// 被 keep-alive 缓存的组件失活时调用。onDeactivated(()=&gt;&#123;&#125;) 9. Provide 和 Inject 父组件通过 provide 来提供数据（必须要在父组件中使用过子组件，建立联系才能提供数据） provide(属性名，属性值) const name = ref(&quot;jenny&quot;)// 给后代组件提供属性或方法(为了不让子组件随意修改父组件的数据,可以使用readonly)provide(&quot;name&quot;, readonly(name)) 后代组件可以通过 Inject 来注入需要的属性和对应值 inject(要注入的属性名, 默认值) ，默认值就是如果父组件没有提供改数据的话就使用默认值 const name = inject(&quot;name&quot;) 10. composition API 练习 自定义 hooks 1. useTitle 改变页面标题 import &#123; ref, watch &#125; from &#x27;vue&#x27;export default function(title = &quot;默认的title&quot;) &#123; const titleRef = ref(title) watch(titleRef, (newValue) =&gt; &#123; document.title = newValue &#125;, &#123; immediate: true &#125;) return titleRef&#125; 2. useScrollPosition 监听页面滚动位置 import &#123; ref &#125; from &#x27;vue&#x27;export default function useScrollPosition() &#123; const scrollX = ref(0) const scrollY = ref(0) document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; scrollX.value = window.scrollX scrollY.value = window.scrollY &#125;) return &#123; scrollX, scrollY &#125;&#125; 3. useMousePosition 监听鼠标位置 import &#123; ref &#125; from &#x27;vue&#x27;export default function useMousePosition() &#123; const mouseX = ref(0) const mouseY = ref(0) window.addEventListener(&#x27;mousemove&#x27;, (event) =&gt; &#123; mouseX.value = event.pageX mouseY.value = event.pageY &#125;) return &#123; mouseX, mouseY &#125;&#125; 4. useLocalStorage 使用 localStorage 存储和获取数据 export default function(key, value) &#123; const data = ref(value) // 如果有传value,表示要存储值,否则是获取值 if (value) &#123; window.localStorage.setItem(key, JSON.stringify(value)) &#125; else &#123; data.value = JSON.parse(window.localStorage.getItem(key)) &#125; watch(data, (newValue) =&gt; &#123; window.localStorage.setItem(key, JSON.stringify(newValue)) &#125;) return data&#125; 使用： // 在浏览器存取值let data = useLocalStorage(&quot;name&quot;, &quot;jenny&quot;)const changeData = () =&gt; data.value = &quot;hahaha&quot; 5. useCounter import &#123; ref, computed &#125; from &#x27;vue&#x27;;export default function() &#123; const counter = ref(0); const doubleCounter = computed(() =&gt; counter.value * 2); const increment = () =&gt; counter.value++; const decrement = () =&gt; counter.value--; return &#123; counter, doubleCounter, increment, decrement &#125;&#125; 11. 认识自定义指令 11.1 简单使用 除了 v-for, v-show，等指令，Vue也允许我们自定义指令 自定义指令分为两种 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用 自定义全局指令：app的 directive 方法，可以在任意组件中被使用 简单的案例：当某个元素挂载完成后可以自定获取焦点 默认方式的实现 &lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref, onMounted&#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const input = ref(null) onMounted(() =&gt; &#123; input.value.focus() &#125;) return &#123; input &#125; &#125;&#125; 自定义局部指令 v-focus &lt;input type=&quot;text&quot; ref=&quot;input&quot; v-focus&gt;export default &#123; directives: &#123; // 自定义属性的名称(这里不需要写 v-) focus: &#123; mounted(el) &#123; el.focus() &#125; &#125; &#125;,&#125; 自定义全局指令 v-focus (main.js中) app.directive(&quot;focus&quot;, &#123; mounted(el) &#123; el.focus() &#125;&#125;) 11.2 指令的生命周期 一个指令定义的对象，Vue提供了如下的几个钩子函数： created：在绑定元素的 attribute 或事件监听器被应用之前调用； beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用 mounted：在绑定元素的父组件被挂载后调用 beforeUpdate：在更新包含组件的 VNode 之前调用 updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次 指令的生命周期可以拿到几个参数 app.directive(&quot;focus&quot;, &#123; // el: &lt;input&gt; // bindings: 包含一些属性的对象 // vnode: 一个真实 DOM 元素 // preVnode: 上一个虚拟节点 mounted(el, bindings, vnode, preVnode) &#123; console.log(&quot;focus created&quot;, el, bindings, vnode, preVnode); console.log(bindings.value); // 拿到传入的参数 console.log(bindings.modifiers); // 指令的修饰符 el.focus() &#125;&#125;) 11.3 指令的参数和修饰符 指令接受参数或者修饰符 v-指令名:参数名.修饰符=&quot;具体值&quot;&lt;button v-why:info.aaa.bbb=&quot;&#123;title: &#x27;hello&#x27;, name: &#x27;me&#x27;&#125;&quot;&gt;&lt;/button&gt; 11.4 自定义指令练习 自定义时间格式化的指令 v-format-time import dayjs from &quot;dayjs&quot;;export default function(app) &#123; app.directive(&quot;format-time&quot;, &#123; created(el, bindings) &#123; // 默认格式 bindings.formatString = &quot;YYYY-MM-DD HH:mm:ss&quot; // 如果有传入格式的参数，那么使用传入的格式 if (bindings.value) &#123; bindings.formatString = bindings.value &#125; &#125;, mounted(el, bindings) &#123; const textContent = el.textContent // 节点及其后代的文本内容 let timestamp = parseInt(textContent) if (textContent.length === 10) &#123; timestamp = timestamp * 1000 // 转成毫秒 &#125; el.textContent = dayjs(timestamp).format(bindings.formatString) &#125;, &#125;)&#125; 其他补充 1. render函数 1.1 认识 h 函数 绝大多数情况下，我们的HTML都是用模板&lt;template&gt;创建的，如果在一些特殊的场景，真的需要JavaScript的完全编程能力，这个时候可以使用 渲染函数，它比模板更接近编译器 Vue在生成真实的 DOM 之前，会将我们的节点转换成 VNode（虚拟节点），而VNode组合在一起形成一棵树结构，就是虚拟DOM（VDOM） 你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode h()函数是一个用于创建 VNode 的函数 1.2 h 函数基本使用 h() 函数接收三个参数，（标签名，组件名…）（属性）（子节点，内容） h 函数可以在两个地方使用，render 函数选项中或者 setup 函数选项中 // render 函数选项中&lt;script&gt; import &#123; h &#125; from &#x27;vue&#x27; export default &#123; render() &#123; return h(&quot;h2&quot;, &#123;class: &quot;title&quot;&#125;, &quot;Hello Render&quot;) &#125;, &#125;&lt;/script&gt; setup() &#123; return () =&gt; h(&quot;h2&quot;, &#123;class: &quot;title&quot;&#125;, &quot;Hello Render&quot;)&#125; 1.3 h 函数实现计数器案例 import &#123; h &#125; from &#x27;vue&#x27;;export default &#123; data() &#123; return &#123; counter: 0 &#125; &#125;, render() &#123; return h(&quot;div&quot;, &#123;class: &quot;app&quot;&#125;, [ h(&quot;h2&quot;, null, `当前计数:$&#123;this.counter&#125;`), h(&quot;button&quot;, &#123;onClick: () =&gt; this.counter++&#125;, &quot;+1&quot;), h(&quot;button&quot;, &#123;onClick: () =&gt; this.counter--&#125;, &quot;-1&quot;) ]) &#125;,&#125; 2. jsx 在项目中使用 jsx 需要添加对 jsx 的支持 安装Babel支持Vue的jsx插件 npm install @vue/babel-plugin-jsx -D 在 babel.config.js 配置文件中配置插件 module.exports = &#123; plugins: [ &quot;@vue/babel-plugin-jsx&quot; ]&#125; 基本使用：计数器案例 export default &#123; data() &#123; return &#123; counter: 0 &#125; &#125;, render() &#123; const increment = () =&gt; this.counter++; const decrement = () =&gt; this.counter--; return ( &lt;div&gt; &lt;h2&gt;当前计数: &#123;this.counter&#125;&lt;/h2&gt; &lt;button onClick=&#123;increment&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;decrement&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 3. 认识 Teleport (先了解一下) 在组件化开发中，我们封装一个组件A，在另外一个组件B中使用，p 那么组件A中template的元素，会被挂载到组件B中template的某个位置，最终形成一棵 DOM 树结构 但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置，这个时候就可以通过teleport完成 4. 认识 Vue 插件 通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行 export default &#123; install(app) &#123; // app.config.globalProperties.$name = &quot;hillyee&quot; &#125;&#125; 函数类型：一个function，这个函数会在安装插件时自动执行 // plugins_function.jsexport default function(app) &#123; console.log(app);&#125; main.js app.use(pluginsFunction)app.use(pluginsObject)","categories":[{"name":"深入Vue3+Typescript学习","slug":"深入Vue3-Typescript学习","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"面试每日练 — JS篇","slug":"面试每日一题——JS篇","date":"2022-03-31T01:17:39.000Z","updated":"2022-03-31T05:27:00.460Z","comments":true,"path":"2022/03/31/面试每日一题——JS篇/","link":"","permalink":"https://hillyee.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94JS%E7%AF%87/","excerpt":"","text":"JS 数据类型","categories":[{"name":"面试题-js篇","slug":"面试题-js篇","permalink":"https://hillyee.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"}],"tags":[]},{"title":"TCP三次握手","slug":"TCP三次握手","date":"2022-03-30T12:11:13.000Z","updated":"2022-03-31T06:26:33.081Z","comments":true,"path":"2022/03/30/TCP三次握手/","link":"","permalink":"https://hillyee.github.io/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"1. TCP 三次握手过程 ? （首先，两个概念：SYN：同步标志 ACK：确认标志） 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手： 第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态 第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态 第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态 最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接 2. 为什么需要三次握手？两次不行吗？ 其实这是由 TCP 的自身特点可靠传输决定的。 第一次握手，客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的 第二次握手，服务端发包，客户端收到了。这样客户端就能得出结论：服务端的发送能力、客户端的接收能力是正常的。 第三次握手，客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送，接收能力也正常。 3. (ISN) 是固定的吗? 三次握手的一个重要功能是客户端和服务端交换 ISN ，以便让对方知道接下来接受数据的时候如何按序列号组装数据 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的 4. 三次握手过程中可以携带数据吗 第三次握手的时候可以携带数据。因为假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常。然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，可能会让服务器更加容易受到攻击。 而对于第三次的话，客户端已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的，所以携带数据也没问题 5. 四次挥手？为什么要四次？ 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 刚开始双方都处于established状态，假如是客户端先发起关闭请求 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态 第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。 6. SYN 攻击是什么？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 检测 SYN 攻击？ 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。 常见的防御 SYN 攻击的方法？ 缩短超时时间 增加最大半连接数 过滤网关防护 SYN cookies技术 7. 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，这种队列称之为半连接队列。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"var_let_const区别","slug":"var-let-const区别","date":"2022-03-30T12:08:54.000Z","updated":"2022-03-31T10:46:51.382Z","comments":true,"path":"2022/03/30/var-let-const区别/","link":"","permalink":"https://hillyee.github.io/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/","excerpt":"","text":"var、let、const 相关 var（ES5）let,const（ES6） 1. 作用域？ 简单来说，作用域就是一个独立的地盘，外层作用域无法读取内层作用域的变量，但是内层作用域可以访问外层作用域的变量或者定义外层作用域的同名变量。 2. var 变量提升？ var 特点？ 无论在全局作用域还是在局部作用域中，使用 var 关键字声明的变量都会被提升到该作用域的最顶部，这就是我们常说的变量提升 在代码预编译的时候，JavaScript 引擎会自动将所有代码里面以var 关键字声明的语句提升到当前作用域的顶端 function fn1() &#123; var name = &quot;jack&quot;&#125;// 等价于function fn1() &#123; var name; name = &quot;jack&quot;&#125; console.log(name) // undefinedvar name = &quot;jack&quot; var 的特点 存在变量提升 在变量未赋值时，变量为 undefined 一个变量可以多次声明，后面的声明会覆盖前面的声明 在函数中使用 var 声明变量的时候，该变量是局部的（因为在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文） function add(num1, num2) &#123; var sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 报错 sum is not defined 如果函数内不使用 var 声明，该变量是全局的，sum 被添加到全局上下文（window）window.sum function add(num1, num2) &#123; sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 30 3. let let 不存在变量提升，let 声明变量前，该变量不能使用(暂时性死区) let 为块级作用域，所有外面的语句块访问不到 console.log(value) // 报错let value = &#x27;hello&#x27; let 不允许重复声明，如果在同一个作用域中某个变量已经存在，再次使用 let 关键字声明的话会报错 4. const 与 let 没什么大不同 const 声明的是常量，常量就是一旦定义完就不能修改的值。 必须初始化值，否则会报错。 需要注意的是：const 变量不能再被重新赋值为其他引用值，但对象的键不受限制 也就是说，并不是变量的值不能改动，而是变量指向的那个内存地址不得改动 const obj1 = &#123;&#125;obj1 = &#123;&#125; // 报错，不能给常量赋值const obj2 = &#123; name: &quot;jack&quot; &#125;obj2.name = &quot;tony&quot; // 没问题 5. 暂时性死区？ 如果区块中存在 let 和 const 命令，以这个命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错 总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”(temporal dead zone 简称 TDZ ) if (true) &#123; // TDZ 开始 tmp = &quot;abc&quot;; console.log(tmp); // 报错 let tmp; // TDZ 结束 console.log(tmp) tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的死区 6. 在 for 循环中使用 var，let 的区别 for(var i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 输出全是10// 因为 i 是全局变量，最后访问的都是全局变量 for(let i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 0123456789; // i 是局部变量，每次循环改变的是对局部变量赋值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"04_实现call_apply_bind","slug":"手写call-apply-bind","date":"2022-03-30T11:49:46.000Z","updated":"2022-03-31T10:56:01.119Z","comments":true,"path":"2022/03/30/手写call-apply-bind/","link":"","permalink":"https://hillyee.github.io/2022/03/30/%E6%89%8B%E5%86%99call-apply-bind/","excerpt":"","text":"call、apply、bind 实现 1. call 实现 首先我们要知道系统的 call 方法主要实现了什么 执行了函数 改变了 this 的指向 先看系统的call方法 function foo() &#123; console.log(&quot;foo函数被执行&quot;, this);&#125;function sum(num1, num2) &#123; console.log(&quot;sum函数被执行&quot;, this); return num1 + num2&#125;// 1. 传入对象foo.call(&#123;&#125;) // 2. 传入null/undefinedfoo.call(null) // this自动替换为指向全局对象// 3. 传入其他，字符串，数字，布尔值等等foo.call(&quot;abc&quot;) // this 指向相应的对象let res = sum.call(&quot;123&quot;, 10,20)console.log(res) // 30 接下来我们开始实现自己的call（主要是实现思路，没有把所有的边缘条件考虑完全，但是基本都有） 1.1 让函数执行起来 Function.prototype.mycall = function() &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着让函数执行起来 fn() // 但是这里是独立函数调用，this指向window&#125;foo.mycall() // 这里相当于mycall隐式绑定了foo,因此 mycall中的this就是foo 2.2 显式绑定this 现在我们要绑定我们指定的this 先看第一种：foo.mycall(&#123;name: 'hello'&#125;)，绑定一个对象 Function.prototype.mycall = function(thisArg) &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着调用这个函数 // 我们的目的是让函数执行的时候绑定thisArg这个对象执行即thisArg.fn()(隐式绑定) // 但是现在 thisArg没有 fn 这个属性呀，怎么调用呢 // 所以我们可以给thisArg添加一个属性 fn, 值就是我们想要执行的函数 thisArg.fn = fn // 然后再调用 thisArg.fn() // 但是这样我们不就让thisArg多出来一个属性fn了吗？ // 没关系，函数执行完 删掉就好 delete thisArg.fn&#125; 如果我们传入的不是对象呢？那就不能给thisArg添加属性啦 foo.mycall(&quot;123&quot;) Function.prototype.mycall = function(thisArg) &#123; let fn = this // 所以要把 thisArg 转成对象类型(Object构造函数可以将给定的值包装为一个新对象) thisArg = Object(thisArg) thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 如果传入的是 null / undefined 呢 Function.prototype.mycall = function(thisArg) &#123; let fn = this // 如果thisArg传入的是 undefined / null, 应该让它指向全局对象 // 所以我们要做一个判断 thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 2.3 接下来要考虑参数了 // rest运算符// ...args 会把我们传入的参数列表组合到一个数组 [num1,num2]// ...args 也可以展开数组, 相当于对数组的一个遍历Function.prototype.mycall = function(thisArg, ...args) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 把参数传入函数，并用 result 接收函数执行完的结果(例子中就是sum函数执行完的结果) let result = thisArg.fn(...args) // ...[num1, num2] --&gt; num1, num2 delete thisArg.fn // 最后把结果返回出去 return result&#125; 到此，基本的call就已经实现了 检验一下叭 foo.mycall(&#123;name: &#x27;hello&#x27;&#125;)foo.mycall(&quot;123&quot;)foo.mycall(undefined)foo.mycall(null)sum.mycall(&#123;name: &quot;hello&quot;&#125;, 10, 20)let res1 = sum.mycall(123, 10, 20)console.log(res1); 2. apply 实现 跟 call 类似，只不过参数的处理有不同 Function.prototype.myapply = function(thisArg, argsArray) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 没有传argArray,那么argsArray默认为 undefined,那么就不能使用展开运算符了 // 所以如果没有传入参数, 那么把它初始化为 [], 空数组也是可以展开的 ...[] argsArray = argsArray || [] let result = thisArg.fn(...argsArray) delete thisArg.fn return result&#125; 3. bind 实现 bind 需要我们返回一个新的函数，并且调用 bind 的时候不需要执行函数 Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn() &#123; thisArg.fn = fn let result = thisArg.fn(...args) delete thisArg.fn // 返回结果 return result &#125; // bind 需要返回一个新的函数 你也可以直接 return function() &#123;...&#125; return newFn&#125; 大体上也差不多，但我们可以就下面这种情况改进一下 function sum2(num1, num2, num3, num4) &#123; console.log(&quot;sum2函数被执行&quot;, this); return num1 + num2 + num3 + num4&#125;let newSum2 = sum2.mybind(&quot;abc&quot;, 10,20) // 绑定的时候传入了两个参数console.log(newSum2(30,40)); // 使用新返回的函数的时候再传入剩余的参数 这种情况，我们就需要把两次传入的参数合并起来，再调用 Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn(...newArgs) &#123; // 合并传入的参数 let allArgs = [...args, ...newArgs] thisArg.fn = fn let result = thisArg.fn(...allArgs) delete thisArg.fn // 返回结果 return result &#125; return newFn&#125; 到此，基本的bind也实现了 最后说明一下，实现的思路是这样，但是方法不唯一的，可能还有一些边边角角没有考虑到的话，可以自己添加进去","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"03_JS函数的this指向","slug":"JS函数的this指向","date":"2022-03-30T10:50:46.000Z","updated":"2022-03-31T10:55:50.068Z","comments":true,"path":"2022/03/30/JS函数的this指向/","link":"","permalink":"https://hillyee.github.io/2022/03/30/JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/","excerpt":"","text":"JS 函数的 this 指向 1. this 在全局作用域下的指向 在浏览器中，this在全局作用域下指向 window console.log(this) // windowvar title = &quot;hello&quot;console.log(this.title) // helloconsole.log(window.title) // hello 2. this 的四个绑定规则 2.1 规则一：默认绑定 在独立函数调用的情况下会使用默认绑定 独立函数调用简单来说就是它没有绑定到某个对象上进行调用，简单看几个例子 // 例1function foo() &#123; console.log(this)&#125;foo() // window // 例2function foo1() &#123; console.log(this);&#125;function foo2() &#123; foo1()&#125;function foo3() &#123; foo2()&#125;foo3() // window // 例3var obj = &#123; name: &#x27;hello&#x27;, foo: function() &#123; console.log(this); &#125;&#125;var bar = obj.foobar() // window 以上的函数调用的时候，都是没有被绑定到对象中调用的，所以 this 都指向 window 2.2 规则二：隐式绑定 函数通过某个对象进行调用的时候，这个对象会被 js 引擎绑定到函数中的 this 里 下面看几个例子： // 1.function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, fn: foo&#125;obj.fn() // obj 对象 // 2.var obj1 = &#123; foo: function() &#123; console.log(this); &#125;&#125;var obj2 = &#123; title: &#x27;hello&#x27;, bar: obj1.foo&#125;obj2.bar() // obj2对象 2.3 显式绑定 利用 call，apply，bind手动指定 this 的绑定，这种明确的绑定称为显示绑定 (1) call，apply call，apply 都是可以调用函数的 fn.call(自定的this指向，参数1，参数2) fn.apply(this指向，[参数1，参数2]) 两者的区别在于传参的方式，下面例子可以看出来 call 传入参数列表，apply是数组 function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;var obj = &#123; title: &quot;hello&quot;&#125;sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;sum.apply(obj, [20,30,40]) // 手动让this指向obj (2) bind bind不会调用函数，而是返回一个新的对象。 function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;// var obj = &#123;// title: &quot;hello&quot;// &#125;// sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;// sum.apply(obj, [20,30,40]) // 手动让this指向objvar newSum = sum.bind(&#x27;aaa&#x27;,10,20,30)newSum() // 60 String &#123;&#x27;aaa&#x27;&#125; 咦？newSum 不也是独立函数调用吗，怎么不指向 window 了 这就是默认绑定和显示绑定bind的冲突，显示绑定的优先级更高！ 2.4 new绑定 function Person(name, age) &#123; this.name = name this.age = age // 实际上这里是会把 this 返回出去的,即return this（默认） // this = 创建出来的对象&#125;// new 会创建一个全新的对象var p1 = new Person(&quot;jenny&quot;, 12)var p2 = new Person(&quot;tony&quot;, 15) 3. 一些内置函数的 this 绑定 有时候我们会调用一些 JS 的内置函数，这些函数要求我们传入另外一个函数，并且我们不会自己去调用这些函数，而是 JS 内部会帮助我们执行。 这个时候，this 的绑定就跟内部帮我们指向函数的方式有关系了。 看几个例子吧 3.1 setTimeout 内部通过 apply 调用函数，并绑定了this对象，是window setTimeout(function() &#123; console.log(this); // window&#125;, 2000) 3.2 数组的内置函数 forEach 默认情况下传入的函数是自动调用函数（默认绑定） var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 window&#125;) 也可以通过传入第二个参数，改变this指向 var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 &#x27;obj&#x27;&#125;, &#x27;obj&#x27;) 3.3 点击事件 在发生点击时，回调函数被调用，会将 this 绑定到该函数中 &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; var box = document.querySelector(&quot;.box&quot;)box.onclick = function() &#123; console.log(this); // box对象&#125; 所以说，某些内置的函数，我们很难确定它内部是如何调用传入的回调函数的，可以自己测试一下，记一下，看源码当然更好啦 4. 几个规则的优先级 从高到低：new绑定 &gt; 显式绑定(bind) &gt; 隐式绑定 &gt; 默认绑定 new绑定和call，apply是不允许同时使用的，（毕竟都会调用函数），所以不存在谁的优先级更高 显示绑定高于隐式绑定 // 显式绑定和隐式绑定function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;obj&#x27;, foo: foo&#125;obj.foo() // obj 对象obj.foo.call(&quot;aaa&quot;) // &#x27;aaa&#x27; new 绑定高于隐式绑定 function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, foo: foo&#125;new obj.foo() // 输出 foo 对象而不是 obj new 绑定高于bind function foo() &#123; console.log(this, title);&#125;var obj = &#123; name: &#x27;hello&#x27;&#125;var bar = foo.bind(obj) // 显式绑定objnew bar() // 打印 foo对象 而不是 obj 5. 两种特殊情况 5.1 在显示绑定中传入 null 或 undefined 这时候，显示绑定会被忽略，使用默认规则 function foo() &#123; console.log(this);&#125;var obj = &#123; name: &quot;hello&quot;, foo: foo&#125;foo.call(obj) // objfoo.call(null) // windowfoo.call(undefined) // window 5.2 间接函数引用 function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;// 先来看一下这个赋值的结果, 是 foo 函数console.log((obj2.foo = obj1.foo)); // foo函数// 这种叫做间接函数引用，是会把赋值语句右边的结果返回，然后直接调用，是独立函数调用(obj2.foo = obj1.foo)() // 相当于直接调用 foo 函数，所以是默认绑定，输出window 6. 箭头函数的this 箭头函数不绑定 this，也就是说它没有自己的 this，而是根据外层作用域来决定this var name = &quot;hello&quot;var foo = () =&gt; &#123; console.log(this); // 在这里this的外层作用域就是 window&#125;var obj = &#123; foo: foo&#125;obj.foo() // windowobj.foo.call(&quot;aaa&quot;) // window 再来看一个案例： 使用setTimeout模拟一个网络请求，如果我们想把返回来的数据保存到 data 中，该怎么做 var obj = &#123; data: &#x27;&#x27;, getData: function() &#123; setTimeout(() =&gt; &#123; console.log(this); // obj 对象 // 这里的 this 不是应该指向window吗？ // 如果我们这里使用的是普通的函数 function() &#123;console.log(this)&#125; // 那么这个函数在内部调用的时候，会绑定this，就是window // 但是我们使用了箭头函数，它不绑定this，会往上层作用域中找到对应的this // 所以找到了 obj this.data = &#x27;hello&#x27; // --&gt; obj.data = &quot;hello&quot; &#125;, 2000); &#125;&#125;obj.getData() 7. this 的面试题 如果每题都会了，那么 this 绑定的问题，就是你的送分题而不是送命题了哈哈哈 建议把我的答案跟注释都删掉，自己一点点理清哦 题一 var name = &quot;window&quot;; // window.name = &quot;window&quot;var person = &#123; name: &quot;person&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;;function sayName() &#123; var sss = person.sayName; sss(); // window 很明显是独立函数调用,没有与任何对象关联 person.sayName(); // person 隐式绑定,与person关联 (person.sayName)(); // person 同上(加括号只是代表这是一个整体) // console.log((b = person.sayName)); // 这里实际上就是sayName这个函数 (b = person.sayName)(); // 间接函数引用，是独立函数调用, 输出 window&#125;sayName(); 题二 var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;// 隐式绑定person1对象person1.foo1(); // person1// 显式绑定person2person1.foo1.call(person2); // person2// 箭头函数不适用任何规则, 向上层作用域中找thisperson1.foo2(); // windowperson1.foo2.call(person2); // window// person1.foo3()返回了一个函数，然后独立调用person1.foo3()(); // window// person1.foo3.call(person2) 返回的是一个函数，然后独立调用person1.foo3.call(person2)(); // window// person1.foo3()返回一个函数，然后显式绑定到 person2person1.foo3().call(person2); // person2// person1.foo4()返回一个箭头函数，往上层作用域找，找到foo4中绑定的this,是 person1person1.foo4()(); // person1// foo4显示绑定到 person2person1.foo4.call(person2)(); // person2// person1.foo4()返回箭头函数，往上层作用域找person1.foo4().call(person2); // person1 题三 var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.foo1 = function () &#123; console.log(this.name) &#125;, this.foo2 = () =&gt; console.log(this.name), this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() // person1 隐式绑定person1.foo1.call(person2) // person2 显式绑定person1.foo2() // person1 隐式绑定// 箭头函数不适用显式绑定规则，直接向上层作用域找person1.foo2.call(person2) // person1 // person1.foo3() 返回一个函数，在全局调用person1.foo3()() // windowperson1.foo3.call(person2)() // window // 同理// person1.foo3() 返回的函数使用 .call 显式绑定 person2person1.foo3().call(person2) //person2 // person1.foo4() 返回一个箭头函数，再调用，向上层作用域找person1.foo4()() // person1// person1.foo4.call(person2) 返回箭头函数，并且foo4显式绑定this为person2// 再调用这个箭头函数，向上找就找到 foo4 的this 为person2person1.foo4.call(person2)() // person2 // person1.foo4() 返回箭头函数,不适用显式绑定，向上找到 person1// 注意这里跟上面的区别，这里的foo4调用不是.call调用的，而是.foo4()这样调用的// call是来调用箭头函数的，而箭头函数不适用显式绑定，向上找到的是person1person1.foo4().call(person2) // person1 题四 var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)// person1.obj.foo1()返回一个函数，在全局中调用person1.obj.foo1()() // window// person1.obj.foo1.call(person2) 返回一个函数 在全局中调用person1.obj.foo1.call(person2)() // window// person1.obj.foo1() 返回一个函数，显式绑定person2person1.obj.foo1().call(person2) // person2// 箭头函数调用，向上找到 foo2 中的this是objperson1.obj.foo2()() // obj// foo2调用的时候显式绑定person2，箭头函数向上层找到的就是person2person1.obj.foo2.call(person2)() // person2// 箭头函数不适用 显式绑定，向上找找到 objperson1.obj.foo2().call(person2) // obj","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"02_JS内存管理和闭包","slug":"JS内存管理和闭包","date":"2022-03-30T10:49:50.000Z","updated":"2022-03-31T10:55:36.994Z","comments":true,"path":"2022/03/30/JS内存管理和闭包/","link":"","permalink":"https://hillyee.github.io/2022/03/30/JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"一、JS 的内存管理 1. JS 的内存管理 JavaScript 会在定义变量时为我们分配内存 内存分配的方式是一样的吗？ JS 对于基本数据类型内存的分配，会在执行时直接在栈空间进行分配 JS 对于复杂数据类型内存的分配，会在堆内存中开辟一块空间，并且将这块空间的地址保存在栈空间 2. JS 的垃圾回收 垃圾回收的英文是 Garbage Collection，简称 GC 对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放出更多的内存空间 JavaScript的运行环境 js引擎都会内存垃圾回收器 3. 常见的两个 GC 算法 GC怎么知道哪些对象是不再使用的呢？这里就要用到 GC 算法了 3.1 引用计数 当一个对象有一个引用指向它的时候，那么这个对象的引用就 +1，当一个对象的引用为 0 时，这个对象就可以被回收掉 但是这个算法有一个很大的弊端，就是会产生循环引用 var obj1 = &#123;friend: obj2&#125;var obj2 = &#123;friend: obj1&#125; 3.2 标记清除 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象 ​ 图中从 A 开始找，找到 D 的时候结束，M,N不可达，被认为是不可用的对象 这个算法可以很好的解决循环引用的问题 注：JS 引擎比较广泛采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，在算法的实现细节上也会结合一些其他的算法 二、JS中的闭包 1. 什么是闭包？ JavaScript 中的一个函数，如果它访问了外层作用域的变量，那么这个函数是一个闭包。 MDN中的一个解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） function foo() &#123; var name = &quot;foo&quot; var age = 18 function bar() &#123; console.log(name)// name访问了外层作用域的变量name console.log(age) // age访问了外层作用域的变量age &#125; return bar // 返回一个函数&#125;var fn = foo()fn() 2. 闭包的访问过程 简单描述上面函数的执行过程： 1. GO: &#123;foo:地址1, fn:undefined&#125;2. 执行代码： 2.1 foo():只要执行函数，就会创建一个函数执行上下文 (1)VO: &#123;AO对象:&#123;name: undefined;age:undefined;bar:地址2&#125;&#125; scopechain:[VO+parent scopes] (2)开始执行代码 &#123;name: &quot;foo&quot;, age:18;&#125; return bar地址2 (3)foo执行完毕 2.2 fn: bar地址2 2.3 fn(),即执行 bar地址2中的函数执行体,创建bar的函数执行上下文 (1)&#123;AO:&#123;&#125;,scopechain&#125; (2)执行代码: console.log(name):在自己的AO中找不到，通过作用域链找到foo的AO，找到name:&quot;foo&quot;,输出 &quot;foo&quot; console.log(age)同理 (3)fn()执行完毕3.执行完毕地址1:foo函数对象: &#123;parentScope: GO&#125;,&#123;foo函数的执行体&#125;地址2:bar函数对象: &#123;parentScope: foo的AO对象&#125;,&#123;bar函数的执行体&#125; 你可能会有疑惑：foo函数执行完毕之后，不是应该弹出栈吗，foo的AO对象不应该被释放了吗？怎么bar还能找到 name，找到 age 呢？ 看下图： 可以看到，当我们执行完 foo 函数的时候，返回的是 bar 函数(或者说是bar的地址)，然后因为 fn = foo()，把这个地址赋值给了fn，因此会存在 fn 指向 bar函数对象，而bar的父作用域又指向了 foo 的AO对象，因此foo的AO是不会被释放的 3. 闭包的内存泄漏 为什么总说闭包是有内存泄漏的呢？什么是内存泄漏？ 拿上面的例子说，如果后续我们不会再用 foo，bar 这些函数了，但是在全局作用域下 fn 变量对bar函数对象有引用，而bar的作用域中AO对foo的AO有引用，所以会造成这些内存都是无法被释放的。 这就是我们所说的内存泄漏，其实就是刚才的引用链中的对象无法释放 怎么解决这个问题呢？ 很简单，设置 fn = null，就不再对 bar 函数对象有引用，那么从GO出发，bar是不可达的，那么对应的AO对象(foo) 同样也就不可达。 在下一次 GC 的的检测中，它们就会被销毁掉 还有一个问题，形成闭包之后，是不是所有的属性都不会被释放呢？ 还是这个例子 function foo() &#123; var name = &quot;why&quot; var age = 18 function bar() &#123; console.log(name) // console.log(age) &#125; return bar&#125;var fn = foo()fn() 如果age不使用了，会不会被销毁掉呢？ 答案是会的，测试如下： 这是因为 V8 引擎做的优化，因为规范中闭包的属性应该是不会被销毁的","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"01_深入JS运行原理","slug":"深入JS运行原理","date":"2022-03-30T10:49:46.000Z","updated":"2022-03-31T10:46:03.508Z","comments":true,"path":"2022/03/30/深入JS运行原理/","link":"","permalink":"https://hillyee.github.io/2022/03/30/%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"1. 从输入 URL 到页面展示 发生了什么？ 总体分为以下过程： DNS 域名解析：将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 2. 浏览器工作原理 在浏览器中输入查找内容，浏览器是怎样将页面加载出来的？ 大致流程如下： 首先，用户输入服务器地址，与服务器建立连接 服务器返回对应的静态资源（index.html） 然后浏览器拿到 index.html 后进行解析 当解析时遇到 css 或 js 文件，就向服务器请求并下载对应的 css 和 js 文件 最后浏览器对页面进行渲染，执行 js 代码 3. 浏览器渲染过程 HTML Parser 将 HTML解析转换成 DOM 树 CSS Parser 将 样式表转换成 CSS 规则树 合并 DOM 树和 CSS 规则树，生成 render（渲染） 树 布局 render 树（Layout） 通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 绘制 render 树（painting），进行 Display 展示 注意图中顶部的紫色 DOM 三角形，实际上是 js 对 DOM 的相关操作。 4. 一个强大的 JavaScript 引擎 — V8 引擎 在解析 HTML 的过程中，遇到了 JavaScript 标签，该怎么办呢？ 会停止解析 HTML ，而去加载和执行 JavaScript 代码 那么，JavaScript 代码由谁来执行呢？ JavaScript 引擎 高级的编程语言最终都要转成机器指令来执行的， 所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行 （1）V8 引擎的架构 V8 的底层架构主要有三个核心模块（Parse、Ignition、TurboFan） 1. Parse： 该过程主要是对 JavaScript 源代码进行词法分析和语法分析。 词法分析：对代码中的每一个词每一个符号进行解析，最终生成很多 tokens 例如：对 const name = “curry” // 首先对const进行解析，因为const为一个关键字，所以类型会被记为一个关键词，值为consttokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;]// 接着对name进行解析，因为name为一个标识符，所以类型会被记为一个标识符，值为nametokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;, &#123; type: &#x27;identifier&#x27;, value: &#x27;name&#x27; &#125;]// 以此类推... 语法分析：在词法分析的基础上，拿到 tokens 中的一个个对象，根据不同类型，再进一步分析具体语法，最终生成 AST 抽象语法树 可以详细查看通过 Parse 转换后的 AST 的工具：AST Explorer 2. Ignition 一个解析器，可以将 AST 转换成 ByteCode（字节码） 3. TurboFan 一个编译器，可以将字节码编译为 CPU 认识的机器码 （2）V8 引擎的执行过程 Blink 内核将 JS 源码交给 V8 引擎 Stream 获取到 JS 源码进行编码转换 Scanner 进行词法分析，将代码转换成 tokens Parser 和 PreParser Parser ：直接解析，将 tokens 转成 AST 树 PreParser：预解析，对不必要的函数进行预解析，也就是只解析暂时需要的内容，而在函数被调用时才进行函数的全量解析 生成 AST 树后，会被 Ignition 转成字节码，之后就是代码的执行过程 5. JavaScript 的执行过程 假如要执行如下代码： var title = &quot;hello&quot;console.log(num1)var num1 = 20var num2 = 30var result = num1 + num2console.log(result) （1）首先，代码被解析，V8 引擎内部会帮助我们创建一个全局对象：Global Object（GO） GO 可以访问所有的作用域 里面会包含 Date、Array、String、setTimeout等等（所以我们可以直接 new Date() ） GO 还有一个window 属性指向自己（所以window.window.window还是指向 GO自己） 用伪代码表示为： var globalObject = &#123; String: 类, setTimeout: 函数, ... window: globalObject&#125; （2）然后运行代码 首先我们要知道 js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ESC），它是用于执行代码的调用栈。 为了全局代码能够正常执行，首先需要创建一个**全局执行上下文 **（Global Execution Context，简称GEC），全局代码需要被执行时才会创建 然后全局执行上下文会被放入执行上下文栈中执行，包含两个部分： 在代码执行前，会将全局定义的变量，函数等加入到 GlobalOject 中，但是并不会赋值（也称为变量的作用域提升） 开始依次执行代码： title = “hello” // 赋值 console.log(num1) // undefined, 不会报错 num1= 20 … 遇到函数如何执行? 先根据函数体创建一个函数执行上下文，并且压入到执行上下文栈中 作用域链？ 由 VO(变量对象，在函数中就是 AO 对象)和 父级 VO组成，查找时会一层层查找 看一个例子： var message = &quot;Hello Global&quot;function foo() &#123; console.log(message) // Hello Global&#125;function bar() &#123; var message = &quot;Hello Bar&quot; foo()&#125;bar() 比如说这里，当执行 foo 函数的时候， foo 的 AO 中没有message，就会去它的父级 VO 中查找。一定要注意！当第一次代码解析的时候， foo 的函数执行上下文就已经确定了，其中包括三部分： 第一部分：在解析函数成为 AST 树结构的时候，会创建一个 AO（Activation） 其中包含形参、arguments、函数定义、指向函数对象或定义的变量 第二部分：就是作用域链 第三部分：this 绑定的值 因此！当foo在自己的AO找不到message的时候，去父级 VO 找，这个父级 VO 就是一开始解析时候保存的 GO，所以message为 “Hello Global” 简单描述一下这个过程吧：(我不专业的表达) // 初始化 GOGO: &#123;window; message:undefined; foo: 地址1; bar: 地址2;&#125;// 执行代码GO: &#123;window; message:&quot;Hello Global&quot;; foo: 地址1; bar: 地址2;&#125;bar函数执行,创建一个函数执行上下文, 其中包括 VO对象: AO:&#123;message: undefined&#125; 然后开始执行 bar函数 message:&quot;Hello Bar&quot; (赋值) foo() foo函数执行，创建一个foo的函数执行上下文 其中包括：VO: AO: &#123;&#125; 然后开始执行代码 console.log(message) 发现自己的AO没有message,会向上找，即从自己保存的父级VO中查找，找到GO中的message为 &quot;Hello Global&quot; (图来源于coderwhy) 几道常见的作用域提升面试题： var n = 100 function foo() &#123; n = 200 &#125; foo() console.log(n) // 200 2. ```js function foo() &#123; console.log(n) // undefined var n = 200 console.log(n) // 200 &#125; var n = 100 foo() var a = 100 function foo() &#123; console.log(a) // undefined return var a = 200 &#125; foo() 4. ```js function foo() &#123; m = 100 &#125; foo() console.log(m) // 100 function foo() &#123; var a = b = 10 // =&gt; 转成下面的两行代码 // var a = 10 // b = 10 &#125; foo() //console.log(a) // 报错 a is not defined(因为当 foo函数执行完之后，foo的函数执行上下文就会弹出栈(没啦！哪里还会有a呢)) console.log(b) // 10","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-29T14:25:03.367Z","updated":"2022-03-29T14:25:03.367Z","comments":true,"path":"2022/03/29/hello-world/","link":"","permalink":"https://hillyee.github.io/2022/03/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"深入Vue3+Typescript学习","slug":"深入Vue3-Typescript学习","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"},{"name":"面试题-js篇","slug":"面试题-js篇","permalink":"https://hillyee.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"},{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"难","slug":"难","permalink":"https://hillyee.github.io/tags/%E9%9A%BE/"},{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]}
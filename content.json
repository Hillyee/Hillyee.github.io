{"meta":{"title":"Hillyee-blog","subtitle":"","description":"","author":"Hillyee","url":"https://hillyee.github.io","root":"/"},"pages":[{"title":"About","date":"2022-03-30T15:53:22.543Z","updated":"2022-03-30T15:53:22.543Z","comments":false,"path":"about/index.html","permalink":"https://hillyee.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-03-30T10:42:50.892Z","updated":"2022-03-30T10:42:50.892Z","comments":false,"path":"tags/index.html","permalink":"https://hillyee.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-30T05:15:58.514Z","updated":"2022-03-30T05:15:58.514Z","comments":false,"path":"repository/index.html","permalink":"https://hillyee.github.io/repository/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-03-30T15:45:28.276Z","updated":"2022-03-30T15:45:28.276Z","comments":false,"path":"categories/index.html","permalink":"https://hillyee.github.io/categories/index.html","excerpt":"","text":"categories111"}],"posts":[{"title":"08_JS面向对象","slug":"08-JS面向对象","date":"2022-04-02T08:37:13.000Z","updated":"2022-04-02T08:41:12.684Z","comments":true,"path":"2022/04/02/08-JS面向对象/","link":"","permalink":"https://hillyee.github.io/2022/04/02/08-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"深入JS面向对象 面向对象初识 创建对象的方式 // 方式一：通过new Object()创建var obj = new Object()obj.name = &quot;hill&quot;obj.age = 18obj.running = function() &#123; console.log(this.name + &quot; is running&quot;);&#125;// 方式二：字面量形式var info = &#123; name: &#x27;hill&#x27;, age: 18, eating: function() &#123; console.log(this.name + &#x27;is&#x27; + this.age); &#125;&#125; 对属性的操作 var obj = &#123; name: &quot;yuzi&quot;, age: 18&#125;// 1.获取属性console.log(obj.name); // yuzi// 2.给属性赋值obj.name = &quot;jackson&quot;console.log(obj.name); // jackson// 3.删除属性// delete obj.name// console.log(obj); // &#123;age: 18&#125;// 4.遍历属性for (var key in obj) &#123; console.log(key); // name age&#125; 这种直接定义在对象内部或者直接添加到对象内部的属性，我们不能对其做出限制：比如这个属性是否可以通过delete删除，是否可以在for-in遍历的时候被遍历出来 Object.defineProperty() 如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符 通过属性描述符可以精准的添加或修改对象的属性 属性描述符需要使用 Object.defineProperty 来对属性进行添加或修改 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象 接收三个参数 obj:要定义属性的对象 prop: 要定义或修改的属性的名称或Symbol descriptor：要定义或修改的属性描述符 第三个参数的属性描述符分为两类： 数据属性描述符 configurable，enumerable，writable，value // 直接在一个对象上定义某个属性时，描述符的默认值为// value: 赋值的value// configurable: true// enumerable: true// writable: truevar obj = &#123; name: &#x27;jackson&#x27;, age: 18&#125;Object.defineProperty(obj, &quot;height&quot;, &#123; value: 1.88, // 属性值(默认为 undefined) enumerable: true, // 对应属性是否可以枚举(默认为false) writable: true, // 是否可以修改属性值(默认为false) configurable: true, // 属性能否被删除(默认为false),属性的描述符能否被改变&#125;)// 枚举for(var key in obj) &#123; console.log(key); // name age height 可枚举&#125;console.log(Object.keys(obj)); // [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;height&#x27; ] 可枚举// 修改属性值obj.height = 2console.log(obj.height); // 2 可修改// 删除属性delete obj.heightconsole.log(obj.height); // undefined 删除成功 存取属性描述符 enumerable，configurable，get，set 不用value,writable，而是用 get,set var obj = &#123; name: &#x27;jackson&#x27;, age: 18, _address: &quot;广东&quot; &#125;// 私有属性，js里面是没有严格意义的私有属性的，所以我们实际上也能直接访问，但是在社区人们约定 下划线_开头的属性定义为私有属性// 1.隐藏某一个私有属性(address)不希望直接被外界使用和赋值// 2.如果我们希望截获某个属性被访问和设置值的过程时，也会使用存储属性描述符Object.defineProperty(obj, &quot;address&quot;, &#123; enumerable: true, // 可枚举 configurable: true, // 可删除，可修改描述符 get: function() &#123; console.log(&quot;获取了一次address的值&quot;) return this._address &#125;, set: function(value) &#123; console.log(&quot;设置了address的值&quot;) this._address = value &#125;&#125;)console.log(obj.address); // 广东 可枚举属性的补充 var obj = &#123; name: &quot;why&quot;, age: 18&#125;Object.defineProperty(obj, &quot;address&quot;, &#123; value: &quot;北京市&quot;&#125;)console.log(obj)// address属性默认是不可枚举的，但是我们在浏览器上面是可以看到的（稍微浅色一点），这是浏览器为了方便我们调试做的处理 Object.defineProperties() Object.defineProperties() 方法可以直接在一个对象上定义多个新的属性 var obj = &#123; _age: 18&#125;Object.defineProperties(obj, &#123; name: &#123; writable: true, value: &#x27;jackson&#x27; &#125;, age: &#123; get: function() &#123; return this._age &#125; &#125;&#125;) 对象方法补充(了解) 获取对象的属性描述符 getOwnPropertyDescriptor getOwnPropertyDescriptors 禁止对象扩展新属性 preventExtensions：给一个对象添加新的属性会失败(在严格模式下会报错) 密封对象，不允许配置和删除属性：seal 实际是调用preventExtensions 并且将现有属性的configurable:false 冻结对象，不允许修改现有属性：freeze 实际上是调用seal 并且将现有属性的writable: false 创建多个对象的方式 通过想要创建多个对象的目的，来引出后面的构造函数 前面我们通过 new Object，字面量的方式创建对象，但是这两种方式有一个很大的弊端： 创建同样的对象时，需要编写重复代码 比如说字面量： var p1 = &#123;name: , age: &#125;var p2 = &#123;name: , age: &#125;var p3 = &#123;name: , age: &#125; // 它们有同样的属性或者方法 创建对象的方式 - 工厂模式 工厂模式其实是一种常见的设计模式 通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象 工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型 但是从某些角度来说，这些对象应该有一个他们共同的类型 function createPerson(name, age, height) &#123; var p = &#123;&#125; // 定义一个对象 p.name = name p.age = age p.height = height p.eating = function() &#123; console.log(this.name + &quot;is eating&quot;); &#125; return p // 把对象返回&#125;var p1 = createPerson(&quot;张三&quot;, 18, 1.88)var p2 = createPerson(&quot;李四&quot;, 20, 1.98)var p3 = createPerson(&quot;王五&quot;, 30, 1.78)// 工厂模式的缺点：获取不到对象最真实的类型console.log(p1, p2, p3); // 我只知道你是一个对象，但我不知道你是person类型 认识构造函数 什么是构造函数？ 构造函数也称之为构造器（constructor），通常我们在创建对象时会调用的函数 JavaScript 中，如果一个普通的函数被使用 new 操作符来调用了，那么这个函数就称之为是一个构造函数 所以说构造函数也是一个普通函数，只不过用 new 去调用，就称为构造函数 new也是可以调用函数的喔 new操作符 如果一个函数被使用new操作符调用了，那么它会执行如下操作： 在内存中创建一个新的对象（空对象） 这个对象内部的 **[[prototype]]**属性会被赋值为该构造函数的 prototype属性 构造函数的 this ，会指向创建出来的新对象 执行函数的内部代码 如果构造函数没有返回非空对象，则返回创建出来的新对象 构造函数创建对象 // 规范：构造函数的首字母一般是大写function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address this.eating = function() &#123; console.log(this.name + &quot;is eating&quot;); &#125; this.running = function() &#123; console.log(this.name + &#x27;is running&#x27;); &#125;&#125;var p1 = new Person(&quot;张三&quot;, 18, 1.88, &#x27;广州&#x27;)var p2 = new Person(&quot;李四&quot;, 20, 1.78, &#x27;北京&#x27;)console.log(p1); // Person &#123;...&#125; 是可以看见类型的console.log(p2); 这个构造函数可以确保我们的对象是有Person的类型的 但是也有缺点：我们需要给每个对象的函数去创建一个函数对象实例（开辟新的内存空间） 对象的原型 [[prototype]] JavaScript 中，每个对象都有一个特殊的内置属性 [[prototype]]，这个属性称之为对象的原型（隐式原型）（只要是对象，就会有这个内置属性） [[prototype]] 指向一个对象（也就是说它也是一个对象） 那么这个对象有什么用呢？ 当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作 这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它 如果对象中没有该属性， 那么会沿着它的原型去查找 [[prototype]] 如果通过字面量直接创建一个对象，那么这个对象也有[[prototype]]这个属性 如何查看这个属性呢 var obj = &#123; name: &quot;jackson&quot;&#125;var info = &#123;&#125;// 创建出来的对象上都有 [[prototype]]属性// 如何查看这个属性？// 早期的ECMA是没有规范如何去查看 [[prototype]]// 给对象中提供了一个属性 __proto__, 可以让我们查看一下这个原型对象(浏览器提供)console.log(obj.__proto__);// [Object: null prototype] &#123;&#125;// 相当于(伪代码)var obj = &#123;name: &#x27;jackson&#x27;, __proto__: &#123;&#125;&#125;// ES5之后提供的Object.getPrototypeOf()查看console.log(Object.getPrototypeOf(obj)); // &#123;&#125;// 例如找 age 这个属性，该对象本身没有，沿着原型查找obj.__proto__.age = 18console.log(obj.age); // 18 函数的原型 prototype 所有的函数都有一个 prototype 属性（显式原型） function Foo() &#123;&#125;// 函数也是一个对象，所以它也是有[[prototype]]隐式属性// 另外，函数还会多出来一个显式原型属性：prototypeconsole.log(Foo.prototype); 再看回new操作符其中的一个步骤： 这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性 也就意味着我们通过 Foo 构造函数创建出的所有对象的 [[prototype]] 都指向 Foo.prototype var f1 = new Foo()var f2 = new Foo()console.log(f1.__proto__ === Foo.prototype); // trueconsole.log(f2.__proto__ === Foo.prototype); // true 创建对象的内存表现 可以看到： 构造函数的 prototype 属性指向该函数的原型对象 原型对象身上有一个 constructor 属性指回构造函数本身 new出来的实例对象 p1，p2 对象身上有 __proto__属性也指向构造函数的原型对象 函数原型上的属性constructor 默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象 function Foo() &#123;&#125;// 1. constructor属性// Foo.prototype这个对象中有一个constructor属性console.log(Foo.prototype); // &#123;&#125; 为什么没看到constructor？// 那换一种方式看console.log(Object.getOwnPropertyDescriptors(Foo.prototype));//打印 // &#123;// constructor: &#123;// value: [Function: Foo],// writable: true, // enumerable: false,// configurable: true// &#125;// &#125;// 可以看到enumerable为false，所以第一种方式不能看到constructor// 既然这样，我们能不能重写这个对象的属性constructor呢？肯定可以呀Object.defineProperty(Foo.prototype, &quot;constructor&quot;, &#123; enumerable: true, //可枚举 configurable: true, // 可删除，描述符可修改 writable: true, // 可写 value: &#x27;hahahha&#x27;&#125;)// 这个时候我们再来直接打印，就可以看到constructor了(被我们改成可枚举了)console.log(Foo.prototype);// &#123; constructor: &#x27;hahahha&#x27; &#125; 我们也可以在prototype上添加自己的属性 Foo.prototype.name = &quot;jackson&quot;Foo.prototype.age = 18Foo.prototype.eating = function() &#123;&#125;// 我们再new对象的时候，这些属性都可以通过实例的原型__proto__找到var f1 = new Foo()console.log(f1.name); // jacksonconsole.log(f1.__proto__); // 打印// &#123;// constructor: &#x27;hahahha&#x27;,// name: &#x27;jackson&#x27;,// age: 18,// eating: [Function (anonymous)]// &#125; 直接修改整个prototype对象（赋值，新开内存空间） Foo.prototype = &#123; constructor: Foo, // 让它指回本身(但这样它默认是可枚举的) name: &quot;jackson&quot;, age: 20&#125;var f1 = new Foo()console.log(f1.name); // &quot;jackson&quot;// 为了可以自定属性描述符,真实开发中我们可以通过Object.defineProperty添加constructorObject.defineProperty(Foo.prototype, &quot;constructor&quot;, &#123; enumerable: false, configurable: true, writable: true, value: Foo&#125;) 原来的foo函数的原型对象因为没有对它的引用，会被回收的 创建对象的方式 — 构造函数和原型组合 function Person(name, age, address) &#123; this.name = name this.age = age this.address = address // this.fn = function() // 为了不给每个实例都新开内存空间保存相同的方法，我们不把共同的方法定义在这&#125;// 我们可以把一些公共的方法直接通过原型对象添加Person.prototype.eating = function() &#123; console.log(this.name + &#x27;is eating&#x27;); // 这里的this怎么找到实例对象的？ // 调用函数的时候隐式绑定啊&#125;Person.prototype.running = function() &#123; console.log(this.name + &#x27;is running&#x27;);&#125;var p1 = new Person(&quot;jackson&quot;, 18, &quot;guangdong&quot;)var p2 = new Person(&quot;yuzi&quot;, 18, &quot;beijing&quot;)p1.eating()p2.eating() JavaScript中的类和对象 function Person() &#123;&#125; 在 JS 中，Person应该被称之为是一个构造函数 但是从很多面向对象语言的开发者习惯称之为类，因为类可以帮我们创建出来实例对象，也是可以的 面向对象的特性 - 继承 面向对象有三大特性：封装、继承、多态 封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程 继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中） 多态：不同的对象在执行时表现出不同的形态 JavaScript原型链 原型链的理解 var obj = &#123; name: &quot;jackson&quot;, age: 18&#125;// 当我们&quot;.&quot;的时候就是[[get]]操作// 1.在当前的对象中查找属性// 2.如果没有找到，这个时候会去原型链(__proto__)对象上查找obj.__proto__ = &#123; // address: &quot;广州市&quot;&#125;// 原型链obj.__proto__.__proto__= &#123; // address: &quot;广州市&quot;&#125;obj.__proto__.__proto__.__proto__= &#123; address: &quot;广州市&quot;&#125;console.log(obj.address); // &quot;广州市&quot;// 只要在原型链上都可以找到的 这样一直向上找的话，那么顶层原型究竟是什么呢？ var obj = &#123;name: &quot;Jackson&quot;&#125;// 找到那一层对象之后会停止继续查找呢？console.log(obj.__proto__); // 可以看到字面量obj的原型是 [Object: null prototype] &#123;&#125;// 我们继续往上看看console.log(obj.__proto__.__proto__); // null// 所以我们可以说 [Object: null prototype] &#123;&#125; 就是顶层的原型 顶层对象有什么特别吗？该对象上有很多默认的属性和方法 顶层原型又来自哪里呢？下面我们创建Object对象看看 // 创建一个对象(这种方式相当于下面一种方式的语法糖，本质都是创建一个对象)var obj1 = &#123;&#125; var obj2 = new Object() // 创建了一个对象// 创建对象的话，其中有一步是：将Object函数的显式原型prototype赋值给实例的隐式原型// 相当于这里// Object.prototype = obj2.__proto__// 因此（我们知道这里obj1/2.__proto__已经是到顶层了）console.log(Object.prototype === obj1.__proto__); // trueconsole.log(Object.prototype === obj2.__proto__); // true// Object.prototype也是一个对象，那么它应该也有 __proto__console.log(Object.prototype.__proto__); // null// 因此Object.prototype指向的已经是顶层原型了console.log(Object.getOwnPropertyDescriptors(Object.prototype)) // 有constructor,toString等属性和方法 因此，原型链最顶层的原型对象就是Object的原型对象 也就是说，Object是所有类的父类 function Person(name) &#123; this.name = name&#125;// 看看构造函数Person的原型console.log(Person.prototype);// &#123;&#125; 看不到！应该是不可枚举吧console.log(Object.getOwnPropertyDescriptors(Person.prototype));//输出 &#123;constructor: &#123;...&#125;&#125;console.log(Person.prototype.__proto__);//[Object: null prototype] &#123;&#125; 通过原型链实现继承 为什么需要有继承？ 如果没有继承，我们想创建多个类，类里面的属性和方法很多是一样的，那么我们就会写很多重复的代码，所以主要是为了代码的复用 // Studentfunction Student(name, age, sno) &#123; this.name = name this.age = age this.sno = sno&#125;Student.prototype.running = function() &#123;&#125;// Teacherfunction Teacher(name, age, title) &#123; this.name = name this.age = age this.title = title&#125;Teacher.prototype.running = function() &#123;&#125; 原型链的继承方案 自己画画图更好理解 // 父类：公共属性和方法function Person() &#123; this.name = &quot;Jackson&quot;, this.friends = []&#125;Person.prototype.eating = function() &#123; console.log(this.name + &quot;is eating&quot;);&#125;// 子类：特有属性和方法function Student() &#123; this.sno = 111&#125;// new一个personvar p = new Person()Student.prototype = p var stu = new Student()// console.log(stu.sno); // 111// console.log(stu.name);// Jackson// stu.eating()// 原型链实现继承的弊端：// 1.打印stu对象，继承的属性是看不到的// console.log(stu); // Person &#123; sno: 111 &#125;// 2.创建出来两个stu对象var stu1 = new Student()var stu2 = new Student()// 获取引用，修改引用中的值，会相互影响// 因为这个fre1被加到p对象，而stu1,stu2的__proto__都指向pstu1.friends.push(&quot;fre1&quot;)console.log(stu1.friends); // [ &#x27;fre1&#x27; ]console.log(stu2.friends); // [ &#x27;fre1&#x27; ]// 3. 在前面实现类的过程中都没有传递参数var stu3 = new Student(&quot;jeccy&quot;, 112)// 直接在function Student(name,age)&#123;this.name = name this.age = age&#125;？// 肯定不行啊，我们是想要把name的处理放在Person的 借用构造函数实现继承 // 父类：公共属性和方法function Person(name, age, friends) &#123; this.name = name, this.age = age this.friends = friends&#125;Person.prototype.eating = function() &#123; console.log(this.name + &quot;is eating&quot;);&#125;// 子类：特有属性和方法function Student(name, age, friends, sno) &#123; // 我们在这里调用Person,并把需要Person处理的参数传过去 // this 就是Student的实例 Person.call(this, name, age, friends) // !!! this.sno = sno&#125;// new一个personvar p = new Person()Student.prototype = p // 解决弊端3var stu1 = new Student(&quot;aaa&quot;, 18, [&#x27;fred1&#x27;], 111)console.log(stu1); // Person &#123; name: &#x27;aaa&#x27;, age: 18, friends: [ &#x27;fred1&#x27; ], sno: 111 &#125; 解决弊端1var stu2 = new Student(&quot;vvv&quot;, 20, [&#x27;fred2&#x27;], 112)stu1.friends.push(&quot;hahaha&quot;)console.log(stu1.friends); // [ &#x27;fred2&#x27; ]console.log(stu2.friends); // [ &#x27;fred1&#x27;, &#x27;hahaha&#x27; ]// 解决弊端2 但是这种方法依然存在弊端： Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person） stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的） 注意：直接将父类原型赋值给子类，以后给某个子类添加方法的时候，会使所有的子类都有该方法，显然是不行的 因为所有子类的prototype都指向同一个父类的原型 原型式继承函数 - 对象 我们先实现对象的继承，后面再扩展到类 var obj = &#123; name: &quot;Jackson&quot;, age: 18&#125;// 原型式继承函数// 这个函数要做到的是，你给我传入的对象，作为新对象的原型function createObject(o) &#123; var newObj = &#123;&#125; // 这个方法是把o设置为newObj的原型 Object.setPrototypeOf(newObj, o) return newObj&#125;// Douglas 的实现(当时还没有setPrototypeOf这个方法)function createObject2(o) &#123; function Fn() &#123;&#125; Fn.prototype = o var newObj = new Fn() // 因此 newObj.__proto__ = Fn.prototype = o return newObj&#125;// 现在，我们想要新建的对象info的原型指向obj（后面扩展到类）// var info = createObject(obj)// 但是 新的ECMA 给我们提供了新的方法：Object.create(obj)// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__// 实际上这个方法跟我们上面的两种实现方法实现的功能是一样的var info = Object.create(obj)console.log(info);// 已经实现了我们的目的console.log(info.__proto__); // &#123; name: &#x27;Jackson&#x27;, age: 18 &#125; Object.create() ：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create 寄生式继承函数（了解） 寄生式继承的思路是结合原型类继承和工厂模式的一种方式 即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回 var personObj = &#123; running: function() &#123; console.log(&#x27;running&#x27;); &#125;&#125;// 目的：继承 personObj里面的方法function createStudent(name) &#123; var stu = Object.create(personObj) stu.name = name stu.studying = function() &#123; console.log(&quot;studying&quot;); &#125; return stu&#125;var stuObj = createStudent(&quot;why&quot;) 寄生组合式继承(最终方案) 利用寄生式继承将组合式继承的两个问题解决 首先我们需要明确，当我们在子类的构造函数中调用父类.call(this，参数)的时候，就会将父类的属性和方法复制一份到子类中，所以父类本身里面的内容我们是不需要的 然后，我们还需要获取到一份父类的原型对象中的属性和方法 // 如果不想使用Object.create这个方法的话，我们可以定义前面说过的方法function createObject(o) &#123; function Fn() &#123;&#125; Fn.prototype = o return new Fn()&#125;function inheritPrototype(SubType, SuperType) &#123; // SubType.prototype = Object.create(SuperType.prototype) SubType.prototype = createObject(SuperType.prototype) // 当然prototype还需要有constructor // 而且控制台打印出来的 类型的名称，实际上就是constructor.name // 也就是constructor指向的那个构造函数的名称 // 所以我们这里要添加constructor的value指向子构造函数本身 Object.defineProperty(SubType.prototype, &quot;constructor&quot;, &#123; enumerable: false, configurable: true, writable: true, value: SubType &#125;)&#125;// 父类function Person(name, age, friends) &#123; this.name = name this.age = age this.friends = friends&#125;Person.prototype.running = function() &#123; console.log(&quot;running~&quot;)&#125;// 子类function Student(name, age, friends, sno) &#123; Person.call(this, name, age, friends) // 获取一份Person中的属性和方法 this.sno = sno&#125;// Student类还需要获取一份父类的prototype的属性和方法inheritPrototype(Student, Person)var stu = new Student(&quot;why&quot;, 18, [&quot;kobe&quot;], 111)console.log(stu); // 打印 Student &#123; name: &#x27;why&#x27;,age: 18,friends: [ &#x27;kobe&#x27; ],sno: 111,&#125; JS原型的补充 hasOwnProperty 判断对象是否有某个属于自己的属性，不包括在原型上的 in/ for in 操作符 判断某个属性是否在某个对象或者对象的原型上 var obj = &#123; name: &#x27;jackson&#x27;, age: 18&#125;// 第二个参数是info添加属于自己的属性var info = Object.create(obj, &#123; address: &#123; value: &quot;北京&quot;, enumerable: true &#125;&#125;)// hasOwnPropertyconsole.log(info.hasOwnProperty(&quot;address&quot;)); // trueconsole.log(info.hasOwnProperty(&quot;name&quot;)); // false// in 操作符: 不管在当前对象还是原型中返回的都是trueconsole.log(&quot;address&quot; in info); // trueconsole.log(&quot;name&quot; in info); // true// for in (包括原型上的属性都可以遍历到)for(var key in info) &#123; console.log(key); // address name age&#125; instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 function Person() &#123;&#125;function Student() &#123;&#125;// 使用前面的寄生组合式继承inheritPrototype(Student, Person)console.log(Person.prototype.__proto__); // [Object: null prototype] &#123;&#125;var stu = new Student()// stu是否出现在构造函数 Student 的原型链上console.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // trueconsole.log(stu instanceof Object); // true isPrototypeOf(了解) 用于检测某个对象，是否出现在某个实例对象的原型链上 var info = Object.create(obj)// obj是否出现在info的原型链上console.log(obj.isPrototypeOf(info)) 对象-函数-原型之间的关系 var obj = &#123; name: &quot;jackson&quot;&#125;// 只要是对象，里面就会有一个__proto__对象（隐式原型对象）console.log(obj.__proto__);// [Object: null prototype] &#123;&#125;function Foo() &#123;&#125;// 所有的 function xx() &#123;&#125;// 我们都可以认为 xx 是 new Function 创建出来的// 相当于 var xxx = new Function// 只要是函数，那么它就会有一个显式原型对象：Foo.prototype// 那 Foo.prototype 这个对象又来自哪里呢？// 创建函数的时候，JS内部就会创建一个对象,并添加到函数的prototype属性中：Foo.prototype = &#123;constructor: Foo&#125;// Foo也是一个对象，只要是对象，就会有隐式原型对象 Foo.__proto__// Foo.__proto__来自哪里？// var Foo = new Function() console.log(Foo.__proto__ === Function.prototype); // true// 而 Function.prototype对象是我们创建Function函数的时候创建出来的// Function.prototype = &#123;constructor: Function&#125;// 创建Function函数// function Function() &#123;&#125;// Function.prototype// Function 又是一个对象// Function.__proto__// 唯一一个比较特殊的东西console.log(Function.__proto__ === Function.prototype); // true// 另外还有 function Object() &#123;&#125;// Object作为函数, 就会有Object.prototype// Object作为对象, 就会有Object.__proto__// Object函数是Function创建出来的，所以// Objcet.__proto__ === Function.prototype// 最后就是每个函数的原型prototype都会有一个constructor指回函数本身 最后 上图！","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"V3","slug":"V3","permalink":"https://hillyee.github.io/tags/V3/"}]},{"title":"日常记录","slug":"日常记录","date":"2022-04-02T04:22:13.000Z","updated":"2022-04-02T08:38:34.824Z","comments":true,"path":"2022/04/02/日常记录/","link":"","permalink":"https://hillyee.github.io/2022/04/02/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"","categories":[{"name":"其他","slug":"其他","permalink":"https://hillyee.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"待整理或解决","slug":"待整理或解决","date":"2022-04-02T04:21:08.000Z","updated":"2022-04-02T04:21:45.194Z","comments":true,"path":"2022/04/02/待整理或解决/","link":"","permalink":"https://hillyee.github.io/2022/04/02/%E5%BE%85%E6%95%B4%E7%90%86%E6%88%96%E8%A7%A3%E5%86%B3/","excerpt":"","text":"JS类型转换","categories":[{"name":"其他","slug":"其他","permalink":"https://hillyee.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"07_严格模式","slug":"07_严格模式","date":"2022-04-01T16:47:09.000Z","updated":"2022-04-01T16:47:25.203Z","comments":true,"path":"2022/04/02/07_严格模式/","link":"","permalink":"https://hillyee.github.io/2022/04/02/07_%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"严格模式 如何开启严格模式？ 在文件或者函数开头使用 “use strict” 严格模式常见的限制 &quot;use strict&quot;&quot;use strict&quot;// 1.禁止意外创建全局变量// 在全局中不使用关键字直接定义变量message = &quot;hello&quot;message is not defined// 2. 不允许函数有相同的参数名称function foo(x, y, x) &#123;&#125;// Duplicate parameter name not allowed in this context// 3.使静默错误(不报错但也没有任何效果)的赋值操作抛出异常true.name = &quot;abc&quot;NaN = 123var obj = &#123;&#125;Object.defineProperty(obj, &quot;name&quot;, &#123; configurable: false, writable: false, // 不可写 value: &quot;hillyee&quot;&#125;)obj.name = &quot;jenny&quot;// 试图删除不可删除的属性，报错delete obj.name// Cannot delete property &#x27;name&#x27; of #&lt;Object&gt;// 4.不允许使用原先的八进制格式var num = 0o123 // 八进制var num2 = 0x123 // 十六进制var num3 = 0b100 // 二进制 严格模式下的this &quot;use strict&quot;// 在严格模式下，独立函数调用this默认绑定不是window，而是undefinedfunction foo() &#123; console.log(this); // undefined&#125;foo()var obj = &#123; name: &quot;hill&quot;, foo: foo&#125;var bar = obj.foobar()// setTimeout的this// 内部 fn.apply(this=window)setTimeout(function() &#123; console.log(this); // window&#125;, 1000)","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"V2","slug":"V2","permalink":"https://hillyee.github.io/tags/V2/"}]},{"title":"06_纯函数-柯里化-组合","slug":"06_纯函数-柯里化-组合","date":"2022-04-01T16:44:34.000Z","updated":"2022-04-01T16:46:04.102Z","comments":true,"path":"2022/04/02/06_纯函数-柯里化-组合/","link":"","permalink":"https://hillyee.github.io/2022/04/02/06_%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88/","excerpt":"","text":"纯函数 - 柯里化 - 组合 纯函数 什么是纯函数？ 确定的输入，一定会产生确定的输出 函数在执行过程中，不能产生副作用 什么是副作用？ 在执行一个函数时，除了返回值函数之外，还对调用函数产生了附加的影响，比如说修改了全局变量，修改参数或者改变外部的存储 纯函数例子 var names = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;, &quot;dna&quot;]// slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值// slice函数本身它是不会修改原来的数组// 所以slice函数本身就是一个纯函数var newNames1 = names.slice(0, 3)console.log(newNames1)// splice不是一个纯函数var newNames2 = names.splice(2)console.log(newNames2)console.log(names) // [ &#x27;abc&#x27;, &#x27;cba&#x27; ] 改变了原数组 JavaScript柯里化 什么是柯里化？ 把接收多个参数的函数变成接收一个单一参数的函数 “如果你固定某些参数，你将得到接受余下参数的一个函数” 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数，这个过程称之为柯里化 柯里化的结构 function add(x, y, z) &#123; return x + y + z&#125;var result = add(10, 20, 30)console.log(result); // 60function sum1(x) &#123; return function(y) &#123; return function(z) &#123; return x + y + z &#125; &#125;&#125;var result2 = sum1(10)(20)(30) // 60console.log(result2);// 简化var sum2 = x =&gt; y =&gt; z =&gt; x + y + z 柯里化让函数的职责单一 每次接收的一个参数，都做它自己的逻辑 可以更好的复用参数逻辑 function makeAdder(count) &#123; count = count * count return function(num) &#123; return count + num &#125;&#125;// 比如说我们想要每次的count都是5var adder5 = makeAdder(5)adder5(10)adder5(13) 柯里化函数的实现 function add1(x, y, z) &#123; return x + y + z&#125;function myCurrying(fn) &#123; function curried(...args) &#123; // 当已经传入的参数 大于等于 需要的参数时, 就执行函数 if (args.length &gt;= fn.length) &#123; // fn() return fn.apply(this, args) &#125; else &#123; // 没有达到个数时, 需要返回一个新的函数,继续来接收参数 function curried2(...args2) &#123; // 接收到参数后, 需要递归调用curried来检查函数的个数是否达到 return curried.apply(this, [...args, ...args2]) &#125; return curried2 &#125; &#125; // 返回一个柯里化的函数 return curried&#125;var curryAdd = myCurrying(add1)console.log(curryAdd(10, 20, 30));console.log(curryAdd(10)(20, 30));console.log(curryAdd(10)(20)(30)); 组合函数 什么是组合函数？ 组合函数是在 JavaScript 开发过程中一种对函数的使用技巧、模式 组合函数的例子 function double(num) &#123; return num * 2&#125;function square(num) &#123; return num ** 2&#125;var count = 10var result = square((double(count))) 实现组合函数 function hyCompose(...fns) &#123; // 如果不是函数,直接报错 let length = fns.length for (let i = 0; i &lt; length; i++) &#123; if(typeof fns[i] !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Expected a function&#x27;) &#125; &#125; // 取出所有的函数一次调用 return function(...args) &#123; let index = 0 let result = length ? fns[index].apply(this, args) : args while(++index &lt; length) &#123; result = fns[index].call(this, result) &#125; return result &#125;&#125;function double(m) &#123; return m * 2&#125;function square(n) &#123; return n ** 2&#125;let newFn = hyCompose(double, square)console.log(newFn(10))","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"V1","slug":"V1","permalink":"https://hillyee.github.io/tags/V1/"}]},{"title":"05_认识arguments","slug":"05_认识arguments","date":"2022-04-01T16:43:02.000Z","updated":"2022-04-01T16:50:26.658Z","comments":true,"path":"2022/04/02/05_认识arguments/","link":"","permalink":"https://hillyee.github.io/2022/04/02/05_%E8%AE%A4%E8%AF%86arguments/","excerpt":"","text":"认识 arguments 什么是 arguments arguments 是一个对应于传递给函数的参数的类数组对象。(MDN) 类数组对象，就说明它本质上是一个对象类型 类数组表示它长得像数组，并且拥有数组的一些特性，比如说 length，可以通过 index 访问 但是却没有数组的一些方法，比如说 forEach，map 等 function foo() &#123; // 会帮你接收所有传递给函数的参数 console.log(arguments); // [Arguments] &#123; &#x27;0&#x27;: 10, &#x27;1&#x27;: 20, &#x27;2&#x27;: 30 &#125; // 获取参数的长度 console.log(arguments.length); // 3 // 根据索引值获取某一个参数 console.log(arguments[1]); // 20 // 获取当前 arguments 所在的函数 console.log(arguments.callee); // [Function: foo] // arguments.forEach() 是不可以的&#125;foo(10,20,30) arguments 转成数组 如果我们需要遍历里面的参数呢？或者说使用一些数组的方法呢？ 所以在开发中，我们经常会把 arguments 转成数组 第一种方法: 自己遍历 function foo() &#123; // 我们可以通过索引值拿到 arguments 的每一个值 // 然后添加到新的数组 let newArr = [] for (let i = 0; i &lt; arguments.length; i++) &#123; newArr.push(arguments[i]) &#125; console.log(newArr); // [ 10, 20, 30, 40, 50 ]&#125;foo(10, 20, 30, 40, 50) 第二种方法：Array.prototype.slice function foo() &#123; let newArr = Array.prototype.slice.call(arguments) console.log(newArr); // [1, 2, 3, 4, 5, 6]&#125;foo(1,2,3,4,5,6) Array.prototype.slice.call(arguments) ？什么意思呀？ 首先，我们一般使用 slice 的时候，是 arr.slice(start, end)，那如果没有这个arr呢？我们怎么才能拿到 slice 这个方法 是不是可以在 Array 的原型上面找这个方法，所以 Array.prototype.slice() 那为什么要用 call 来调用？ 我们先来模拟一下 Array 中的 slice 是怎么实现的 Array.prototype.myslice = function(start, end) &#123; // 如果我们直接 Array.prototype.myslice() 这样调用的话, this 指向的就是prototype了 // 而我们希望的是, 这里的 this 是指向调用 slice 这个方法的数组 let arr = this start = start || 0 end = end || arr.length let newArray = [] // 从start到end(不包括end),把元素添加到数组 for (let i = start; i &lt; end; i++) &#123; newArray.push(arr[i]) &#125; return newArray&#125; 所以，我们要使用 call 来显式绑定这个 this，让this指向数组 let newArr = Array.prototype.myslice.call([1,2,3,4,5,6])console.log(newArr); // [1, 2, 3, 4, 5, 6]// 当然可以传递参数let newArr2 = Array.prototype.myslice.call([1,2,3,4,5,6], 2, 4)console.log(newArr2); // [3, 4] 那跟我们 arguments 有什么关系？ Array内部 slice 的实现只不过是对 this，也就是需要使用 slice 的数组进行遍历，然后把需要的部分加入到新数组 那遍历 arguments 也可以啊，把元素一个个加入到一个数组里面，再把这个数组返回，最后不就实现了 arguments 转数组了吗 function foo() &#123; let newArr = Array.prototype.slice.call(arguments) console.log(newArr); // [1, 2, 3, 4, 5, 6] // 同样道理的还有一种方法, 我们目的就是拿到 slice 这个方法,并且让 this 绑定 arguments,让内部遍历arguments let newArr2 = [].slice.call(arguments)&#125;foo(1,2,3,4,5,6) 再看回这个，应该理解了吧 Array.from (ES6) Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例（MDN） function foo() &#123; let newArr = Array.from(arguments) console.log(newArr); // [1, 2, 3, 4, 5, 6]&#125;foo(1,2,3,4,5,6) 展开运算符 (ES6) function foo() &#123; // 因为展开运算符实际上也是遍历，把遍历的元素一个个放到数组 let newArr = [...arguments] console.log(newArr); // [1, 2, 3, 4, 5, 6]&#125;foo(1,2,3,4,5,6) 箭头函数没有 arguments 箭头函数是不绑定 arguments 的，如果在箭头函数中使用 arguments，会去找上层作用域中的arguments 注意，全局作用域是没有 arguments 的 var foo = () =&gt; &#123; // 找上层作用域，找到 window console.log(arguments); // arguments is not defined&#125;foo() function foo() &#123; // arguments 有 123 console.log(arguments); // Arguments [123] var bar = () =&gt; &#123; console.log(arguments); // Arguments [123] &#125; return bar&#125;var fn = foo(123)fn() 那如果想传递多个参数呢？用 ES6 的剩余参数 var foo = (a, b, ...args) =&gt; &#123; console.log(a, b); // 1 2 console.log(args); // [3,4,5,6]&#125;foo(1,2,3,4,5,6)","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"V2","slug":"V2","permalink":"https://hillyee.github.io/tags/V2/"}]},{"title":"Vue3源码学习","slug":"Vue3源码学习","date":"2022-03-31T11:42:30.000Z","updated":"2022-03-31T14:43:32.549Z","comments":true,"path":"2022/03/31/Vue3源码学习/","link":"","permalink":"https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue3源码学习 第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭 真实的DOM渲染 传统的前端开发中，我们是编写自己的HTML，最终被渲染到浏览器上的，这个过程大概是： 解析 html 转化成 DOM 树，然后渲染到页面 虚拟DOM 渲染过程 源码的三大核心系统 Complier模块：编译模板系统 Runtime模块：也可以称之为 Renderer模块，真正渲染的模块 Reactivity模块：响应式系统 三大系统协同工作 实现 Mini-Vue mini-vue的实现也是，后面有时间得回来重新看看 包括三部分： 渲染系统模块 可响应式系统模块 应用程序入口模块 渲染系统实现 包含三个功能： h 函数，返回一个 VNode 对象 mount 函数，用于将 VNode 挂载到 DOM 上 patch 函数，用于对比两个 VNode，决定如何处理新的VNode（diff） h函数生成 VNode // 生成 VNode// 直接返回一个 VNode对象即可const h = (tag, props, children) =&gt; &#123; return &#123; tag, props, children &#125;&#125; mount函数挂载 vnode // mount函数, 挂载VNodeconst mount = (vnode, container) =&gt; &#123; // 1.根据tag创建HTML元素,并且存储到vnode的el中 const el = vnode.el = document.createElement(vnode.tag) // 2.处理props属性 // 2.1 如果以on开头,那么监听事件 // 2.2 普通属性直接通过 setAttribute 添加 if (vnode.props) &#123; for (const key in vnode.props) &#123; const value = vnode.props[key] if (key.startsWith(&quot;on&quot;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), value) &#125; else &#123; el.setAttribute(key, value) &#125; &#125; &#125; // 3.处理children if (vnode.children) &#123; if (typeof vnode.children === &#x27;string&#x27;) &#123; el.textContent = vnode.children &#125; else &#123; vnode.children.forEach(item =&gt; &#123; mount(item, el) &#125;); &#125; &#125; // 4.将 el挂载到container上 container.appendChild(el)&#125; patch函数 - 对比两个VNode // patch,对比两个 VNodeconst patch = (n1, n2) =&gt; &#123; // 1. tag不同,直接加入新的节点 if (n1.tag !== n2.tag) &#123; const n1Elparent = n1.el.parentElement n1Elparent.removeChild(n1.el) mount(n2, n1Elparent) &#125; else &#123; // 1. 取出element对象,并且在n2中进行保存 const el = n2.el = n1.el // 2. 处理props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; // 2.1 获取所有的newProps添加到el for (const key in newProps) &#123; const oldValue = oldProps[key] const newValue = newProps[key] if (newValue !== oldValue) &#123; if (key.startsWith(&quot;on&quot;)) &#123; // 对事件监听的判断 el.addEventListener(key.slice(2).toLowerCase(), newValue) &#125; else &#123; el.setAttribute(key, newValue) &#125; &#125; &#125; // 2.2删除旧的props for(const key in oldProps) &#123; if (key.startsWith(&quot;on&quot;)) &#123; const value = oldProps[key] el.removeEventListener(key.slice(2).toLowerCase(), value) &#125; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.处理children const oldChildren = n1.children || [] const newChildren = n2.children || [] if (typeof newChildren === &quot;string&quot;) &#123; // 3.1newChildren本身是一个string // 边界情况 如果oldChildren也是一个字符串 if (typeof oldChildren === &quot;string&quot;) &#123; if (newChildren !== oldChildren) &#123; el.textContent = newChildren &#125; &#125; else &#123; el.innerHTML = newChildren &#125; &#125; else &#123; // 3.2 newChildren本身是一个数组 if (typeof oldChildren === &quot;string&quot;) &#123; el.innerHTML = &quot;&quot; newChildren.forEach(item =&gt; &#123; mount(item, el) &#125;) &#125; else &#123; // oldChildren 也是数组 // 1. 前面有相同节点的 const commonLength = Math.min(oldChildren.length, newChildren.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oldChildren[i], newChildren[i]) &#125; // 2.如果新节点的length更长，那么剩余的新节点进行挂载操作 if (newChildren.length &gt; oldChildren.length) &#123; newChildren.slice(oldChildren.length).forEach(item =&gt; &#123; mount(item, el) &#125;) &#125; // 3.如果旧节点的length更长，那么移除剩余的旧节点进行 if (newChildren.length &lt; oldChildren.length) &#123; oldChildren.slice(newChildren.length).forEach(item =&gt; &#123; el.removeChild(item.el) &#125;) &#125; &#125; &#125; &#125;&#125; 响应式系统 依赖收集系统 + vue2响应式系统 class Dep &#123; constructor() &#123; // 只要new Dep,就会给你添加subscribes属性 this.subscribers = new Set() // 创建集合(里面放某属性依赖的函数) &#125; depend() &#123; // 收集依赖 if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach(effect =&gt; &#123; effect() &#125;) &#125;&#125;let activeEffect = nullfunction watchEffect(effect) &#123; activeEffect = effect effect() // 原始数据先执行一次 activeEffect = null&#125;const targetMap = new WeakMap()function getDep(target, key) &#123; // 1.根据对象(target)取出对应的Map对象 let depsMap = targetMap.get(target) if (!depsMap) &#123; depsMap = new Map() targetMap.set(target, depsMap) &#125; // 2.取出具体的dep对象 let dep = depsMap.get(key) if (!dep) &#123; dep = new Dep() depsMap.set(key, dep) &#125; return dep&#125;// vue2对raw进行数据劫持function reactive(raw) &#123; // 根据对象拿到所有key,组成数组 Object.keys(raw).forEach(key =&gt; &#123; // 获取key对应的依赖 const dep = getDep(raw, key) let value = raw[key] Object.defineProperty(raw, key, &#123; get() &#123; // 用到了某个key,调用get,所以可以在这里收集依赖 dep.depend() return value &#125;, set(newValue) &#123; // 当属性被重新赋值的时候,会调用set,所以在这里执行这个属性依赖的函数 // raw[key] = newValue 不能这样设置,否则递归了(又对raw操作,又劫持,又来到set这里了) if (value !== newValue) &#123; value = newValue dep.notify() &#125; &#125; &#125;) &#125;) return raw&#125;// 测试代码const info = reactive(&#123; counter: 100, name: &#x27;hillyee&#x27;&#125;)// watchEffect1watchEffect(function () &#123; console.log(info.counter * 2, info.name, &#x27;w1&#x27;);&#125;)// watchEffect2watchEffect(function () &#123; console.log(info.counter * info.counter, &#x27;w2&#x27;);&#125;)// info.counter++ // 修改数据的时候,所有对这个数据有依赖的函数都应该被执行一次// info.name = &quot;hahahhahah&quot; 响应式系统 vue3-proxy实现 // vue3对raw进行数据劫持function reactive(raw) &#123; // Proxy(原对象,代理对象) return new Proxy(raw, &#123; get(target, key) &#123; const dep = getDep(target, key) // 获取该属性的依赖 dep.depend() return target[key] &#125;, set(target, key, newValue) &#123; const dep = getDep(target, key) target[key] = newValue dep.notify() &#125; &#125;)&#125; 为什么 Vue3 选择 Proxy 呢？ Object.definedProperty 是劫持对象的属性时，如果新增元素， 那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理 修改对象的不同： 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截； 而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截； 框架外层 API 设计 createApp() 用于创建一个app对象，该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上 function createApp(rootComponent) &#123; return &#123; mount(selector) &#123; const container = document.querySelector(selector) let isMounted = false let oldVNode = null watchEffect(function() &#123; if (!isMounted) &#123; // rootComponent.render() 返回根组件的vnode oldVNode = rootComponent.render() mount(oldVNode, container) isMounted = true &#125; else &#123; const newVNode = rootComponent.render() patch(oldVNode, newVNode) oldVNode = newVNode &#125; &#125;) &#125; &#125;&#125; 使用案例–计数 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../mini_vue/renderer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../mini_vue/reactive.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.创建根组件 const App = &#123; data: reactive(&#123; counter: 0 &#125;), render() &#123; return h(&quot;div&quot;, null, [ h(&quot;h2&quot;, null, `当前计数:$&#123;this.data.counter&#125;`), h(&quot;button&quot;, &#123; onClick: () =&gt; &#123; this.data.counter++ console.log(this.data.counter); &#125; &#125;, &quot;+1&quot;) ]) &#125;, &#125; // 2.挂载根组件 const app = createApp(App) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt; Vue3源码阅读 根据图的流程，加上源码，多看看叭，第一次看源码确实有点吃力了 先看熟悉流程，然后可以 debugger 在浏览器上简单过一下整个流程 createApp 源码阅读之挂载根组件 const app = &#123;props: &#123;message: String&#125;instance// 1.处理props和attrsinstance.propsinstance.attrs// 2.处理slotsinstance.slots// 3.执行setupconst result = setup()instance.setupState = proxyRefs(result);// 4.编译template -&gt; compile&lt;template&gt; -&gt; render函数instance.render = Component.render = render函数// 5.对vue2的options api进行知识data/methods/computed/生命周期 组件化的初始化 Compile过程 对于不会改变的静态节点进行作用于提升 我都没找到这部分函数。。。 Block Tree 分析 vue3的一个优化：对于不会改变的静态节点进行作用域提升，仅对新的vnode进行创建 生命周期回调 template中数据的使用顺序 如果setup跟data中有同一个属性,首先选择setup的,内部做了一个判断吧","categories":[{"name":"深入Vue3+Typescript学习","slug":"深入Vue3-Typescript学习","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"}]},{"title":"Vue3_compositionAPI","slug":"Vue3-compositionAPI","date":"2022-03-31T08:10:18.000Z","updated":"2022-04-01T00:46:20.039Z","comments":true,"path":"2022/03/31/Vue3-compositionAPI/","link":"","permalink":"https://hillyee.github.io/2022/03/31/Vue3-compositionAPI/","excerpt":"","text":"Composition API 1. setup 1.1 setup函数有两个参数：props，context props：其实就是父组件传递过来的属性，但是在setup外面依然需要用props接收 context：里面包含三个属性： attrs：父组件传递过来的没有被prop接收的属性 slots：父组件传递过来的插槽 emit：当组件内部需要发出事件的时候用（vue2里面是this.$emit，但是vue3中，setup不能访问this） 1.2 setup 函数的返回值 setup() &#123; let a = 1 return &#123; a &#125;&#125; setup的返回值可以在模板 template 中使用，也就是可以代替data 但是直接这么返回变量，是没有响应式的 1.3 setup 不可以使用 this this 并没有指向当前组件实例 在 setup 被调用之前，data、computed、等都没有被解析 所以无法在 setup 中获取this 2. reactive API 为setup中定义的数据提供响应式的特性 reactive API 传入的类型必须是对象或者数组 const state = reactive(&#123; name: &quot;why&quot; // 这时候这个name就是响应式的&#125;) 3. ref API 3.1 ref API 基本使用 可以传入基本数据类型，在开发中推荐使用 ref，便于代码的抽离，当然如果属性关系很紧密的时候，我们也可以用 reactive ref 会返回一个可变的响应式对象 const message = ref(&quot;hello world&quot;) 在 template 中引用 ref 的值时，Vue会自动帮我们进行解包，就是说我们不需要在模板中 xxx.value 来使用 但是在 setup 内部，它依然是一个 ref 的引用，所以要使用 ref.value 3.2 ref API 的补充 toRefs 和 toRef let info = reactive(&#123; name: &#x27;why&#x27;, age: 18&#125;)// 当我们想解构的时候// let &#123;name, age&#125; = info // 不再是响应式的了// 如果希望响应式的话// 1. toRefs: 将 reactive 对象中所有属性都转成 ref// let &#123;name, age&#125; = toRefs(info)// 只希望单个响应式的话// 2. toReflet &#123;name&#125; = info // 不是响应式let age = toRef(info, &quot;age&quot;)const change = () =&gt; &#123; age.value++&#125; shallowRef：创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的 triggerRef：手动触发和 shallowRef 相关联的副作用 let info = shallowRef(&#123; name: &quot;why&quot;&#125;)const change = () =&gt; &#123; // info.value = &quot;hello&quot; 响应式 info.value.name = &quot;james&quot; // 不是响应式 // 手动触发和 shallowRef 相关联的副作用(变成响应式) triggerRef(info)&#125; customRef 自定义 ref 4. readonly 当我们希望我们给其他组件传递数据时，希望其他组件只是使用我们的内容，但是不允许它们修改的时候，可以用readonly 实际上，readonly 会返回原生对象的只读代理，也就是它依然是一个 Proxy，但是set方法被劫持 开发中常见的readonly方法会传入三个类型的值 普通对象 reactive 返回的对象 ref 的对象 readonly 使用时，readonly 返回的对象不允许修改，但是经过 readonly 处理的原来的对象是可以修改的 const info = &#123; name: &quot;why&quot;&#125;const state = readonly(info)state.name = &quot;aaa&quot; // 不可以info.name = &quot;aaa&quot; // 可以 5. computed 用法一：传入一个getter函数,computed的返回值是一个只读的ref对象(不能修改) const fullName = computed(() =&gt; firstName.value + &quot;-&quot; +lastName.value)const changeData = () =&gt; &#123; firstName.value = &quot;james&quot; // 可修改 fullName.value = &quot;yuzi bing&quot; // 不可修改&#125; 用法二：传入一个对象,对象包含 getter/setter,返回一个可读写的ref 对象 const fullName = computed(&#123; get: () =&gt; firstName.value + &quot;-&quot; +lastName.value, set(newValue) &#123; const names = newValue.split(&#x27; &#x27;) firstName.value = names[0] lastName.value = names[1] &#125;&#125;)const changeData = () =&gt; &#123; fullName.value = &quot;yuzi bing&quot; // 可修改&#125; 6. watchEffect 6.1 watchEffect 基本使用 watchEffect 传入的函数会被立即执行一次, 并在执行的过程中自动收集依赖（相当于你在这个函数使用了什么变量，它会自动收集到） 只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行 下面案例中，name 的改变会被侦听到，而 age 不会被侦听 // watchEffect: 自动收集响应式的依赖const name = ref(&quot;jenny&quot;)const age = ref(18)const changeName = () =&gt; name.value = &quot;tony&quot;const changeAge = () =&gt; age.value = 20watchEffect(() =&gt; &#123; console.log(&quot;name:&quot;, name.value);&#125;) 6.2 watchEffect 停止侦听 如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可 const age = ref(18)// watchEffect 会返回一个函数,供我们停止侦听使用const stop = watchEffect(() =&gt; &#123; console.log(&quot;age:&quot;, age.value);&#125;)const changeAge = () =&gt; &#123; age.value++ // 案例：age 到25的时候就停止侦听 if (age.value &gt; 25) &#123; stop() &#125;&#125; 6.3 watchEffect 清除副作用 清除副作用？ 比如我们需要在侦听器中执行网络请求，但是在网络请求还没完成之前，我们停止了侦听器或者修改了数据让侦听器侦听函数再次执行了，这时候我们应该清除上一次的副作用（数据改变了要重新发送请求或者说不需要发了） const stop = watchEffect((onInvalidate) =&gt; &#123; const timer = setTimeout(() =&gt; &#123; console.log(&#x27;网络请求成功~&#x27;); // 定时器模拟网络请求 &#125;, 2000); // 在传入的回调函数中执行一些清除工作 onInvalidate(() =&gt; &#123; clearTimeout(timer) console.log(&#x27;onInvalidate&#x27;); &#125;) console.log(&quot;age:&quot;, age.value);&#125;) 6.4 watchEffect 执行时机 首先补充一下：在 setup 中如何属于 ref 或者元素或者组件？ 定义一个 ref 对象，绑定到元素或组件的ref属性上 &lt;h2 ref=&quot;title&quot;&gt;hello&lt;/h2&gt; // 绑定到元素的ref属性const title = ref(null) // 定义 ref 对象 watchEffect 执行时机 如果我们希望在副作用函数中获取元素，我们会发现打印结果有两个 watchEffect(() =&gt; &#123; console.log(title.value);&#125;) 这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null 当 DOM 挂载时，会给 title 的 ref 对象赋新的值，副作用函数会再次执行 调整 watchEffect 的执行时机 watchEffect(() =&gt; &#123; console.log(title.value);&#125;, &#123; // flush: &quot;pre&quot; // 在元素挂载或更新之前执行 flush: &quot;post&quot; // 元素挂载更新之后执行, 这时候只打印一次&lt;h2&gt;&lt;/h2&gt;&#125;) 7. watch 7.1 侦听单个数据源 侦听一个 getter 函数 const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)// 1. watch侦听时,传入一个getter函数, 具体监听某个属性watch(() =&gt; info.name, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // Tom jenny&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot;&#125; 直接侦听一个可响应式的对象，reactive 或 ref （ref更常用） // 传入一个可响应式对象: reactive对象/ref对象const title = ref(&quot;hello&quot;)const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)watch(info, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // Proxy &#123;name: &#x27;Tom&#x27;, age: 18&#125;&#125;)watch(title, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue); // world hello&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot; title.value = &quot;world&quot;&#125; 7.2 侦听多个数据源 注：如果我们希望侦听一个数组或者对象，那么可以使用一个getter函数，并且对可响应对象进行解构 (不解构也行,不解构n,o就是一个Proxy对象) const info = reactive(&#123; name: &quot;jenny&quot;, age: 18&#125;)const title = ref(&quot;hello&quot;)// 同时侦听多个数据源watch([() =&gt; (&#123;...info&#125;), title], ([newInfo, newTitle], [oldInfo, oldTitle]) =&gt; &#123; console.log(newInfo, newTitle, oldInfo, oldTitle); // &#123;name: &#x27;Tom&#x27;, age: 18&#125; &#x27;world&#x27; // &#123;name: &#x27;jenny&#x27;, age: 18&#125; &#x27;hello&#x27;&#125;)const changeData = () =&gt; &#123; info.name = &quot;Tom&quot; title.value = &quot;world&quot;&#125; 7.3 watch 的选项 const info = reactive(&#123; name: &quot;jenny&quot;, hobby: &#123; title: &#x27;haha&#x27; &#125;&#125;)watch(() =&gt; (&#123;...info&#125;), (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue);&#125;, &#123; deep: true, // 深度监听 immediate: true // 立即执行一次&#125;)const changeData = () =&gt; &#123; // info.name = &quot;Tom&quot; info.hobby.title = &quot;hehe&quot; // 开启深度监听&#125; 8. 生命周期钩子 // 在挂载开始之前被调用：相关的 render 函数首次被调用。onBeforeMount(() =&gt; &#123;&#125;)// 实例挂载完毕后调用onMounted(() =&gt; &#123;&#125;)// 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。onBeforeUpdate(() =&gt; &#123;&#125;)// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。onUpdated(() =&gt; &#123;&#125;)// 卸载组件实例前调用, 这个阶段,实例仍然是完全正常的onBeforeUnmount(() =&gt; &#123;&#125;)// 卸载组件实例后调用,调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。onUnmounted(() =&gt; &#123;&#125;),// 被 keep-alive 缓存的组件激活时调用。onActivated(() =&gt; &#123;&#125;)// 被 keep-alive 缓存的组件失活时调用。onDeactivated(()=&gt;&#123;&#125;) 9. Provide 和 Inject 父组件通过 provide 来提供数据（必须要在父组件中使用过子组件，建立联系才能提供数据） provide(属性名，属性值) const name = ref(&quot;jenny&quot;)// 给后代组件提供属性或方法(为了不让子组件随意修改父组件的数据,可以使用readonly)provide(&quot;name&quot;, readonly(name)) 后代组件可以通过 Inject 来注入需要的属性和对应值 inject(要注入的属性名, 默认值) ，默认值就是如果父组件没有提供改数据的话就使用默认值 const name = inject(&quot;name&quot;) 10. composition API 练习 自定义 hooks 1. useTitle 改变页面标题 import &#123; ref, watch &#125; from &#x27;vue&#x27;export default function(title = &quot;默认的title&quot;) &#123; const titleRef = ref(title) watch(titleRef, (newValue) =&gt; &#123; document.title = newValue &#125;, &#123; immediate: true &#125;) return titleRef&#125; 2. useScrollPosition 监听页面滚动位置 import &#123; ref &#125; from &#x27;vue&#x27;export default function useScrollPosition() &#123; const scrollX = ref(0) const scrollY = ref(0) document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; scrollX.value = window.scrollX scrollY.value = window.scrollY &#125;) return &#123; scrollX, scrollY &#125;&#125; 3. useMousePosition 监听鼠标位置 import &#123; ref &#125; from &#x27;vue&#x27;export default function useMousePosition() &#123; const mouseX = ref(0) const mouseY = ref(0) window.addEventListener(&#x27;mousemove&#x27;, (event) =&gt; &#123; mouseX.value = event.pageX mouseY.value = event.pageY &#125;) return &#123; mouseX, mouseY &#125;&#125; 4. useLocalStorage 使用 localStorage 存储和获取数据 export default function(key, value) &#123; const data = ref(value) // 如果有传value,表示要存储值,否则是获取值 if (value) &#123; window.localStorage.setItem(key, JSON.stringify(value)) &#125; else &#123; data.value = JSON.parse(window.localStorage.getItem(key)) &#125; watch(data, (newValue) =&gt; &#123; window.localStorage.setItem(key, JSON.stringify(newValue)) &#125;) return data&#125; 使用： // 在浏览器存取值let data = useLocalStorage(&quot;name&quot;, &quot;jenny&quot;)const changeData = () =&gt; data.value = &quot;hahaha&quot; 5. useCounter import &#123; ref, computed &#125; from &#x27;vue&#x27;;export default function() &#123; const counter = ref(0); const doubleCounter = computed(() =&gt; counter.value * 2); const increment = () =&gt; counter.value++; const decrement = () =&gt; counter.value--; return &#123; counter, doubleCounter, increment, decrement &#125;&#125; 11. 认识自定义指令 11.1 简单使用 除了 v-for, v-show，等指令，Vue也允许我们自定义指令 自定义指令分为两种 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用 自定义全局指令：app的 directive 方法，可以在任意组件中被使用 简单的案例：当某个元素挂载完成后可以自定获取焦点 默认方式的实现 &lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref, onMounted&#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const input = ref(null) onMounted(() =&gt; &#123; input.value.focus() &#125;) return &#123; input &#125; &#125;&#125; 自定义局部指令 v-focus &lt;input type=&quot;text&quot; ref=&quot;input&quot; v-focus&gt;export default &#123; directives: &#123; // 自定义属性的名称(这里不需要写 v-) focus: &#123; mounted(el) &#123; el.focus() &#125; &#125; &#125;,&#125; 自定义全局指令 v-focus (main.js中) app.directive(&quot;focus&quot;, &#123; mounted(el) &#123; el.focus() &#125;&#125;) 11.2 指令的生命周期 一个指令定义的对象，Vue提供了如下的几个钩子函数： created：在绑定元素的 attribute 或事件监听器被应用之前调用； beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用 mounted：在绑定元素的父组件被挂载后调用 beforeUpdate：在更新包含组件的 VNode 之前调用 updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次 指令的生命周期可以拿到几个参数 app.directive(&quot;focus&quot;, &#123; // el: &lt;input&gt; // bindings: 包含一些属性的对象 // vnode: 一个真实 DOM 元素 // preVnode: 上一个虚拟节点 mounted(el, bindings, vnode, preVnode) &#123; console.log(&quot;focus created&quot;, el, bindings, vnode, preVnode); console.log(bindings.value); // 拿到传入的参数 console.log(bindings.modifiers); // 指令的修饰符 el.focus() &#125;&#125;) 11.3 指令的参数和修饰符 指令接受参数或者修饰符 v-指令名:参数名.修饰符=&quot;具体值&quot;&lt;button v-why:info.aaa.bbb=&quot;&#123;title: &#x27;hello&#x27;, name: &#x27;me&#x27;&#125;&quot;&gt;&lt;/button&gt; 11.4 自定义指令练习 自定义时间格式化的指令 v-format-time import dayjs from &quot;dayjs&quot;;export default function(app) &#123; app.directive(&quot;format-time&quot;, &#123; created(el, bindings) &#123; // 默认格式 bindings.formatString = &quot;YYYY-MM-DD HH:mm:ss&quot; // 如果有传入格式的参数，那么使用传入的格式 if (bindings.value) &#123; bindings.formatString = bindings.value &#125; &#125;, mounted(el, bindings) &#123; const textContent = el.textContent // 节点及其后代的文本内容 let timestamp = parseInt(textContent) if (textContent.length === 10) &#123; timestamp = timestamp * 1000 // 转成毫秒 &#125; el.textContent = dayjs(timestamp).format(bindings.formatString) &#125;, &#125;)&#125; 其他补充 1. render函数 1.1 认识 h 函数 绝大多数情况下，我们的HTML都是用模板&lt;template&gt;创建的，如果在一些特殊的场景，真的需要JavaScript的完全编程能力，这个时候可以使用 渲染函数，它比模板更接近编译器 Vue在生成真实的 DOM 之前，会将我们的节点转换成 VNode（虚拟节点），而VNode组合在一起形成一棵树结构，就是虚拟DOM（VDOM） 你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode h()函数是一个用于创建 VNode 的函数 1.2 h 函数基本使用 h() 函数接收三个参数，（标签名，组件名…）（属性）（子节点，内容） h 函数可以在两个地方使用，render 函数选项中或者 setup 函数选项中 // render 函数选项中&lt;script&gt; import &#123; h &#125; from &#x27;vue&#x27; export default &#123; render() &#123; return h(&quot;h2&quot;, &#123;class: &quot;title&quot;&#125;, &quot;Hello Render&quot;) &#125;, &#125;&lt;/script&gt; setup() &#123; return () =&gt; h(&quot;h2&quot;, &#123;class: &quot;title&quot;&#125;, &quot;Hello Render&quot;)&#125; 1.3 h 函数实现计数器案例 import &#123; h &#125; from &#x27;vue&#x27;;export default &#123; data() &#123; return &#123; counter: 0 &#125; &#125;, render() &#123; return h(&quot;div&quot;, &#123;class: &quot;app&quot;&#125;, [ h(&quot;h2&quot;, null, `当前计数:$&#123;this.counter&#125;`), h(&quot;button&quot;, &#123;onClick: () =&gt; this.counter++&#125;, &quot;+1&quot;), h(&quot;button&quot;, &#123;onClick: () =&gt; this.counter--&#125;, &quot;-1&quot;) ]) &#125;,&#125; 2. jsx 在项目中使用 jsx 需要添加对 jsx 的支持 安装Babel支持Vue的jsx插件 npm install @vue/babel-plugin-jsx -D 在 babel.config.js 配置文件中配置插件 module.exports = &#123; plugins: [ &quot;@vue/babel-plugin-jsx&quot; ]&#125; 基本使用：计数器案例 export default &#123; data() &#123; return &#123; counter: 0 &#125; &#125;, render() &#123; const increment = () =&gt; this.counter++; const decrement = () =&gt; this.counter--; return ( &lt;div&gt; &lt;h2&gt;当前计数: &#123;this.counter&#125;&lt;/h2&gt; &lt;button onClick=&#123;increment&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;decrement&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 3. 认识 Teleport (先了解一下) 在组件化开发中，我们封装一个组件A，在另外一个组件B中使用，p 那么组件A中template的元素，会被挂载到组件B中template的某个位置，最终形成一棵 DOM 树结构 但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置，这个时候就可以通过teleport完成 4. 认识 Vue 插件 通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行 export default &#123; install(app) &#123; // app.config.globalProperties.$name = &quot;hillyee&quot; &#125;&#125; 函数类型：一个function，这个函数会在安装插件时自动执行 // plugins_function.jsexport default function(app) &#123; console.log(app);&#125; main.js app.use(pluginsFunction)app.use(pluginsObject)","categories":[{"name":"深入Vue3+Typescript学习","slug":"深入Vue3-Typescript学习","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"面试题 — JS篇","slug":"面试题—JS篇","date":"2022-03-31T01:17:39.000Z","updated":"2022-04-01T16:41:40.331Z","comments":true,"path":"2022/03/31/面试题—JS篇/","link":"","permalink":"https://hillyee.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87/","excerpt":"","text":"问：JS 原始数据类型有哪些？引用数据类型有哪些？ 答：在JS中,存在7中原始数据类型,分别是： boolean,null,undefined,number,string,symbol,bigint 引用类型：Object(包含普通对象 Object, 数组对象 Array, 正则对象 RegExp,日期对象 Date,数字函数 Math,函数对象 Function) Symbol表示独一无二的值，主要是用来定义对象的唯一属性名 bigint 可以表示任意大小的整数 问：请说出下面代码的运行结果，并解释原因 function test(person) &#123; person.age = 26 person = &#123; name: &#x27;hzj&#x27;, age: 18 &#125; return person&#125;const p1 = &#123; name: &#x27;fyq&#x27;, age: 19&#125;const p2 = test(p1)console.log(p1) // -&gt; &#123;name: &#x27;fyq&#x27;,age: 26&#125;console.log(p2) // -&gt; &#123; name: &#x27;hzj&#x27;,age: 18 &#125; 答：因为在test函数传参的时候，实际上传递的是p1对象在堆中的内存地址值，所以通过调用person.age = 26确实改变了p1的值，但是随后person变成了另一块内存空间的地址，并且在最后将这个内存空间的地址返回，然后赋值给了p2 问：下面代码的输出结果是什么？(. 和 = 操作符的优先级) let a = &#123;n : 1&#125;let b = aa.x = a = &#123;n: 2&#125; console.log(a.x) // undefinedconsole.log(b.x) // &#123;n:2&#125; 首先我们要知道 在js的运算中&quot;.“和”=“运算符同时出现时，会先执行”.&quot;运算 所以 a.x = a = {n:2} --&gt; a.x = {n:2} --&gt; a = {n:2} 问：0.1+0.2为什么不等于0.3？ 答：(进制转换) js在做数字计算的时候，0.1和0.2都会被转成二进制后无限循环，但是js采用的IEEE 754二进制浮点运算，最大可以存储53位有效数字，于是大于53位后面的会全部截掉，将会导致精度缺失。 (对阶运算) 由于指数位数不相同，运算时需要对阶运算，这部分也可能产生精度缺失 https://juejin.cn/post/6940405970954616839 https://juejin.cn/post/6844903680362151950 你真的了解作用域吗 var a = 0,b = 0;function A(a) &#123; A = function (b) &#123; console.log(a + b++) &#125; console.log(a++)&#125;A(1) // 1A(2) // 4 带着掘金的各种文章一起看,找到自己想要的答案 做了一份前端面试复习计划，保熟～ 链接：https://juejin.cn/post/7061588533214969892 神十三-原生JS灵魂之问, 请问你能接得住几个 链接：https://juejin.cn/post/6844903974378668039#comment 字节跳动最爱考的前端面试题：JavaScript 基础 链接：https://juejin.cn/post/6934500357091360781 「查缺补漏」送你 54 道 JavaScript 面试题 链接：https://juejin.cn/post/6854573211443544078#comment","categories":[{"name":"面试题-js篇","slug":"面试题-js篇","permalink":"https://hillyee.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"}],"tags":[]},{"title":"TCP三次握手","slug":"TCP三次握手","date":"2022-03-30T12:11:13.000Z","updated":"2022-04-01T00:36:00.738Z","comments":true,"path":"2022/03/30/TCP三次握手/","link":"","permalink":"https://hillyee.github.io/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"1. TCP 三次握手过程 ? （首先，两个概念：SYN：同步标志 ACK：确认标志） 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手： 第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态 第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态 第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态 最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接 2. 为什么需要三次握手？两次不行吗？ 其实这是由 TCP 的自身特点可靠传输决定的。 第一次握手，客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的 第二次握手，服务端发包，客户端收到了。这样客户端就能得出结论：服务端的发送能力、客户端的接收能力是正常的。 第三次握手，客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送，接收能力也正常。 3. (ISN) 是固定的吗? 三次握手的一个重要功能是客户端和服务端交换 ISN ，以便让对方知道接下来接受数据的时候如何按序列号组装数据 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的 4. 三次握手过程中可以携带数据吗 第三次握手的时候可以携带数据。因为假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常。然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，可能会让服务器更加容易受到攻击。 而对于第三次的话，客户端已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的，所以携带数据也没问题 5. 四次挥手？为什么要四次？ 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 刚开始双方都处于established状态，假如是客户端先发起关闭请求 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态 第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。 6. SYN 攻击是什么？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 检测 SYN 攻击？ 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。 常见的防御 SYN 攻击的方法？ 缩短超时时间 增加最大半连接数 过滤网关防护 SYN cookies技术 7. 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_REVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，这种队列称之为半连接队列。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"var_let_const区别","slug":"var-let-const区别","date":"2022-03-30T12:08:54.000Z","updated":"2022-03-31T10:46:51.382Z","comments":true,"path":"2022/03/30/var-let-const区别/","link":"","permalink":"https://hillyee.github.io/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/","excerpt":"","text":"var、let、const 相关 var（ES5）let,const（ES6） 1. 作用域？ 简单来说，作用域就是一个独立的地盘，外层作用域无法读取内层作用域的变量，但是内层作用域可以访问外层作用域的变量或者定义外层作用域的同名变量。 2. var 变量提升？ var 特点？ 无论在全局作用域还是在局部作用域中，使用 var 关键字声明的变量都会被提升到该作用域的最顶部，这就是我们常说的变量提升 在代码预编译的时候，JavaScript 引擎会自动将所有代码里面以var 关键字声明的语句提升到当前作用域的顶端 function fn1() &#123; var name = &quot;jack&quot;&#125;// 等价于function fn1() &#123; var name; name = &quot;jack&quot;&#125; console.log(name) // undefinedvar name = &quot;jack&quot; var 的特点 存在变量提升 在变量未赋值时，变量为 undefined 一个变量可以多次声明，后面的声明会覆盖前面的声明 在函数中使用 var 声明变量的时候，该变量是局部的（因为在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文） function add(num1, num2) &#123; var sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 报错 sum is not defined 如果函数内不使用 var 声明，该变量是全局的，sum 被添加到全局上下文（window）window.sum function add(num1, num2) &#123; sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 30 3. let let 不存在变量提升，let 声明变量前，该变量不能使用(暂时性死区) let 为块级作用域，所有外面的语句块访问不到 console.log(value) // 报错let value = &#x27;hello&#x27; let 不允许重复声明，如果在同一个作用域中某个变量已经存在，再次使用 let 关键字声明的话会报错 4. const 与 let 没什么大不同 const 声明的是常量，常量就是一旦定义完就不能修改的值。 必须初始化值，否则会报错。 需要注意的是：const 变量不能再被重新赋值为其他引用值，但对象的键不受限制 也就是说，并不是变量的值不能改动，而是变量指向的那个内存地址不得改动 const obj1 = &#123;&#125;obj1 = &#123;&#125; // 报错，不能给常量赋值const obj2 = &#123; name: &quot;jack&quot; &#125;obj2.name = &quot;tony&quot; // 没问题 5. 暂时性死区？ 如果区块中存在 let 和 const 命令，以这个命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错 总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”(temporal dead zone 简称 TDZ ) if (true) &#123; // TDZ 开始 tmp = &quot;abc&quot;; console.log(tmp); // 报错 let tmp; // TDZ 结束 console.log(tmp) tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的死区 6. 在 for 循环中使用 var，let 的区别 for(var i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 输出全是10// 因为 i 是全局变量，最后访问的都是全局变量 for(let i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 0123456789; // i 是局部变量，每次循环改变的是对局部变量赋值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"04_实现call_apply_bind","slug":"04_手写call-apply-bind","date":"2022-03-30T11:49:46.000Z","updated":"2022-03-31T10:56:01.119Z","comments":true,"path":"2022/03/30/04_手写call-apply-bind/","link":"","permalink":"https://hillyee.github.io/2022/03/30/04_%E6%89%8B%E5%86%99call-apply-bind/","excerpt":"","text":"call、apply、bind 实现 1. call 实现 首先我们要知道系统的 call 方法主要实现了什么 执行了函数 改变了 this 的指向 先看系统的call方法 function foo() &#123; console.log(&quot;foo函数被执行&quot;, this);&#125;function sum(num1, num2) &#123; console.log(&quot;sum函数被执行&quot;, this); return num1 + num2&#125;// 1. 传入对象foo.call(&#123;&#125;) // 2. 传入null/undefinedfoo.call(null) // this自动替换为指向全局对象// 3. 传入其他，字符串，数字，布尔值等等foo.call(&quot;abc&quot;) // this 指向相应的对象let res = sum.call(&quot;123&quot;, 10,20)console.log(res) // 30 接下来我们开始实现自己的call（主要是实现思路，没有把所有的边缘条件考虑完全，但是基本都有） 1.1 让函数执行起来 Function.prototype.mycall = function() &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着让函数执行起来 fn() // 但是这里是独立函数调用，this指向window&#125;foo.mycall() // 这里相当于mycall隐式绑定了foo,因此 mycall中的this就是foo 2.2 显式绑定this 现在我们要绑定我们指定的this 先看第一种：foo.mycall(&#123;name: 'hello'&#125;)，绑定一个对象 Function.prototype.mycall = function(thisArg) &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着调用这个函数 // 我们的目的是让函数执行的时候绑定thisArg这个对象执行即thisArg.fn()(隐式绑定) // 但是现在 thisArg没有 fn 这个属性呀，怎么调用呢 // 所以我们可以给thisArg添加一个属性 fn, 值就是我们想要执行的函数 thisArg.fn = fn // 然后再调用 thisArg.fn() // 但是这样我们不就让thisArg多出来一个属性fn了吗？ // 没关系，函数执行完 删掉就好 delete thisArg.fn&#125; 如果我们传入的不是对象呢？那就不能给thisArg添加属性啦 foo.mycall(&quot;123&quot;) Function.prototype.mycall = function(thisArg) &#123; let fn = this // 所以要把 thisArg 转成对象类型(Object构造函数可以将给定的值包装为一个新对象) thisArg = Object(thisArg) thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 如果传入的是 null / undefined 呢 Function.prototype.mycall = function(thisArg) &#123; let fn = this // 如果thisArg传入的是 undefined / null, 应该让它指向全局对象 // 所以我们要做一个判断 thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 2.3 接下来要考虑参数了 // rest运算符// ...args 会把我们传入的参数列表组合到一个数组 [num1,num2]// ...args 也可以展开数组, 相当于对数组的一个遍历Function.prototype.mycall = function(thisArg, ...args) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 把参数传入函数，并用 result 接收函数执行完的结果(例子中就是sum函数执行完的结果) let result = thisArg.fn(...args) // ...[num1, num2] --&gt; num1, num2 delete thisArg.fn // 最后把结果返回出去 return result&#125; 到此，基本的call就已经实现了 检验一下叭 foo.mycall(&#123;name: &#x27;hello&#x27;&#125;)foo.mycall(&quot;123&quot;)foo.mycall(undefined)foo.mycall(null)sum.mycall(&#123;name: &quot;hello&quot;&#125;, 10, 20)let res1 = sum.mycall(123, 10, 20)console.log(res1); 2. apply 实现 跟 call 类似，只不过参数的处理有不同 Function.prototype.myapply = function(thisArg, argsArray) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 没有传argArray,那么argsArray默认为 undefined,那么就不能使用展开运算符了 // 所以如果没有传入参数, 那么把它初始化为 [], 空数组也是可以展开的 ...[] argsArray = argsArray || [] let result = thisArg.fn(...argsArray) delete thisArg.fn return result&#125; 3. bind 实现 bind 需要我们返回一个新的函数，并且调用 bind 的时候不需要执行函数 Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn() &#123; thisArg.fn = fn let result = thisArg.fn(...args) delete thisArg.fn // 返回结果 return result &#125; // bind 需要返回一个新的函数 你也可以直接 return function() &#123;...&#125; return newFn&#125; 大体上也差不多，但我们可以就下面这种情况改进一下 function sum2(num1, num2, num3, num4) &#123; console.log(&quot;sum2函数被执行&quot;, this); return num1 + num2 + num3 + num4&#125;let newSum2 = sum2.mybind(&quot;abc&quot;, 10,20) // 绑定的时候传入了两个参数console.log(newSum2(30,40)); // 使用新返回的函数的时候再传入剩余的参数 这种情况，我们就需要把两次传入的参数合并起来，再调用 Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn(...newArgs) &#123; // 合并传入的参数 let allArgs = [...args, ...newArgs] thisArg.fn = fn let result = thisArg.fn(...allArgs) delete thisArg.fn // 返回结果 return result &#125; return newFn&#125; 到此，基本的bind也实现了 最后说明一下，实现的思路是这样，但是方法不唯一的，可能还有一些边边角角没有考虑到的话，可以自己添加进去","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"03_JS函数的this指向","slug":"03_JS函数的this指向","date":"2022-03-30T10:50:46.000Z","updated":"2022-04-01T01:15:55.522Z","comments":true,"path":"2022/03/30/03_JS函数的this指向/","link":"","permalink":"https://hillyee.github.io/2022/03/30/03_JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/","excerpt":"","text":"JS 函数的 this 指向 1. this 在全局作用域下的指向 在浏览器中，this在全局作用域下指向 window console.log(this) // windowvar title = &quot;hello&quot;console.log(this.title) // helloconsole.log(window.title) // hello 2. this 的四个绑定规则 2.1 规则一：默认绑定 在独立函数调用的情况下会使用默认绑定 独立函数调用简单来说就是它没有绑定到某个对象上进行调用，简单看几个例子 // 例1function foo() &#123; console.log(this)&#125;foo() // window // 例2function foo1() &#123; console.log(this);&#125;function foo2() &#123; foo1()&#125;function foo3() &#123; foo2()&#125;foo3() // window // 例3var obj = &#123; name: &#x27;hello&#x27;, foo: function() &#123; console.log(this); &#125;&#125;var bar = obj.foobar() // window 以上的函数调用的时候，都是没有被绑定到对象中调用的，所以 this 都指向 window 2.2 规则二：隐式绑定 函数通过某个对象进行调用的时候，这个对象会被 js 引擎绑定到函数中的 this 里 下面看几个例子： // 1.function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, fn: foo&#125;obj.fn() // obj 对象 // 2.var obj1 = &#123; foo: function() &#123; console.log(this); &#125;&#125;var obj2 = &#123; title: &#x27;hello&#x27;, bar: obj1.foo&#125;obj2.bar() // obj2对象 2.3 显式绑定 利用 call，apply，bind手动指定 this 的绑定，这种明确的绑定称为显式绑定 (1) call，apply call，apply 都是可以调用函数的 fn.call(自定的this指向，参数1，参数2) fn.apply(this指向，[参数1，参数2]) 两者的区别在于传参的方式，下面例子可以看出来 call 传入参数列表，apply是数组 function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;var obj = &#123; title: &quot;hello&quot;&#125;sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;sum.apply(obj, [20,30,40]) // 手动让this指向obj (2) bind bind不会调用函数，而是返回一个新的对象。 function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;// var obj = &#123;// title: &quot;hello&quot;// &#125;// sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;// sum.apply(obj, [20,30,40]) // 手动让this指向objvar newSum = sum.bind(&#x27;aaa&#x27;,10,20,30)newSum() // 60 String &#123;&#x27;aaa&#x27;&#125; 咦？newSum 不也是独立函数调用吗，怎么不指向 window 了 这就是默认绑定和显式绑定bind的冲突，显式绑定的优先级更高！ 2.4 new绑定 function Person(name, age) &#123; this.name = name this.age = age // 实际上这里是会把 this 返回出去的,即return this（默认） // this = 创建出来的对象&#125;// new 会创建一个全新的对象var p1 = new Person(&quot;jenny&quot;, 12)var p2 = new Person(&quot;tony&quot;, 15) 3. 一些内置函数的 this 绑定 有时候我们会调用一些 JS 的内置函数，这些函数要求我们传入另外一个函数，并且我们不会自己去调用这些函数，而是 JS 内部会帮助我们执行。 这个时候，this 的绑定就跟内部帮我们指向函数的方式有关系了。 看几个例子吧 3.1 setTimeout 内部通过 apply 调用函数，并绑定了this对象，是window setTimeout(function() &#123; console.log(this); // window&#125;, 2000) 3.2 数组的内置函数 forEach 默认情况下传入的函数是自动调用函数（默认绑定） var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 window&#125;) 也可以通过传入第二个参数，改变this指向 var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 &#x27;obj&#x27;&#125;, &#x27;obj&#x27;) 3.3 点击事件 在发生点击时，回调函数被调用，会将 this 绑定到该函数中 &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; var box = document.querySelector(&quot;.box&quot;)box.onclick = function() &#123; console.log(this); // box对象&#125; 所以说，某些内置的函数，我们很难确定它内部是如何调用传入的回调函数的，可以自己测试一下，记一下，看源码当然更好啦 4. 几个规则的优先级 从高到低：new绑定 &gt; 显式绑定(bind) &gt; 隐式绑定 &gt; 默认绑定 new绑定和call，apply是不允许同时使用的，（毕竟都会调用函数），所以不存在谁的优先级更高 显式绑定高于隐式绑定 // 显式绑定和隐式绑定function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;obj&#x27;, foo: foo&#125;obj.foo() // obj 对象obj.foo.call(&quot;aaa&quot;) // &#x27;aaa&#x27; new 绑定高于隐式绑定 function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, foo: foo&#125;new obj.foo() // 输出 foo 对象而不是 obj new 绑定高于bind function foo() &#123; console.log(this, title);&#125;var obj = &#123; name: &#x27;hello&#x27;&#125;var bar = foo.bind(obj) // 显式绑定objnew bar() // 打印 foo对象 而不是 obj 5. 两种特殊情况 5.1 在显式绑定中传入 null 或 undefined 这时候，显式绑定会被忽略，使用默认规则 function foo() &#123; console.log(this);&#125;var obj = &#123; name: &quot;hello&quot;, foo: foo&#125;foo.call(obj) // objfoo.call(null) // windowfoo.call(undefined) // window 5.2 间接函数引用 function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;// 先来看一下这个赋值的结果, 是 foo 函数console.log((obj2.foo = obj1.foo)); // foo函数// 这种叫做间接函数引用，是会把赋值语句右边的结果返回，然后直接调用，是独立函数调用(obj2.foo = obj1.foo)() // 相当于直接调用 foo 函数，所以是默认绑定，输出window 6. 箭头函数的this 箭头函数不绑定 this，也就是说它没有自己的 this，而是根据外层作用域来决定this var name = &quot;hello&quot;var foo = () =&gt; &#123; console.log(this); // 在这里this的外层作用域就是 window&#125;var obj = &#123; foo: foo&#125;obj.foo() // windowobj.foo.call(&quot;aaa&quot;) // window 再来看一个案例： 使用setTimeout模拟一个网络请求，如果我们想把返回来的数据保存到 data 中，该怎么做 var obj = &#123; data: &#x27;&#x27;, getData: function() &#123; setTimeout(() =&gt; &#123; console.log(this); // obj 对象 // 这里的 this 不是应该指向window吗？ // 如果我们这里使用的是普通的函数 function() &#123;console.log(this)&#125; // 那么这个函数在内部调用的时候，会绑定this，就是window // 但是我们使用了箭头函数，它不绑定this，会往上层作用域中找到对应的this // 所以找到了 obj this.data = &#x27;hello&#x27; // --&gt; obj.data = &quot;hello&quot; &#125;, 2000); &#125;&#125;obj.getData() 7. this 的面试题 如果每题都会了，那么 this 绑定的问题，就是你的送分题而不是送命题了哈哈哈 建议把我的答案跟注释都删掉，自己一点点理清哦 题一 var name = &quot;window&quot;; // window.name = &quot;window&quot;var person = &#123; name: &quot;person&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;;function sayName() &#123; var sss = person.sayName; sss(); // window 很明显是独立函数调用,没有与任何对象关联 person.sayName(); // person 隐式绑定,与person关联 (person.sayName)(); // person 同上(加括号只是代表这是一个整体) // console.log((b = person.sayName)); // 这里实际上就是sayName这个函数 (b = person.sayName)(); // 间接函数引用，是独立函数调用, 输出 window&#125;sayName(); 题二 var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;// 隐式绑定person1对象person1.foo1(); // person1// 显式绑定person2person1.foo1.call(person2); // person2// 箭头函数不适用任何规则, 向上层作用域中找thisperson1.foo2(); // windowperson1.foo2.call(person2); // window// person1.foo3()返回了一个函数，然后独立调用person1.foo3()(); // window// person1.foo3.call(person2) 返回的是一个函数，然后独立调用person1.foo3.call(person2)(); // window// person1.foo3()返回一个函数，然后显式绑定到 person2person1.foo3().call(person2); // person2// person1.foo4()返回一个箭头函数，往上层作用域找，找到foo4中绑定的this,是 person1person1.foo4()(); // person1// foo4显式绑定到 person2person1.foo4.call(person2)(); // person2// person1.foo4()返回箭头函数，往上层作用域找person1.foo4().call(person2); // person1 题三 var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.foo1 = function () &#123; console.log(this.name) &#125;, this.foo2 = () =&gt; console.log(this.name), this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() // person1 隐式绑定person1.foo1.call(person2) // person2 显式绑定person1.foo2() // person1 隐式绑定// 箭头函数不适用显式绑定规则，直接向上层作用域找person1.foo2.call(person2) // person1 // person1.foo3() 返回一个函数，在全局调用person1.foo3()() // windowperson1.foo3.call(person2)() // window // 同理// person1.foo3() 返回的函数使用 .call 显式绑定 person2person1.foo3().call(person2) //person2 // person1.foo4() 返回一个箭头函数，再调用，向上层作用域找person1.foo4()() // person1// person1.foo4.call(person2) 返回箭头函数，并且foo4显式绑定this为person2// 再调用这个箭头函数，向上找就找到 foo4 的this 为person2person1.foo4.call(person2)() // person2 // person1.foo4() 返回箭头函数,不适用显式绑定，向上找到 person1// 注意这里跟上面的区别，这里的foo4调用不是.call调用的，而是.foo4()这样调用的// call是来调用箭头函数的，而箭头函数不适用显式绑定，向上找到的是person1person1.foo4().call(person2) // person1 题四 var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)// person1.obj.foo1()返回一个函数，在全局中调用person1.obj.foo1()() // window// person1.obj.foo1.call(person2) 返回一个函数 在全局中调用person1.obj.foo1.call(person2)() // window// person1.obj.foo1() 返回一个函数，显式绑定person2person1.obj.foo1().call(person2) // person2// 箭头函数调用，向上找到 foo2 中的this是objperson1.obj.foo2()() // obj// foo2调用的时候显式绑定person2，箭头函数向上层找到的就是person2person1.obj.foo2.call(person2)() // person2// 箭头函数不适用 显式绑定，向上找找到 objperson1.obj.foo2().call(person2) // obj","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"02_JS内存管理和闭包","slug":"02_JS内存管理和闭包","date":"2022-03-30T10:49:50.000Z","updated":"2022-03-31T10:55:36.994Z","comments":true,"path":"2022/03/30/02_JS内存管理和闭包/","link":"","permalink":"https://hillyee.github.io/2022/03/30/02_JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"一、JS 的内存管理 1. JS 的内存管理 JavaScript 会在定义变量时为我们分配内存 内存分配的方式是一样的吗？ JS 对于基本数据类型内存的分配，会在执行时直接在栈空间进行分配 JS 对于复杂数据类型内存的分配，会在堆内存中开辟一块空间，并且将这块空间的地址保存在栈空间 2. JS 的垃圾回收 垃圾回收的英文是 Garbage Collection，简称 GC 对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放出更多的内存空间 JavaScript的运行环境 js引擎都会内存垃圾回收器 3. 常见的两个 GC 算法 GC怎么知道哪些对象是不再使用的呢？这里就要用到 GC 算法了 3.1 引用计数 当一个对象有一个引用指向它的时候，那么这个对象的引用就 +1，当一个对象的引用为 0 时，这个对象就可以被回收掉 但是这个算法有一个很大的弊端，就是会产生循环引用 var obj1 = &#123;friend: obj2&#125;var obj2 = &#123;friend: obj1&#125; 3.2 标记清除 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象 ​ 图中从 A 开始找，找到 D 的时候结束，M,N不可达，被认为是不可用的对象 这个算法可以很好的解决循环引用的问题 注：JS 引擎比较广泛采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，在算法的实现细节上也会结合一些其他的算法 二、JS中的闭包 1. 什么是闭包？ JavaScript 中的一个函数，如果它访问了外层作用域的变量，那么这个函数是一个闭包。 MDN中的一个解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） function foo() &#123; var name = &quot;foo&quot; var age = 18 function bar() &#123; console.log(name)// name访问了外层作用域的变量name console.log(age) // age访问了外层作用域的变量age &#125; return bar // 返回一个函数&#125;var fn = foo()fn() 2. 闭包的访问过程 简单描述上面函数的执行过程： 1. GO: &#123;foo:地址1, fn:undefined&#125;2. 执行代码： 2.1 foo():只要执行函数，就会创建一个函数执行上下文 (1)VO: &#123;AO对象:&#123;name: undefined;age:undefined;bar:地址2&#125;&#125; scopechain:[VO+parent scopes] (2)开始执行代码 &#123;name: &quot;foo&quot;, age:18;&#125; return bar地址2 (3)foo执行完毕 2.2 fn: bar地址2 2.3 fn(),即执行 bar地址2中的函数执行体,创建bar的函数执行上下文 (1)&#123;AO:&#123;&#125;,scopechain&#125; (2)执行代码: console.log(name):在自己的AO中找不到，通过作用域链找到foo的AO，找到name:&quot;foo&quot;,输出 &quot;foo&quot; console.log(age)同理 (3)fn()执行完毕3.执行完毕地址1:foo函数对象: &#123;parentScope: GO&#125;,&#123;foo函数的执行体&#125;地址2:bar函数对象: &#123;parentScope: foo的AO对象&#125;,&#123;bar函数的执行体&#125; 你可能会有疑惑：foo函数执行完毕之后，不是应该弹出栈吗，foo的AO对象不应该被释放了吗？怎么bar还能找到 name，找到 age 呢？ 看下图： 可以看到，当我们执行完 foo 函数的时候，返回的是 bar 函数(或者说是bar的地址)，然后因为 fn = foo()，把这个地址赋值给了fn，因此会存在 fn 指向 bar函数对象，而bar的父作用域又指向了 foo 的AO对象，因此foo的AO是不会被释放的 3. 闭包的内存泄漏 为什么总说闭包是有内存泄漏的呢？什么是内存泄漏？ 拿上面的例子说，如果后续我们不会再用 foo，bar 这些函数了，但是在全局作用域下 fn 变量对bar函数对象有引用，而bar的作用域中AO对foo的AO有引用，所以会造成这些内存都是无法被释放的。 这就是我们所说的内存泄漏，其实就是刚才的引用链中的对象无法释放 怎么解决这个问题呢？ 很简单，设置 fn = null，就不再对 bar 函数对象有引用，那么从GO出发，bar是不可达的，那么对应的AO对象(foo) 同样也就不可达。 在下一次 GC 的的检测中，它们就会被销毁掉 还有一个问题，形成闭包之后，是不是所有的属性都不会被释放呢？ 还是这个例子 function foo() &#123; var name = &quot;why&quot; var age = 18 function bar() &#123; console.log(name) // console.log(age) &#125; return bar&#125;var fn = foo()fn() 如果age不使用了，会不会被销毁掉呢？ 答案是会的，测试如下： 这是因为 V8 引擎做的优化，因为规范中闭包的属性应该是不会被销毁的","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"01_深入JS运行原理","slug":"01_深入JS运行原理","date":"2022-03-30T10:49:46.000Z","updated":"2022-04-01T01:08:33.707Z","comments":true,"path":"2022/03/30/01_深入JS运行原理/","link":"","permalink":"https://hillyee.github.io/2022/03/30/01_%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"1. 从输入 URL 到页面展示 发生了什么？ 总体分为以下过程： DNS 域名解析：将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 2. 浏览器工作原理 在浏览器中输入查找内容，浏览器是怎样将页面加载出来的？ 大致流程如下： 首先，用户输入服务器地址，与服务器建立连接 服务器返回对应的静态资源（index.html） 然后浏览器拿到 index.html 后进行解析 当解析时遇到 css 或 js 文件，就向服务器请求并下载对应的 css 和 js 文件 最后浏览器对页面进行渲染，执行 js 代码 3. 浏览器渲染过程 HTML Parser 将 HTML解析转换成 DOM 树 CSS Parser 将 样式表转换成 CSS 规则树 合并 DOM 树和 CSS 规则树，生成 render（渲染） 树 布局 render 树（Layout） 通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 绘制 render 树（painting），进行 Display 展示 注意图中顶部的紫色 DOM 三角形，实际上是 js 对 DOM 的相关操作。 4. 一个强大的 JavaScript 引擎 — V8 引擎 在解析 HTML 的过程中，遇到了 JavaScript 标签，该怎么办呢？ 会停止解析 HTML ，而去加载和执行 JavaScript 代码 那么，JavaScript 代码由谁来执行呢？ JavaScript 引擎 高级的编程语言最终都要转成机器指令来执行的， 所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行 （1）V8 引擎的架构 V8 的底层架构主要有三个核心模块（Parse、Ignition、TurboFan） 1. Parse： 该过程主要是对 JavaScript 源代码进行词法分析和语法分析。 词法分析：对代码中的每一个词每一个符号进行解析，最终生成很多 tokens 例如：对 const name = “curry” // 首先对const进行解析，因为const为一个关键字，所以类型会被记为一个关键词，值为consttokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;]// 接着对name进行解析，因为name为一个标识符，所以类型会被记为一个标识符，值为nametokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;, &#123; type: &#x27;identifier&#x27;, value: &#x27;name&#x27; &#125;]// 以此类推... 语法分析：在词法分析的基础上，拿到 tokens 中的一个个对象，根据不同类型，再进一步分析具体语法，最终生成 AST 抽象语法树 可以详细查看通过 Parse 转换后的 AST 的工具：AST Explorer 2. Ignition 一个解析器，可以将 AST 转换成 ByteCode（字节码） 3. TurboFan 一个编译器，可以将字节码编译为 CPU 认识的机器码 （2）V8 引擎的执行过程 Blink 内核将 JS 源码交给 V8 引擎 Stream 获取到 JS 源码进行编码转换 Scanner 进行词法分析，将代码转换成 tokens Parser 和 PreParser Parser ：直接解析，将 tokens 转成 AST 树 PreParser：预解析，对不必要的函数进行预解析，也就是只解析暂时需要的内容，而在函数被调用时才进行函数的全量解析 生成 AST 树后，会被 Ignition 转成字节码，之后就是代码的执行过程 5. JavaScript 的执行过程 假如要执行如下代码： var title = &quot;hello&quot;console.log(num1)var num1 = 20var num2 = 30var result = num1 + num2console.log(result) （1）首先，代码被解析，V8 引擎内部会帮助我们创建一个全局对象：Global Object（GO） GO 可以访问所有的作用域 里面会包含 Date、Array、String、setTimeout等等（所以我们可以直接 new Date() ） GO 还有一个window 属性指向自己（所以window.window.window还是指向 GO自己） 用伪代码表示为： var globalObject = &#123; String: 类, setTimeout: 函数, ... window: globalObject&#125; （2）然后运行代码 首先我们要知道 js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ESC），它是用于执行代码的调用栈。 为了全局代码能够正常执行，首先需要创建一个 全局执行上下文（Global Execution Context，简称GEC），全局代码需要被执行时才会创建 然后全局执行上下文会被放入执行上下文栈中执行，包含两个部分： 在代码执行前，会将全局定义的变量，函数等加入到 GlobalOject 中，但是并不会赋值（也称为变量的作用域提升） 开始依次执行代码： title = “hello” // 赋值 console.log(num1) // undefined, 不会报错 num1= 20 … 遇到函数如何执行? 先根据函数体创建一个函数执行上下文，并且压入到执行上下文栈中 作用域链？ 由 VO(变量对象，在函数中就是 AO 对象)和 父级 VO组成，查找时会一层层查找 看一个例子： var message = &quot;Hello Global&quot;function foo() &#123; console.log(message) // Hello Global&#125;function bar() &#123; var message = &quot;Hello Bar&quot; foo()&#125;bar() 比如说这里，当执行 foo 函数的时候， foo 的 AO 中没有message，就会去它的父级 VO 中查找。一定要注意！当第一次代码解析的时候， foo 的函数执行上下文就已经确定了，其中包括三部分： 第一部分：在解析函数成为 AST 树结构的时候，会创建一个 AO（Activation） 其中包含形参、arguments、函数定义、指向函数对象或定义的变量 第二部分：就是作用域链 第三部分：this 绑定的值 因此！当foo在自己的AO找不到message的时候，去父级 VO 找，这个父级 VO 就是一开始解析时候保存的 GO，所以message为 “Hello Global” 简单描述一下这个过程吧：(我不专业的表达) // 初始化 GOGO: &#123;window; message:undefined; foo: 地址1; bar: 地址2;&#125;// 执行代码GO: &#123;window; message:&quot;Hello Global&quot;; foo: 地址1; bar: 地址2;&#125;bar函数执行,创建一个函数执行上下文, 其中包括 VO对象: AO:&#123;message: undefined&#125; 然后开始执行 bar函数 message:&quot;Hello Bar&quot; (赋值) foo() foo函数执行，创建一个foo的函数执行上下文 其中包括：VO: AO: &#123;&#125; 然后开始执行代码 console.log(message) 发现自己的AO没有message,会向上找，即从自己保存的父级VO中查找，找到GO中的message为 &quot;Hello Global&quot; (图来源于coderwhy) 几道常见的作用域提升面试题： var n = 100function foo() &#123; n = 200&#125;foo()console.log(n) // 200 function foo() &#123; console.log(n) // undefined var n = 200 console.log(n) // 200&#125;var n = 100foo() var a = 100function foo() &#123; console.log(a) // undefined return var a = 200&#125;foo() function foo() &#123; m = 100&#125;foo()console.log(m) // 100 function foo() &#123; var a = b = 10 // =&gt; 转成下面的两行代码 // var a = 10 // b = 10&#125;foo() //console.log(a) // 报错 a is not defined(因为当 foo函数执行完之后，foo的函数执行上下文就会弹出栈(没啦！哪里还会有a呢))console.log(b) // 10","categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-29T14:25:03.367Z","updated":"2022-03-29T14:25:03.367Z","comments":true,"path":"2022/03/29/hello-world/","link":"","permalink":"https://hillyee.github.io/2022/03/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"深入JS高级语法","slug":"深入JS高级语法","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"},{"name":"其他","slug":"其他","permalink":"https://hillyee.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"深入Vue3+Typescript学习","slug":"深入Vue3-Typescript学习","permalink":"https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"},{"name":"面试题-js篇","slug":"面试题-js篇","permalink":"https://hillyee.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"V3","slug":"V3","permalink":"https://hillyee.github.io/tags/V3/"},{"name":"V2","slug":"V2","permalink":"https://hillyee.github.io/tags/V2/"},{"name":"V1","slug":"V1","permalink":"https://hillyee.github.io/tags/V1/"},{"name":"vue3","slug":"vue3","permalink":"https://hillyee.github.io/tags/vue3/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]}
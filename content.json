{"meta":{"title":"Hillyee-blog","subtitle":"","description":"","author":"Hillyee","url":"https://hillyee.github.io","root":"/"},"pages":[{"title":"About","date":"2022-03-30T15:53:22.543Z","updated":"2022-03-30T15:53:22.543Z","comments":false,"path":"about/index.html","permalink":"https://hillyee.github.io/about/index.html","excerpt":"","text":""},{"title":"Links","date":"2022-03-30T11:25:48.026Z","updated":"2022-03-30T11:25:48.026Z","comments":false,"path":"links/index.html","permalink":"https://hillyee.github.io/links/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-03-30T15:45:28.276Z","updated":"2022-03-30T15:45:28.276Z","comments":false,"path":"categories/index.html","permalink":"https://hillyee.github.io/categories/index.html","excerpt":"","text":"categories111"},{"title":"Daily","date":"2022-03-31T04:30:41.000Z","updated":"2022-03-31T04:39:49.401Z","comments":false,"path":"daily/index.html","permalink":"https://hillyee.github.io/daily/index.html","excerpt":"","text":""},{"title":"每日一题","date":"2022-03-31T01:15:22.000Z","updated":"2022-03-31T04:25:08.561Z","comments":true,"path":"每日一题/index.html","permalink":"https://hillyee.github.io/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-03-30T10:42:50.892Z","updated":"2022-03-30T10:42:50.892Z","comments":false,"path":"tags/index.html","permalink":"https://hillyee.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-30T05:15:58.514Z","updated":"2022-03-30T05:15:58.514Z","comments":false,"path":"repository/index.html","permalink":"https://hillyee.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"面试每日一题——JS篇","slug":"面试每日一题——JS篇","date":"2022-03-31T01:17:39.000Z","updated":"2022-03-31T04:43:03.115Z","comments":true,"path":"2022/03/31/面试每日一题——JS篇/","link":"","permalink":"https://hillyee.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94JS%E7%AF%87/","excerpt":"","text":"1. JS 数据类型","categories":[],"tags":[]},{"title":"TCP三次握手","slug":"TCP三次握手","date":"2022-03-30T12:11:13.000Z","updated":"2022-03-31T04:55:03.556Z","comments":true,"path":"2022/03/30/TCP三次握手/","link":"","permalink":"https://hillyee.github.io/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"1. TCP 三次握手过程 ? （首先，两个概念：SYN：同步标志 ACK：确认标志） 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手： 第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态 第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态 第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态 最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接 2. 为什么需要三次握手？两次不行吗？ 其实这是由 TCP 的自身特点可靠传输决定的。 第一次握手，客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的 第二次握手，服务端发包，客户端收到了。这样客户端就能得出结论：服务端的发送能力、客户端的接收能力是正常的。 第三次握手，客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送，接收能力也正常。 3. (ISN) 是固定的吗? 三次握手的一个重要功能是客户端和服务端交换 ISN ，以便让对方知道接下来接受数据的时候如何按序列号组装数据 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的 4. 三次握手过程中可以携带数据吗 第三次握手的时候可以携带数据。因为假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常。然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，可能会让服务器更加容易受到攻击。 而对于第三次的话，客户端已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的，所以携带数据也没问题 5. 四次挥手？为什么要四次？ 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则： 刚开始双方都处于established状态，假如是客户端先发起关闭请求 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态 第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。 6. SYN 攻击是什么？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 检测 SYN 攻击？ 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。 常见的防御 SYN 攻击的方法？ 缩短超时时间 增加最大半连接数 过滤网关防护 SYN cookies技术 7. 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，这种队列称之为半连接队列。","categories":[{"name":"网络传输/","slug":"网络传输","permalink":"https://hillyee.github.io/categories/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"var_let_const区别","slug":"var-let-const区别","date":"2022-03-30T12:08:54.000Z","updated":"2022-03-30T15:39:31.553Z","comments":true,"path":"2022/03/30/var-let-const区别/","link":"","permalink":"https://hillyee.github.io/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/","excerpt":"","text":"var、let、const 相关 var（ES5）let,const（ES6） 1. 作用域？ 简单来说，作用域就是一个独立的地盘，外层作用域无法读取内层作用域的变量，但是内层作用域可以访问外层作用域的变量或者定义外层作用域的同名变量。 2. var 变量提升？ var 特点？ 无论在全局作用域还是在局部作用域中，使用 var 关键字声明的变量都会被提升到该作用域的最顶部，这就是我们常说的变量提升 在代码预编译的时候，JavaScript 引擎会自动将所有代码里面以var 关键字声明的语句提升到当前作用域的顶端 123456789function fn1() &#123; var name = &quot;jack&quot;&#125;// 等价于function fn1() &#123; var name; name = &quot;jack&quot;&#125; 12console.log(name) // undefinedvar name = &quot;jack&quot; var 的特点 存在变量提升 在变量未赋值时，变量为 undefined 一个变量可以多次声明，后面的声明会覆盖前面的声明 在函数中使用 var 声明变量的时候，该变量是局部的（因为在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文） 123456function add(num1, num2) &#123; var sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 报错 sum is not defined 如果函数内不使用 var 声明，该变量是全局的，sum 被添加到全局上下文（window）window.sum 123456function add(num1, num2) &#123; sum = num1 + num2; return sum&#125;let result = add(10, 20) // 30console.log(sum) // 30 **3. let ** let 不存在变量提升，let 声明变量前，该变量不能使用(暂时性死区) let 为块级作用域，所有外面的语句块访问不到 12console.log(value) // 报错let value = &#x27;hello&#x27; let 不允许重复声明，如果在同一个作用域中某个变量已经存在，再次使用 let 关键字声明的话会报错 4. const 与 let 没什么大不同 const 声明的是常量，常量就是一旦定义完就不能修改的值。 必须初始化值，否则会报错。 需要注意的是：const 变量不能再被重新赋值为其他引用值，但对象的键不受限制 也就是说，并不是变量的值不能改动，而是变量指向的那个内存地址不得改动 12345const obj1 = &#123;&#125;obj1 = &#123;&#125; // 报错，不能给常量赋值const obj2 = &#123; name: &quot;jack&quot; &#125;obj2.name = &quot;tony&quot; // 没问题 5. 暂时性死区？ 如果区块中存在 let 和 const 命令，以这个命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错 总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”(temporal dead zone 简称 TDZ ) 1234567891011if (true) &#123; // TDZ 开始 tmp = &quot;abc&quot;; console.log(tmp); // 报错 let tmp; // TDZ 结束 console.log(tmp) tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的死区 6. 在 for 循环中使用 var，let 的区别 123456for(var i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 输出全是10// 因为 i 是全局变量，最后访问的都是全局变量 123456for(let i = 0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125; // 0123456789; // i 是局部变量，每次循环改变的是对局部变量赋值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://hillyee.github.io/tags/JS/"}]},{"title":"实现call_apply_bind","slug":"手写call-apply-bind","date":"2022-03-30T11:57:16.000Z","updated":"2022-03-30T15:40:51.050Z","comments":true,"path":"2022/03/30/手写call-apply-bind/","link":"","permalink":"https://hillyee.github.io/2022/03/30/%E6%89%8B%E5%86%99call-apply-bind/","excerpt":"","text":"call、apply、bind 实现 1. call 实现 首先我们要知道系统的 call 方法主要实现了什么 执行了函数 改变了 this 的指向 先看系统的call方法 123456789101112131415161718function foo() &#123; console.log(&quot;foo函数被执行&quot;, this);&#125;function sum(num1, num2) &#123; console.log(&quot;sum函数被执行&quot;, this); return num1 + num2&#125;// 1. 传入对象foo.call(&#123;&#125;) // 2. 传入null/undefinedfoo.call(null) // this自动替换为指向全局对象// 3. 传入其他，字符串，数字，布尔值等等foo.call(&quot;abc&quot;) // this 指向相应的对象let res = sum.call(&quot;123&quot;, 10,20)console.log(res) // 30 接下来我们开始实现自己的call（主要是实现思路，没有把所有的边缘条件考虑完全，但是基本都有） 1.1 让函数执行起来 1234567Function.prototype.mycall = function() &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着让函数执行起来 fn() // 但是这里是独立函数调用，this指向window&#125;foo.mycall() // 这里相当于mycall隐式绑定了foo,因此 mycall中的this就是foo 2.2 显式绑定this 现在我们要绑定我们指定的this 先看第一种：foo.mycall(&#123;name: 'hello'&#125;)，绑定一个对象 12345678910111213Function.prototype.mycall = function(thisArg) &#123; let fn = this // this就是我们想要执行的函数 foo,把它保存到 fn // 接着调用这个函数 // 我们的目的是让函数执行的时候绑定thisArg这个对象执行即thisArg.fn()(隐式绑定) // 但是现在 thisArg没有 fn 这个属性呀，怎么调用呢 // 所以我们可以给thisArg添加一个属性 fn, 值就是我们想要执行的函数 thisArg.fn = fn // 然后再调用 thisArg.fn() // 但是这样我们不就让thisArg多出来一个属性fn了吗？ // 没关系，函数执行完 删掉就好 delete thisArg.fn&#125; 如果我们传入的不是对象呢？那就不能给thisArg添加属性啦 foo.mycall(&quot;123&quot;) 12345678Function.prototype.mycall = function(thisArg) &#123; let fn = this // 所以要把 thisArg 转成对象类型(Object构造函数可以将给定的值包装为一个新对象) thisArg = Object(thisArg) thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 如果传入的是 null / undefined 呢 123456789Function.prototype.mycall = function(thisArg) &#123; let fn = this // 如果thisArg传入的是 undefined / null, 应该让它指向全局对象 // 所以我们要做一个判断 thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn thisArg.fn() delete thisArg.fn&#125; 2.3 接下来要考虑参数了 12345678910111213// rest运算符// ...args 会把我们传入的参数列表组合到一个数组 [num1,num2]// ...args 也可以展开数组, 相当于对数组的一个遍历Function.prototype.mycall = function(thisArg, ...args) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 把参数传入函数，并用 result 接收函数执行完的结果(例子中就是sum函数执行完的结果) let result = thisArg.fn(...args) // ...[num1, num2] --&gt; num1, num2 delete thisArg.fn // 最后把结果返回出去 return result&#125; 到此，基本的call就已经实现了 检验一下叭 12345678foo.mycall(&#123;name: &#x27;hello&#x27;&#125;)foo.mycall(&quot;123&quot;)foo.mycall(undefined)foo.mycall(null)sum.mycall(&#123;name: &quot;hello&quot;&#125;, 10, 20)let res1 = sum.mycall(123, 10, 20)console.log(res1); 2. apply 实现 跟 call 类似，只不过参数的处理有不同 1234567891011121314Function.prototype.myapply = function(thisArg, argsArray) &#123; let fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window thisArg.fn = fn // 没有传argArray,那么argsArray默认为 undefined,那么就不能使用展开运算符了 // 所以如果没有传入参数, 那么把它初始化为 [], 空数组也是可以展开的 ...[] argsArray = argsArray || [] let result = thisArg.fn(...argsArray) delete thisArg.fn return result&#125; 3. bind 实现 bind 需要我们返回一个新的函数，并且调用 bind 的时候不需要执行函数 1234567891011121314151617Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn() &#123; thisArg.fn = fn let result = thisArg.fn(...args) delete thisArg.fn // 返回结果 return result &#125; // bind 需要返回一个新的函数 你也可以直接 return function() &#123;...&#125; return newFn&#125; 大体上也差不多，但我们可以就下面这种情况改进一下 1234567function sum2(num1, num2, num3, num4) &#123; console.log(&quot;sum2函数被执行&quot;, this); return num1 + num2 + num3 + num4&#125;let newSum2 = sum2.mybind(&quot;abc&quot;, 10,20) // 绑定的时候传入了两个参数console.log(newSum2(30,40)); // 使用新返回的函数的时候再传入剩余的参数 这种情况，我们就需要把两次传入的参数合并起来，再调用 1234567891011121314151617Function.prototype.mybind = function(thisArg, ...args) &#123; var fn = this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window function newFn(...newArgs) &#123; // 合并传入的参数 let allArgs = [...args, ...newArgs] thisArg.fn = fn let result = thisArg.fn(...allArgs) delete thisArg.fn // 返回结果 return result &#125; return newFn&#125; 到此，基本的bind也实现了 最后说明一下，实现的思路是这样，但是方法不唯一的，可能还有一些边边角角没有考虑到的话，可以自己添加进去","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://hillyee.github.io/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JS函数的this指向","slug":"JS函数的this指向","date":"2022-03-30T11:55:56.000Z","updated":"2022-03-30T15:41:57.115Z","comments":true,"path":"2022/03/30/JS函数的this指向/","link":"","permalink":"https://hillyee.github.io/2022/03/30/JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/","excerpt":"","text":"JS 函数的 this 指向 1. this 在全局作用域下的指向 在浏览器中，this在全局作用域下指向 window 12345console.log(this) // windowvar title = &quot;hello&quot;console.log(this.title) // helloconsole.log(window.title) // hello 2. this 的四个绑定规则 2.1 规则一：默认绑定 在独立函数调用的情况下会使用默认绑定 独立函数调用简单来说就是它没有绑定到某个对象上进行调用，简单看几个例子 12345// 例1function foo() &#123; console.log(this)&#125;foo() // window 1234567891011121314// 例2function foo1() &#123; console.log(this);&#125;function foo2() &#123; foo1()&#125;function foo3() &#123; foo2()&#125;foo3() // window 12345678910// 例3var obj = &#123; name: &#x27;hello&#x27;, foo: function() &#123; console.log(this); &#125;&#125;var bar = obj.foobar() // window 以上的函数调用的时候，都是没有被绑定到对象中调用的，所以 this 都指向 window 2.2 规则二：隐式绑定 函数通过某个对象进行调用的时候，这个对象会被 js 引擎绑定到函数中的 this 里 下面看几个例子： 12345678910// 1.function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, fn: foo&#125;obj.fn() // obj 对象 12345678910111213// 2.var obj1 = &#123; foo: function() &#123; console.log(this); &#125;&#125;var obj2 = &#123; title: &#x27;hello&#x27;, bar: obj1.foo&#125;obj2.bar() // obj2对象 2.3 显式绑定 利用 call，apply，bind手动指定 this 的绑定，这种明确的绑定称为显示绑定 (1) call，apply call，apply 都是可以调用函数的 fn.call(自定的this指向，参数1，参数2) fn.apply(this指向，[参数1，参数2]) 两者的区别在于传参的方式，下面例子可以看出来 call 传入参数列表，apply是数组 12345678910function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;var obj = &#123; title: &quot;hello&quot;&#125;sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;sum.apply(obj, [20,30,40]) // 手动让this指向obj (2) bind bind不会调用函数，而是返回一个新的对象。 12345678910111213function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this);&#125;// var obj = &#123;// title: &quot;hello&quot;// &#125;// sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;// sum.apply(obj, [20,30,40]) // 手动让this指向objvar newSum = sum.bind(&#x27;aaa&#x27;,10,20,30)newSum() // 60 String &#123;&#x27;aaa&#x27;&#125; 咦？newSum 不也是独立函数调用吗，怎么不指向 window 了 这就是默认绑定和显示绑定bind的冲突，显示绑定的优先级更高！ 2.4 new绑定 12345678910function Person(name, age) &#123; this.name = name this.age = age // 实际上这里是会把 this 返回出去的,即return this（默认） // this = 创建出来的对象&#125;// new 会创建一个全新的对象var p1 = new Person(&quot;jenny&quot;, 12)var p2 = new Person(&quot;tony&quot;, 15) 3. 一些内置函数的 this 绑定 有时候我们会调用一些 JS 的内置函数，这些函数要求我们传入另外一个函数，并且我们不会自己去调用这些函数，而是 JS 内部会帮助我们执行。 这个时候，this 的绑定就跟内部帮我们指向函数的方式有关系了。 看几个例子吧 3.1 setTimeout 内部通过 apply 调用函数，并绑定了this对象，是window 123setTimeout(function() &#123; console.log(this); // window&#125;, 2000) 3.2 数组的内置函数 forEach 默认情况下传入的函数是自动调用函数（默认绑定） 1234var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 window&#125;) 也可以通过传入第二个参数，改变this指向 1234var names = [&#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;ccc&#x27;]names.forEach(function(item) &#123; console.log(this); // 三次 &#x27;obj&#x27;&#125;, &#x27;obj&#x27;) 3.3 点击事件 在发生点击时，回调函数被调用，会将 this 绑定到该函数中 1&lt;div class=&quot;box&quot;&gt; &lt;/div&gt; 1234var box = document.querySelector(&quot;.box&quot;)box.onclick = function() &#123; console.log(this); // box对象&#125; 所以说，某些内置的函数，我们很难确定它内部是如何调用传入的回调函数的，可以自己测试一下，记一下，看源码当然更好啦 4. 几个规则的优先级 从高到低：new绑定 &gt; 显式绑定(bind) &gt; 隐式绑定 &gt; 默认绑定 new绑定和call，apply是不允许同时使用的，（毕竟都会调用函数），所以不存在谁的优先级更高 显示绑定高于隐式绑定 123456789101112// 显式绑定和隐式绑定function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;obj&#x27;, foo: foo&#125;obj.foo() // obj 对象obj.foo.call(&quot;aaa&quot;) // &#x27;aaa&#x27; new 绑定高于隐式绑定 12345678910function foo() &#123; console.log(this);&#125;var obj = &#123; name: &#x27;hello&#x27;, foo: foo&#125;new obj.foo() // 输出 foo 对象而不是 obj new 绑定高于bind 12345678910function foo() &#123; console.log(this, title);&#125;var obj = &#123; name: &#x27;hello&#x27;&#125;var bar = foo.bind(obj) // 显式绑定objnew bar() // 打印 foo对象 而不是 obj 5. 两种特殊情况 5.1 在显示绑定中传入 null 或 undefined 这时候，显示绑定会被忽略，使用默认规则 123456789101112function foo() &#123; console.log(this);&#125;var obj = &#123; name: &quot;hello&quot;, foo: foo&#125;foo.call(obj) // objfoo.call(null) // windowfoo.call(undefined) // window 5.2 间接函数引用 1234567891011121314151617function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;// 先来看一下这个赋值的结果, 是 foo 函数console.log((obj2.foo = obj1.foo)); // foo函数// 这种叫做间接函数引用，是会把赋值语句右边的结果返回，然后直接调用，是独立函数调用(obj2.foo = obj1.foo)() // 相当于直接调用 foo 函数，所以是默认绑定，输出window 6. 箭头函数的this 箭头函数不绑定 this，也就是说它没有自己的 this，而是根据外层作用域来决定this 123456789101112var name = &quot;hello&quot;var foo = () =&gt; &#123; console.log(this); // 在这里this的外层作用域就是 window&#125;var obj = &#123; foo: foo&#125;obj.foo() // windowobj.foo.call(&quot;aaa&quot;) // window 再来看一个案例： 使用setTimeout模拟一个网络请求，如果我们想把返回来的数据保存到 data 中，该怎么做 123456789101112131415var obj = &#123; data: &#x27;&#x27;, getData: function() &#123; setTimeout(() =&gt; &#123; console.log(this); // obj 对象 // 这里的 this 不是应该指向window吗？ // 如果我们这里使用的是普通的函数 function() &#123;console.log(this)&#125; // 那么这个函数在内部调用的时候，会绑定this，就是window // 但是我们使用了箭头函数，它不绑定this，会往上层作用域中找到对应的this // 所以找到了 obj this.data = &#x27;hello&#x27; // --&gt; obj.data = &quot;hello&quot; &#125;, 2000); &#125;&#125;obj.getData() 7. this 的面试题 如果每题都会了，那么 this 绑定的问题，就是你的送分题而不是送命题了哈哈哈 建议把我的答案跟注释都删掉，自己一点点理清哦 题一 12345678910111213141516171819var name = &quot;window&quot;; // window.name = &quot;window&quot;var person = &#123; name: &quot;person&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;;function sayName() &#123; var sss = person.sayName; sss(); // window 很明显是独立函数调用,没有与任何对象关联 person.sayName(); // person 隐式绑定,与person关联 (person.sayName)(); // person 同上(加括号只是代表这是一个整体) // console.log((b = person.sayName)); // 这里实际上就是sayName这个函数 (b = person.sayName)(); // 间接函数引用，是独立函数调用, 输出 window&#125;sayName(); 题二 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;// 隐式绑定person1对象person1.foo1(); // person1// 显式绑定person2person1.foo1.call(person2); // person2// 箭头函数不适用任何规则, 向上层作用域中找thisperson1.foo2(); // windowperson1.foo2.call(person2); // window// person1.foo3()返回了一个函数，然后独立调用person1.foo3()(); // window// person1.foo3.call(person2) 返回的是一个函数，然后独立调用person1.foo3.call(person2)(); // window// person1.foo3()返回一个函数，然后显式绑定到 person2person1.foo3().call(person2); // person2// person1.foo4()返回一个箭头函数，往上层作用域找，找到foo4中绑定的this,是 person1person1.foo4()(); // person1// foo4显示绑定到 person2person1.foo4.call(person2)(); // person2// person1.foo4()返回箭头函数，往上层作用域找person1.foo4().call(person2); // person1 题三 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.foo1 = function () &#123; console.log(this.name) &#125;, this.foo2 = () =&gt; console.log(this.name), this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() // person1 隐式绑定person1.foo1.call(person2) // person2 显式绑定person1.foo2() // person1 隐式绑定// 箭头函数不适用显式绑定规则，直接向上层作用域找person1.foo2.call(person2) // person1 // person1.foo3() 返回一个函数，在全局调用person1.foo3()() // windowperson1.foo3.call(person2)() // window // 同理// person1.foo3() 返回的函数使用 .call 显式绑定 person2person1.foo3().call(person2) //person2 // person1.foo4() 返回一个箭头函数，再调用，向上层作用域找person1.foo4()() // person1// person1.foo4.call(person2) 返回箭头函数，并且foo4显式绑定this为person2// 再调用这个箭头函数，向上找就找到 foo4 的this 为person2person1.foo4.call(person2)() // person2 // person1.foo4() 返回箭头函数,不适用显式绑定，向上找到 person1// 注意这里跟上面的区别，这里的foo4调用不是.call调用的，而是.foo4()这样调用的// call是来调用箭头函数的，而箭头函数不适用显式绑定，向上找到的是person1person1.foo4().call(person2) // person1 题四 12345678910111213141516171819202122232425262728293031323334var name = &#x27;window&#x27;function Person (name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125; &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)// person1.obj.foo1()返回一个函数，在全局中调用person1.obj.foo1()() // window// person1.obj.foo1.call(person2) 返回一个函数 在全局中调用person1.obj.foo1.call(person2)() // window// person1.obj.foo1() 返回一个函数，显式绑定person2person1.obj.foo1().call(person2) // person2// 箭头函数调用，向上找到 foo2 中的this是objperson1.obj.foo2()() // obj// foo2调用的时候显式绑定person2，箭头函数向上层找到的就是person2person1.obj.foo2.call(person2)() // person2// 箭头函数不适用 显式绑定，向上找找到 objperson1.obj.foo2().call(person2) // obj","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://hillyee.github.io/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JS内存管理和闭包","slug":"JS内存管理和闭包","date":"2022-03-30T11:53:40.000Z","updated":"2022-03-30T15:41:30.776Z","comments":true,"path":"2022/03/30/JS内存管理和闭包/","link":"","permalink":"https://hillyee.github.io/2022/03/30/JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"一、JS 的内存管理 1. JS 的内存管理 JavaScript 会在定义变量时为我们分配内存 内存分配的方式是一样的吗？ JS 对于基本数据类型内存的分配，会在执行时直接在栈空间进行分配 JS 对于复杂数据类型内存的分配，会在堆内存中开辟一块空间，并且将这块空间的地址保存在栈空间 2. JS 的垃圾回收 垃圾回收的英文是 Garbage Collection，简称 GC 对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放出更多的内存空间 JavaScript的运行环境 js引擎都会内存垃圾回收器 3. 常见的两个 GC 算法 GC怎么知道哪些对象是不再使用的呢？这里就要用到 GC 算法了 3.1 引用计数 当一个对象有一个引用指向它的时候，那么这个对象的引用就 +1，当一个对象的引用为 0 时，这个对象就可以被回收掉 但是这个算法有一个很大的弊端，就是会产生循环引用 12var obj1 = &#123;friend: obj2&#125;var obj2 = &#123;friend: obj1&#125; 3.2 标记清除 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象 ​ 图中从 A 开始找，找到 D 的时候结束，M,N不可达，被认为是不可用的对象 这个算法可以很好的解决循环引用的问题 注：JS 引擎比较广泛采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，在算法的实现细节上也会结合一些其他的算法 二、JS中的闭包 1. 什么是闭包？ JavaScript 中的一个函数，如果它访问了外层作用域的变量，那么这个函数是一个闭包。 MDN中的一个解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 12345678910111213function foo() &#123; var name = &quot;foo&quot; var age = 18 function bar() &#123; console.log(name)// name访问了外层作用域的变量name console.log(age) // age访问了外层作用域的变量age &#125; return bar // 返回一个函数&#125;var fn = foo()fn() 2. 闭包的访问过程 简单描述上面函数的执行过程： 12345678910111213141516171. GO: &#123;foo:地址1, fn:undefined&#125;2. 执行代码： 2.1 foo():只要执行函数，就会创建一个函数执行上下文 (1)VO: &#123;AO对象:&#123;name: undefined;age:undefined;bar:地址2&#125;&#125; scopechain:[VO+parent scopes] (2)开始执行代码 &#123;name: &quot;foo&quot;, age:18;&#125; return bar地址2 (3)foo执行完毕 2.2 fn: bar地址2 2.3 fn(),即执行 bar地址2中的函数执行体,创建bar的函数执行上下文 (1)&#123;AO:&#123;&#125;,scopechain&#125; (2)执行代码: console.log(name):在自己的AO中找不到，通过作用域链找到foo的AO，找到name:&quot;foo&quot;,输出 &quot;foo&quot; console.log(age)同理 (3)fn()执行完毕3.执行完毕地址1:foo函数对象: &#123;parentScope: GO&#125;,&#123;foo函数的执行体&#125;地址2:bar函数对象: &#123;parentScope: foo的AO对象&#125;,&#123;bar函数的执行体&#125; 你可能会有疑惑：foo函数执行完毕之后，不是应该弹出栈吗，foo的AO对象不应该被释放了吗？怎么bar还能找到 name，找到 age 呢？ 看下图： 可以看到，当我们执行完 foo 函数的时候，返回的是 bar 函数(或者说是bar的地址)，然后因为 fn = foo()，把这个地址赋值给了fn，因此会存在 fn 指向 bar函数对象，而bar的父作用域又指向了 foo 的AO对象，因此foo的AO是不会被释放的 3. 闭包的内存泄漏 为什么总说闭包是有内存泄漏的呢？什么是内存泄漏？ 拿上面的例子说，如果后续我们不会再用 foo，bar 这些函数了，但是在全局作用域下 fn 变量对bar函数对象有引用，而bar的作用域中AO对foo的AO有引用，所以会造成这些内存都是无法被释放的。 这就是我们所说的内存泄漏，其实就是刚才的引用链中的对象无法释放 怎么解决这个问题呢？ 很简单，设置 fn = null，就不再对 bar 函数对象有引用，那么从GO出发，bar是不可达的，那么对应的AO对象(foo) 同样也就不可达。 在下一次 GC 的的检测中，它们就会被销毁掉 还有一个问题，形成闭包之后，是不是所有的属性都不会被释放呢？ 还是这个例子 1234567891011121314function foo() &#123; var name = &quot;why&quot; var age = 18 function bar() &#123; console.log(name) // console.log(age) &#125; return bar&#125;var fn = foo()fn() 如果age不使用了，会不会被销毁掉呢？ 答案是会的，测试如下： 这是因为 V8 引擎做的优化，因为规范中闭包的属性应该是不会被销毁的","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://hillyee.github.io/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"深入JS运行原理","slug":"深入JS运行原理","date":"2022-03-30T10:49:46.000Z","updated":"2022-03-30T15:40:16.555Z","comments":true,"path":"2022/03/30/深入JS运行原理/","link":"","permalink":"https://hillyee.github.io/2022/03/30/%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"1. 从输入 URL 到页面展示 发生了什么？ 总体分为以下过程： DNS 域名解析：将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 2. 浏览器工作原理 在浏览器中输入查找内容，浏览器是怎样将页面加载出来的？ 大致流程如下： 首先，用户输入服务器地址，与服务器建立连接 服务器返回对应的静态资源（index.html） 然后浏览器拿到 index.html 后进行解析 当解析时遇到 css 或 js 文件，就向服务器请求并下载对应的 css 和 js 文件 最后浏览器对页面进行渲染，执行 js 代码 3. 浏览器渲染过程 HTML Parser 将 HTML解析转换成 DOM 树 CSS Parser 将 样式表转换成 CSS 规则树 合并 DOM 树和 CSS 规则树，生成 render（渲染） 树 布局 render 树（Layout） 通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 绘制 render 树（painting），进行 Display 展示 注意图中顶部的紫色 DOM 三角形，实际上是 js 对 DOM 的相关操作。 4. 一个强大的 JavaScript 引擎 — V8 引擎 在解析 HTML 的过程中，遇到了 JavaScript 标签，该怎么办呢？ 会停止解析 HTML ，而去加载和执行 JavaScript 代码 那么，JavaScript 代码由谁来执行呢？ JavaScript 引擎 高级的编程语言最终都要转成机器指令来执行的， 所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行 （1）V8 引擎的架构 V8 的底层架构主要有三个核心模块（Parse、Ignition、TurboFan） 1. Parse： 该过程主要是对 JavaScript 源代码进行词法分析和语法分析。 词法分析：对代码中的每一个词每一个符号进行解析，最终生成很多 tokens 例如：对 const name = “curry” 123456789101112// 首先对const进行解析，因为const为一个关键字，所以类型会被记为一个关键词，值为consttokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;]// 接着对name进行解析，因为name为一个标识符，所以类型会被记为一个标识符，值为nametokens: [ &#123; type: &#x27;keyword&#x27;, value: &#x27;const&#x27; &#125;, &#123; type: &#x27;identifier&#x27;, value: &#x27;name&#x27; &#125;]// 以此类推... 语法分析：在词法分析的基础上，拿到 tokens 中的一个个对象，根据不同类型，再进一步分析具体语法，最终生成 AST 抽象语法树 可以详细查看通过 Parse 转换后的 AST 的工具：AST Explorer 2. Ignition 一个解析器，可以将 AST 转换成 ByteCode（字节码） 3. TurboFan 一个编译器，可以将字节码编译为 CPU 认识的机器码 （2）V8 引擎的执行过程 Blink 内核将 JS 源码交给 V8 引擎 Stream 获取到 JS 源码进行编码转换 Scanner 进行词法分析，将代码转换成 tokens Parser 和 PreParser Parser ：直接解析，将 tokens 转成 AST 树 PreParser：预解析，对不必要的函数进行预解析，也就是只解析暂时需要的内容，而在函数被调用时才进行函数的全量解析 生成 AST 树后，会被 Ignition 转成字节码，之后就是代码的执行过程 5. JavaScript 的执行过程 假如要执行如下代码： 123456var title = &quot;hello&quot;console.log(num1)var num1 = 20var num2 = 30var result = num1 + num2console.log(result) （1）首先，代码被解析，V8 引擎内部会帮助我们创建一个全局对象：Global Object（GO） GO 可以访问所有的作用域 里面会包含 Date、Array、String、setTimeout等等（所以我们可以直接 new Date() ） GO 还有一个window 属性指向自己（所以window.window.window还是指向 GO自己） 用伪代码表示为： 123456var globalObject = &#123; String: 类, setTimeout: 函数, ... window: globalObject&#125; （2）然后运行代码 首先我们要知道 js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ESC），它是用于执行代码的调用栈。 为了全局代码能够正常执行，首先需要创建一个**全局执行上下文 **（Global Execution Context，简称GEC），全局代码需要被执行时才会创建 然后全局执行上下文会被放入执行上下文栈中执行，包含两个部分： 在代码执行前，会将全局定义的变量，函数等加入到 GlobalOject 中，但是并不会赋值（也称为变量的作用域提升） 开始依次执行代码： title = “hello” // 赋值 console.log(num1) // undefined, 不会报错 num1= 20 … 遇到函数如何执行? 先根据函数体创建一个函数执行上下文，并且压入到执行上下文栈中 作用域链？ 由 VO(变量对象，在函数中就是 AO 对象)和 父级 VO组成，查找时会一层层查找 看一个例子： 123456789101112var message = &quot;Hello Global&quot;function foo() &#123; console.log(message) // Hello Global&#125;function bar() &#123; var message = &quot;Hello Bar&quot; foo()&#125;bar() 比如说这里，当执行 foo 函数的时候， foo 的 AO 中没有message，就会去它的父级 VO 中查找。一定要注意！当第一次代码解析的时候， foo 的函数执行上下文就已经确定了，其中包括三部分： 第一部分：在解析函数成为 AST 树结构的时候，会创建一个 AO（Activation） 其中包含形参、arguments、函数定义、指向函数对象或定义的变量 第二部分：就是作用域链 第三部分：this 绑定的值 因此！当foo在自己的AO找不到message的时候，去父级 VO 找，这个父级 VO 就是一开始解析时候保存的 GO，所以message为 “Hello Global” 简单描述一下这个过程吧：(我不专业的表达) 1234567891011121314// 初始化 GOGO: &#123;window; message:undefined; foo: 地址1; bar: 地址2;&#125;// 执行代码GO: &#123;window; message:&quot;Hello Global&quot;; foo: 地址1; bar: 地址2;&#125;bar函数执行,创建一个函数执行上下文, 其中包括 VO对象: AO:&#123;message: undefined&#125; 然后开始执行 bar函数 message:&quot;Hello Bar&quot; (赋值) foo() foo函数执行，创建一个foo的函数执行上下文 其中包括：VO: AO: &#123;&#125; 然后开始执行代码 console.log(message) 发现自己的AO没有message,会向上找，即从自己保存的父级VO中查找，找到GO中的message为 &quot;Hello Global&quot; (图来源于coderwhy) 几道常见的作用域提升面试题： var n = 100 function foo() &#123; n = 200 &#125; foo() console.log(n) // 200 123456789102. ```js function foo() &#123; console.log(n) // undefined var n = 200 console.log(n) // 200 &#125; var n = 100 foo() var a = 100 function foo() &#123; console.log(a) // undefined return var a = 200 &#125; foo() 123456784. ```js function foo() &#123; m = 100 &#125; foo() console.log(m) // 100 function foo() &#123; var a = b = 10 // =&gt; 转成下面的两行代码 // var a = 10 // b = 10 &#125; foo() //console.log(a) // 报错 a is not defined(因为当 foo函数执行完之后，foo的函数执行上下文就会弹出栈(没啦！哪里还会有a呢)) console.log(b) // 10","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://hillyee.github.io/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-29T14:25:03.367Z","updated":"2022-03-29T14:25:03.367Z","comments":true,"path":"2022/03/29/hello-world/","link":"","permalink":"https://hillyee.github.io/2022/03/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"网络传输/","slug":"网络传输","permalink":"https://hillyee.github.io/categories/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://hillyee.github.io/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JS","slug":"JS","permalink":"https://hillyee.github.io/tags/JS/"},{"name":"JS高级","slug":"JS高级","permalink":"https://hillyee.github.io/tags/JS%E9%AB%98%E7%BA%A7/"}]}
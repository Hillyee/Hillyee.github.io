<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>学习TypeScript | Hillyee-blog</title><meta name="keywords" content="-TS"><meta name="author" content="Hillyee"><meta name="copyright" content="Hillyee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TypeScript初识  JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题  TS简介 Typescript是拥有类型的JavaScript超集 JavaScript所拥有的特性，TS全部都支持，并且在语言层面上添加了类型约束，还加上一些语法的扩展 TS的编译环境 TS最终还是会被编译成JS代码运行，所以我们需要搭建对应的环境 在电脑上安装Typescript"><meta property="og:type" content="article"><meta property="og:title" content="学习TypeScript"><meta property="og:url" content="https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/index.html"><meta property="og:site_name" content="Hillyee-blog"><meta property="og:description" content="TypeScript初识  JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题  TS简介 Typescript是拥有类型的JavaScript超集 JavaScript所拥有的特性，TS全部都支持，并且在语言层面上添加了类型约束，还加上一些语法的扩展 TS的编译环境 TS最终还是会被编译成JS代码运行，所以我们需要搭建对应的环境 在电脑上安装Typescript"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img1.baidu.com/it/u=953166472,1374371628&fm=253&fmt=auto&app=138&f=JPEG?w=955&h=500"><meta property="article:published_time" content="2022-04-15T11:22:29.000Z"><meta property="article:modified_time" content="2022-04-15T11:24:46.813Z"><meta property="article:author" content="Hillyee"><meta property="article:tag" content="-TS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img1.baidu.com/it/u=953166472,1374371628&fm=253&fmt=auto&app=138&f=JPEG?w=955&h=500"><link rel="shortcut icon" href="https://img2.baidu.com/it/u=2994714379,3709164052&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=506"><link rel="canonical" href="https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"学习TypeScript",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-15 19:24:46"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Hillyee-blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=752629441,1211736544&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 🙆首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fas fa-list"></i><span> 🐹目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 🙈分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 🐱标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 🐌时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 🥩关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img1.baidu.com/it/u=953166472,1374371628&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=955&amp;h=500)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hillyee-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 🙆首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fas fa-list"></i><span> 🐹目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 🙈分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 🐱标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 🐌时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 🥩关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学习TypeScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-15T11:22:29.000Z" title="发表于 2022-04-15 19:22:29">2022-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-15T11:24:46.813Z" title="更新于 2022-04-15 19:24:46">2022-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/">深入Vue3+Typescript学习⚡</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="学习TypeScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>TypeScript初识</h1><blockquote><p>JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题</p></blockquote><h2 id="TS简介">TS简介</h2><p>Typescript是拥有类型的JavaScript超集</p><p>JavaScript所拥有的特性，TS全部都支持，并且在语言层面上添加了类型约束，还加上一些语法的扩展</p><h2 id="TS的编译环境">TS的编译环境</h2><p>TS最终还是会被编译成JS代码运行，所以我们需要搭建对应的环境</p><p>在电脑上安装Typescript，这样就可以通过TypeScript的Compiler将其编译成JavaScript</p><p>全局安装：<code>npm install typescript -g</code></p><p>查看版本：<code>tsc --version</code></p><h2 id="TS的运行环境">TS的运行环境</h2><p>运行的两个步骤：</p><ol><li><code>tsc xxx.ts</code> 把ts文件编译成JS代码</li><li>在浏览器或Node环境下运行JS代码</li></ol><p>如果每次都要做这两个步骤，那就太麻烦了</p><p>有什么简化的方式呢？</p><p>第一种：通过webpack，配置本地的TS编译环境和开启一个本地服务，可以直接运行在浏览器上</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f81ce51bbcd4d06b0e99f3148f0056f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%"> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d656d7ffb32e46f4b65292186998a1cf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%"><p>第二种：通过ts-node库，为TS的运行提供执行环境</p><ul><li><p>安装 ts-node：<code>npm install ts-node -g</code></p></li><li><p>另外 ts-node需要安装依赖 tslib 和 @types/node 两个包</p><p><code>npm install tslib @types/node -g</code></p></li><li><p>然后可以直接通过 ts-node 来运行 TS 的代码：</p><p><code>ts-node xxx.ts</code></p></li></ul><h1>变量的声明</h1><ul><li><p>定义的时候给标识符加类型： var/let/const 标识符: 数据类型 = 赋值</p><p>但是 var 不推荐使用</p><p>另外注意 string 和 String 的区别</p><p>string是TypeScript中定义的字符串类型，String是ECMAScript中定义的一个包装类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: string = <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>类型推断（推导），就是说我们第一次给变量赋值的时候，会根据这个赋值的内容，自动推断变量的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span> <span class="comment">// 自动类型推断为number类型</span></span><br><span class="line">num = <span class="string">&quot;123&quot;</span>  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>推荐：如果可以自动推导出变量的类型的时候，不加类型</p><p>不确定类型的时候，要自己加上类型</p></blockquote><h1>数据类型</h1><p>我们常说TS是JS的一个超集</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cbda679e37349e98f0c39d0213cfef9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%"><h2 id="JS类型">JS类型</h2><blockquote><p>TS和JS都有的数据类型</p></blockquote><ol><li><strong>number类型</strong></li></ol><p>TS 和 JS一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: number = <span class="number">123</span></span><br><span class="line">num = <span class="number">222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// num = &quot;123&quot; // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TS 也支持进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num1</span>: number = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: number = <span class="number">0b100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num3</span>: number = <span class="number">0o100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num4</span>: number = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4); <span class="comment">// 100 4 64 256</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>boolean类型</strong></li></ol><p>true、false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: boolean = truelet <span class="attr">flag</span>: boolean = <span class="literal">true</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">flag = <span class="number">20</span> &gt; <span class="number">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>string类型</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;hello&quot;</span></span><br><span class="line">message = <span class="string">&#x27;hello ts&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样也支持ES6的模板字符串</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`hi <span class="subst">$&#123;message&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// hi hello ts</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Array类型</strong></li></ol><p>固定数组里面存放的数据类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">name1</span>: string[] = [] <span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// name1.push(1) // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name2</span>: <span class="title class_">Array</span>&lt;string&gt; = [] <span class="comment">// 不推荐(react jsx中是有冲突)   </span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Object类型</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>:object = &#123;  <span class="comment">// 在这里设置了object类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;kkk&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[<span class="string">&quot;age&quot;</span>]);</span><br></pre></td></tr></table></figure><p>设置了object类型不能获取数据也不能设置数据<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/688374ddd57d49b89dd0ebe6506e3ec1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%"></p><p>如果去掉了:object就可以获取，并且里面的属性类型也有推断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[<span class="string">&quot;age&quot;</span>]) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>Symbol类型</strong></li></ol><blockquote><p>跟 JS 一样，主要用于设置唯一属性名</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">title1</span>: symbol = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"><span class="comment">// title1 = 2 // number赋值给symbol类型,报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title2 = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>) <span class="comment">// 推断</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [title1]: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  [title2]: <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>Null 和 Undefined类型</strong></li></ol><p>null：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n1</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">n1 = <span class="number">123</span> <span class="comment">// number -&gt; null 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="literal">null</span>  <span class="comment">// 推断是 any类型</span></span><br><span class="line">n2 = <span class="number">123</span> <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>同理：undefined：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n3</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line">n3 = <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n4 = <span class="literal">undefined</span></span><br><span class="line">n4 = <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="TypeScript类型">TypeScript类型</h2><h3 id="any类型">any类型</h3><p>any表示任意类型</p><p>在不确定变量类型的时候，可以使用any类型，但是一旦使用了，意味着我们可以对any类型的变量进行任何的操作，包括赋值任何类型的值；获取不存在的属性、方法</p><p>非常不安全，不推荐使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: any = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">message = <span class="number">123</span></span><br><span class="line">message = <span class="literal">true</span></span><br><span class="line">message = &#123;&#125;</span><br><span class="line"></span><br><span class="line">message.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="unknown类型">unknown类型</h3><p>用于描述类型不确定的变量</p><p>unknown类型只能赋值给any和unknown类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: unknown  <span class="comment">// 如果使用any就不会报错了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  result = <span class="title function_">foo</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免拿到结果之后乱用</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = result </span><br><span class="line"><span class="comment">// 不能将类型“unknown”分配给类型“string”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h3 id="void类型">void类型</h3><p>void通常来指定一个函数没有返回值的，那么它的返回值就是void类型</p><p>另外，这个函数可以返回 null，undefined</p><blockquote><p>一般都不写的，因为没有返回值默认推断就是void</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);         <span class="comment">// 这里写不写void都一样的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="never类型">never类型</h3><p>表示永远不会发生值的类型</p><blockquote><p>never表示函数用于执行不到返回值那一步（抛出异常或死循环）的返回值类型</p><p>而void是函数没有返回值，可以返回null，undefined</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>() <span class="comment">// 抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>never 有什么应用场景？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function handleMessage(message: string | number ) &#123;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: string | number | boolean </span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> message) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;number方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;boolean方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      <span class="comment">// 默认不会执行到返回值那一步,所以如果你没有对应的处理逻辑,就会报错</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">check</span>: never = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候有人想要传入 boolean类型</span></span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 但发现报错了, 然后就给函数参数加上boolean类型</span></span><br><span class="line"><span class="comment">// 然后就不报错了,但是函数里面并没有处理boolean参数的逻辑,他并不知道</span></span><br><span class="line"><span class="comment">// 如果, 加上default那一段,就会报错</span></span><br><span class="line"><span class="comment">// 这时候这个人就知道里面需要有boolean的处理逻辑,然后就去加上</span></span><br></pre></td></tr></table></figure><h3 id="tuple类型">tuple类型</h3><p>tuple 是<strong>元组</strong>类型，元组中每个元素都有自己特定的类型，根据索引值获取到的值可以确定对应的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: [string, number, number] = [<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = info[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">length</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>而数组通常建议存放相同类型的值</p></blockquote><p>tuple应用场景</p><p>tuple通常可以作为返回的值，在使用的时候会非常的方便</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> useState&lt;T&gt;(<span class="attr">state</span>: T) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeState</span> = (<span class="params">newState: T</span>) =&gt; &#123;</span><br><span class="line">    currentState = newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">info</span>: [string, number] = [<span class="string">&#x27;xxx&#x27;</span>, <span class="number">18</span>]</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">tuple</span>: [T, <span class="function">(<span class="params">newState: T</span>) =&gt;</span> <span class="keyword">void</span>] = [currentState, changeState]</span><br><span class="line">  <span class="keyword">return</span> tuple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">setCounter</span>(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">const</span> [title, setTitle] = <span class="title function_">useState</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = <span class="title function_">useState</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="函数的参数和返回值类型">函数的参数和返回值类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般可以不写返回值的类型，会自动推断</span></span><br><span class="line"><span class="comment">// function sum(num1: number, num2: number): number &#123;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>, <span class="number">321</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>]</span><br><span class="line"><span class="comment">// 我们并没有指定item的类型</span></span><br><span class="line"><span class="comment">// 但是TypeScript会根据forEach函数的类型以及数组的类型推断出item的类型, 这个时候可以不添加的类型注解</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象类型">对象类型</h3><p>如果我们希望限定一个函数接收的参数是一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123;x: number, y: number&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(&#123;<span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">321</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="联合类型">联合类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: number | string</span>) &#123;</span><br><span class="line">	<span class="comment">// id 可以是number 也可以是 string类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用联合类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: number | string</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用联合类型的值时，需要特别的小心</span></span><br><span class="line">  <span class="comment">// narrow：缩小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定id是string类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选类型">可选类型</h3><p>对象类型也可以指定哪些属性是可选的，可以在属性后面加一个?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123;x: number, y:number, z?:number&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个属性可传可不传</p><p>另外，可选类型可以看做是类型和undefined的联合类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message?: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 什么都不传实际上就是代表undefined</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><h3 id="类型别名">类型别名</h3><p>我们可以给对象类型起一个别名，方面我们后续使用</p><p>用到了关键字 <strong>type</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">IDType</span> = string | number</span><br><span class="line">type <span class="title class_">PointType</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">  z?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: PointType</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言-as">类型断言 as</h3><p>将类型转换为更具体的类型</p><p>本来不加类型断言的话，TS只会把el推断为HTMLElement类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;xxx&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br><span class="line">el.<span class="property">src</span> = <span class="string">&quot;url地址&quot;</span></span><br></pre></td></tr></table></figure><p>案例2：Person 是 Student 的父类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">p: Person</span>) &#123;</span><br><span class="line">  <span class="comment">// 不断言的话会报错：类型“Person”上不存在属性“studying”</span></span><br><span class="line">  (p <span class="keyword">as</span> <span class="title class_">Student</span>).<span class="title function_">studying</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非空类型断言">非空类型断言!</h3><p>! 用于确定某个标识符是有值的，跳过 ts 在编译阶段时对它的检测</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message 可以是string/undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message?: string</span>) &#123;</span><br><span class="line">  <span class="comment">// 当然可以直接if判断</span></span><br><span class="line">  <span class="comment">// if(message) &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是！更简洁</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message!.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链">可选链</h3><blockquote><p>实际上是 ES11 增加的特性</p></blockquote><p><code>?.</code> 操作符，作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  friend?: &#123;</span><br><span class="line">    f1?: &#123;</span><br><span class="line">      <span class="attr">name</span>: string</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(info.friend.f1); // friend不存在,取不到f1,报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">f1</span>); <span class="comment">// undefined, 不报错</span></span><br><span class="line"><span class="comment">// info.friend存在吗？存在再继续取f1</span></span><br></pre></td></tr></table></figure><h3 id="和-运算符">?? 和 !! 运算符</h3><blockquote><p>?? 是 ES11新增的特性</p></blockquote><p>**空值合并操作符 ?? **，是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> res = message ?? <span class="string">&quot;123&quot;</span>  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure><p><strong>!!操作符</strong>，将一个其他类型转换成boolean类型，类型Boolean(变量)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> flag1 = <span class="title class_">Boolean</span>(message)</span><br><span class="line"><span class="keyword">let</span> flag2 = !!message</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag1); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字面量类型">字面量类型</h3><p>字面量也可以当做类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">msg</span>:<span class="string">&quot;hello&quot;</span> = <span class="string">&quot;hello&quot;</span> <span class="comment">// 但是msg的值只能是&quot;hello&quot;</span></span><br><span class="line">msg = <span class="string">&quot;asd&quot;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>那有什么意义呢？可以将多个类型联合在一起</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Alignment</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;center&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAlign</span>(<span class="params">align: Alignment</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改方向:&#x27;</span>, align);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeAlign</span>(<span class="string">&quot;center&quot;</span>) <span class="comment">// 只能传入定义的三个字面量类型</span></span><br></pre></td></tr></table></figure><h3 id="字面量推理">字面量推理</h3><p>下面的代码，默认情况下info 进行类型推断的时候，method是string类型</p><p>加上as const 后，methods就是&quot;GET&quot;字面量类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;https://hillyee.github.io&quot;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">&#125;  <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// 加上as const 后，methods就是&quot;GET&quot;字面量类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: string, method: <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">request</span>(info.<span class="property">url</span>, info.<span class="property">method</span>) <span class="comment">// https://hillyee.github.io GET</span></span><br><span class="line"><span class="comment">// 默认：类型“string”的参数不能赋给类型“&quot;GET&quot; | &quot;POST&quot;”的参数。</span></span><br></pre></td></tr></table></figure><h3 id="类型缩小">类型缩小</h3><p>Type Narrowing 类型缩小</p><p>可以通过类似于 typeof padding === “number” 的判断语句，来改变TypeScript的执行路径</p><p>在给定的执行路径中，缩小比声明时更小的类型，这个过程称之为 缩小</p><p>而我们编写的<code>typeof padding === &quot;number</code> 可以称之为类型保护</p><p>常见的类型保护：</p><ul><li><p>typeof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">IDType</span> = number | string</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;</span><br><span class="line">  <span class="comment">// 这外面使用id是 IDtype 类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里面确认id是string类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 确认是number类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>平等缩小（=== == !== !=/switch）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;top&quot;</span> | <span class="string">&quot;bottom&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.if判断</span></span><br><span class="line">  <span class="comment">// if (direction === &#x27;left&#x27;) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(direction)</span></span><br><span class="line">  <span class="comment">// &#125; else if ()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.switch判断</span></span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//  case ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>instanceof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params">p: Student | Teacher</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p <span class="keyword">instanceof</span> <span class="title class_">Student</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>in</p><blockquote><p>属性是否存在某对象上</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">animal: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;swimming&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">running</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fish</span>:<span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">walk</span>(fish)</span><br></pre></td></tr></table></figure></li></ul><h2 id="TS函数类型">TS函数类型</h2><ol><li><p>定义常量时，编写函数的类型</p><p>(num1: number, num2: number) =&gt; number 就是一个函数类型，并接收两个参数num1，num2，并且都是number类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number</span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">a1: number, a2: number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数作为参数时，在参数中如何编写类型？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">FooFnType</span> = <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn: FooFnType</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(foo)</span><br></pre></td></tr></table></figure></li><li><p>参数的可选类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: number, y?: number</span>) &#123;&#125; <span class="comment">// y可选</span></span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: number, y: number = <span class="number">6</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩余参数</p><p>将一个不定数量的参数放到一个数组中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: number[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    total += num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="this类型">this类型</h2><p>当this不确定的时候，通常TS会要求我们明确的指定this的类型</p><p>如果不指定的话，非常不安全，因为有可能直接调用函数或者通过别的对象来调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type thisType = &#123; <span class="attr">name</span>: string &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"><span class="variable language_">this</span>: thisType, message: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">eating</span>: eating</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">info.<span class="title function_">eating</span>(<span class="string">&quot;asd&quot;</span>) <span class="comment">// this是info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定</span></span><br><span class="line">eating.<span class="title function_">call</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;kkk&quot;</span>&#125;, <span class="string">&quot;hehehe&quot;</span>)</span><br><span class="line"><span class="comment">// &#123; name: &#x27;kkk&#x27; &#125;</span></span><br><span class="line"><span class="comment">// kkk eating hehehe</span></span><br></pre></td></tr></table></figure><h2 id="函数的重载">函数的重载</h2><blockquote><p>函数的重载在实际开发也不是必须要用的，如果本来可以用联合类型简单实现的话，优先选择联合类型</p></blockquote><p>例如有一个需求，希望对字符串和数字类型进行相加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: number | string, a2: number | string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a1 + a2</span></span><br><span class="line">  <span class="comment">// TS 会把 string | number 当做是一个类型</span></span><br><span class="line">  <span class="comment">// 运算符“+”不能应用于类型“string | number”和“string | number”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>以上通过联合类型的方式实现有两个缺点：</p><ul><li>进行很多的逻辑判断（类型缩小）</li><li>返回值的类型依然不确定</li></ul><p><strong>函数的重载是什么？</strong></p><p>函数的名称相同，但是参数不同的几个函数就是函数的重载，并且是没有函数执行体的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构成函数重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: number, num2: number</span>):number</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: string, num2: string</span>):string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line"><span class="comment">// 如果有函数重载，执行体是不能直接被调用的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: any, num2: any</span>): any &#123;</span><br><span class="line">  <span class="comment">// 如果是 string 就返回长度相加</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> num2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1.<span class="property">length</span> + num2.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 先找到函数的声明 再找执行体</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">add</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add(&#123;name: &quot;xxx&quot;&#125;, &#123;age: 18&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>以上案例确实使用函数重载实现更方便，所以可以选择函数重载</p></blockquote><h1>TS类的使用</h1><blockquote><p>这部分，实际开发中相对用的少一点，所以笔记暂时记的比较粗糙</p></blockquote><p><strong>类的定义</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的继承</strong> extends super 关键字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number, sno: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的多态</strong></p><blockquote><p>不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现</p></blockquote><p><strong>类的成员修饰符</strong></p><ol><li><p>public</p><p>共有的，默认编写的属性就是public</p></li><li><p>private</p><p>仅在同一类中可见</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  private <span class="attr">_name</span>: string = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问器setter/getter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 setter/getter 是访问器属性，这样外界就可以存储</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">p.<span class="property">name</span> <span class="comment">// 会调用get访问器</span></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;kkk&quot;</span> <span class="comment">// set</span></span><br></pre></td></tr></table></figure></li><li><p>protected</p><p>仅在类自身<strong>及子类</strong>中可见、受保护的属性和方法</p></li></ol><p><strong>只读属性readonly</strong></p><p>只读属性是可以在构造器中赋值, 赋值之后就不可以修改</p><p>属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string</span><br><span class="line">  age?: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>静态成员</strong></p><p>通过关键字<strong>static</strong>来定义，直接通过类调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">time</span>: string = <span class="string">&quot;20:00&quot;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">attendClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;去上课&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property">time</span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">attendClass</span>()</span><br></pre></td></tr></table></figure><p><strong>抽象类abstract</strong></p><p>抽象类：</p><ul><li>以abstract 声明的类是抽象类</li><li>抽象类和其他类区别不大，但是不能被实例化（不能通过new调用）</li><li>抽象类就是专门用来被继承的类</li></ul><p>抽象方法：没有具体实现（没有方法体），抽象方法必须存在于抽象类中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shape.<span class="title function_">getArea</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  abstract <span class="title function_">getArea</span>(): number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  private <span class="attr">width</span>: number</span><br><span class="line">  private <span class="attr">height</span>: number</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: number, height: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写方法</span></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">20</span>, <span class="number">30</span>) </span><br><span class="line"><span class="title function_">makeArea</span>(rectangle)</span><br></pre></td></tr></table></figure><p><strong>类的类型</strong></p><p>类本身可以作为一个类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = &#123;  <span class="comment">// p1的类型是Person类，所以必须要传name</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>TS接口的使用</h1><p>除了可以通过type开声明一个对象类型，还可以通过接口来声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，接口中也可以定义可选属性，只读属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string</span><br><span class="line">  age?: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>索引类型</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IndexLanguage</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: number]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">frontLanguage</span>: <span class="title class_">IndexLanguage</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;HTML&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;CSS&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&quot;Vue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数类型</strong></p><p>用过接口interface来定义函数类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">CalcFunc</span> &#123;</span><br><span class="line">  (<span class="attr">num1</span>: number, <span class="attr">num2</span>: number):number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然还是推荐使用类型别名来定义函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number</span><br></pre></td></tr></table></figure><p><strong>接口继承</strong></p><p>接口和类一样可以进行继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IRunning</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IPerson</span> <span class="keyword">extends</span> <span class="title class_">ISwim</span>, <span class="title class_">IRunning</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">action</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的实现</strong></p><p><strong>implements</strong> 用于指定 class 满足某个接口，而且类可以实现多个接口</p><blockquote><p>不是很懂</p><p>面向接口开发</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> implements <span class="title class_">ISwim</span>, <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swim</span>(<span class="params">swimmer: ISwim</span>) &#123;</span><br><span class="line">  swimmer.<span class="title function_">swimming</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title function_">swim</span>(p)</span><br></pre></td></tr></table></figure><p><strong>交叉类型</strong></p><p>一种类型合并，表示需要满足多个类型的条件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">MyType</span> = number &amp; string</span><br></pre></td></tr></table></figure><p><strong>interface 和 type 区别</strong></p><p>interface可以重复对某个接口来定义属性和方法</p><p>而type定义的是别名，别名是不能重复的</p><p><strong>字面量赋值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="attr">height</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">person: IPerson</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printInfo(&#123;</span></span><br><span class="line"><span class="comment">//   name: &quot;xxx&quot;,</span></span><br><span class="line"><span class="comment">//   age: 18,</span></span><br><span class="line"><span class="comment">//   height: 1.88,</span></span><br><span class="line"><span class="comment">//   address: &quot;广州市&quot;  // 报错</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="comment">// 定义字面量</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printInfo</span>(info) <span class="comment">// 再赋值就不会报错</span></span><br></pre></td></tr></table></figure><p>这是因为TypeScript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。</p><p>但是之后如果我们是将一个 变量标识符赋值给其他的变量时，会进行freshness擦除操作</p><h1>TS枚举类型</h1><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型</p><p>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</p><p>定义枚举类型的关键字：<strong>enum</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">turnDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">LEFT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向左&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">RIGHT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向右&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">TOP</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向上&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">BOTTOM</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向下&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">foo</span>: never = direction;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>TS泛型</h1><blockquote><p>非常重要！</p></blockquote><h2 id="基本使用">基本使用</h2><p>简单来说就是，类型参数化</p><p>类型决定在调用函数的时候</p><p>基本使用：多加一个<code>&lt;Type&gt;</code>参数来接收类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> sum&lt;<span class="title class_">Type</span>&gt;(<span class="attr">num1</span>: <span class="title class_">Type</span>):<span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum&lt;number&gt;(<span class="number">10</span>)</span><br><span class="line">sum&lt;string&gt;(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">sum&lt;&#123;<span class="attr">name</span>: string&#125;&gt;(&#123;<span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>还有一种调用方式，类型推导</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sum</span>(<span class="number">50</span>) <span class="comment">// 那么类型Type就是字面量50</span></span><br></pre></td></tr></table></figure><p>另外，还可以传入多个类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> foo&lt;T, E, O&gt;(<span class="attr">arg1</span>: T, <span class="attr">arg2</span>: E, <span class="attr">arg3</span>: O, ...<span class="attr">args</span>: T[]) &#123;</span><br><span class="line"><span class="comment">// ...args: T[] 是剩余参数,放到一个数组，只能选择前面&lt;&gt;定义的类型,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo&lt;number, string, boolean&gt;(<span class="number">10</span>, <span class="string">&quot;aaa&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>开发时常用的名称：</p><p>T：Type的缩写，类型</p><p>K、V：key和value的缩写，键值对</p><p>E：Element的缩写，元素</p><p>O：Object的缩写，对象</p><h2 id="泛型接口">泛型接口</h2><p>定义接口中使用泛型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">IPerson</span>&lt;string&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类">泛型类</h2><p>定义类使用泛型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;<span class="variable constant_">T1</span>, <span class="variable constant_">T2</span>&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable constant_">T1</span></span><br><span class="line">  <span class="attr">age</span>: <span class="variable constant_">T2</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: T1, age: T2</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kkk&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己定义类型</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;string, number&gt;(<span class="string">&#x27;xxx&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>:<span class="title class_">Person</span>&lt;string, number&gt; = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><h2 id="泛型约束">泛型约束</h2><blockquote><p>给类型参数一点约束</p></blockquote><p>关键字 <strong>extends</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的参数必须有length属性</span></span><br><span class="line"><span class="title function_">getLength</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="title function_">getLength</span>([<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>])</span><br><span class="line"><span class="title function_">getLength</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><h1>TS其他内容</h1><h2 id="模块化开发">模块化开发</h2><p>TS有两种方式控制作用域</p><h3 id="模块化">模块化</h3><p>支持ES Module，CommonJS</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ebf34f36dc4e0299f70e0bfb5cf699~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%"><h3 id="命名空间namespace">命名空间namespace</h3><p>是将一个模块内部再进行作用域的划分，防止一些命名 冲突的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了其他文件能使用，这里还要导出</span></span><br><span class="line"><span class="keyword">export</span> namespace time &#123;</span><br><span class="line">  <span class="comment">// 内部要export导出，才能在这个ts模块中使用</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">time: string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2022-4-13&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他的逻辑</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">name</span>: string = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> namespace price &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">price: number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;99.99&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TS早期的东西，个人还是选择模块化</p></blockquote><h2 id="类型的查找">类型的查找</h2><p>在之前，我们除了自己编写类型，还有用到一些其他的类型，比如说</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;image&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br></pre></td></tr></table></figure><p>HTMLImageElement 类型来自哪里呢？</p><p>首先我们需要知道一种ts文件：<code>.d.ts</code>为后缀名的文件</p><ul><li>这种文件是用来做类型的声明的（declare）。它仅仅用来做类型检测，告诉typescript我们有哪些类型</li><li>这种文件是不需要转成js文件来运行的</li></ul><p>那么typescript会在哪里查找我们的类型声明呢？</p><p>有三种：</p><ul><li><p>内置类型声明</p><p>typescript自带的，帮助我们内置了JS运行时的一些标准化API的声明文件</p><p>比如如Math、Date等内置类型，也包括DOM API，比如Window、Document等</p><p>内置类型声明通常在我们安装typescript环境中会带有</p><blockquote><p>github:<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></p></blockquote></li><li><p>外部定义类型声明</p><p>通常是我们使用一些库时，需要的一些类型声明</p><p>这些库有两种类型声明方式</p><ol><li>在自己库中进行类型声明（编写.d.ts文件），比如axios</li><li>通过社区的一个公有库DefinitelyTyped存放类型声明文件</li></ol><blockquote><p>github链接：</p><p>该库的GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></p><p>该库查找声明安装方式的地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt/search?search=">https://www.typescriptlang.org/dt/search?search=</a></p><p>比如我们需要安装react的类型声明，就可以去查找安装方式</p></blockquote></li><li><p>自定义类型声明</p><p>比如我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p><p>这时候我们要自己声明类型文件：</p><p>任意一个项目文件夹下定义<code>.d.ts</code> 文件，ts会自己找到的</p><p>声明模块关键字：<strong>declare</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明模块</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: any[]</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>声明变量-函数-类</strong></p><p>在<code>.d.ts</code> 文件中声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="keyword">let</span> <span class="attr">myName</span>: string</span><br><span class="line">declare <span class="keyword">let</span> <span class="attr">myAge</span>: number</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是声明类型, 不需要执行体</span></span><br><span class="line">declare <span class="keyword">function</span> <span class="title function_">myFoo</span>(<span class="params"></span>): <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">declare <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他地方使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFoo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>声明模块</strong></p><p>声明模块的语法: declare module ‘模块名’ {}。</p><p>在声明模块的内部，可以通过export导出对应库的类、函数等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: any[]</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明文件</strong></p><blockquote><p>文件会被当成模块使用，然后就可以引入</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jepg&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span></span><br></pre></td></tr></table></figure><p>在别的地方<code>import</code>使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">&#x27;./img/xxx.jpg&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>声明命名空间</strong></p><p>比如在index.html中直接引入jQuery</p><p>然后在声明文件中（<code>.d.ts</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare namespace $ &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">settings: any</span>):any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在别的文件使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;...&#125;)</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hillyee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/">https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hillyee.github.io" target="_blank">Hillyee-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TS/">-TS</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=953166472,1374371628&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=955&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"><img class="prev-cover" src="https://img0.baidu.com/it/u=3270187559,3770262487&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题—JS篇之代码输出结果是什么</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E6%89%8B%E5%86%99%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题—JS手写篇</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">TypeScript初识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TS%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">TS简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS%E7%9A%84%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.</span> <span class="toc-text">TS的编译环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text">TS的运行环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">变量的声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">JS类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">TypeScript类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#any%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">any类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">unknown类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">void类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">never类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">tuple类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.6.</span> <span class="toc-text">函数的参数和返回值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.7.</span> <span class="toc-text">对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.8.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.9.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.2.10.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-as"><span class="toc-number">3.2.11.</span> <span class="toc-text">类型断言 as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.2.12.</span> <span class="toc-text">非空类型断言!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE"><span class="toc-number">3.2.13.</span> <span class="toc-text">可选链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.14.</span> <span class="toc-text">?? 和 !! 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.15.</span> <span class="toc-text">字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%8E%A8%E7%90%86"><span class="toc-number">3.2.16.</span> <span class="toc-text">字面量推理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.2.17.</span> <span class="toc-text">类型缩小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">TS函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">this类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.5.</span> <span class="toc-text">函数的重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">TS类的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">TS接口的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">TS枚举类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">TS泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.4.</span> <span class="toc-text">泛型约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">TS其他内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-number">8.1.</span> <span class="toc-text">模块化开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">8.1.1.</span> <span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace"><span class="toc-number">8.1.2.</span> <span class="toc-text">命名空间namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">8.2.</span> <span class="toc-text">类型的查找</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url(https://img1.baidu.com/it/u=953166472,1374371628&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=955&amp;h=500)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Hillyee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"K17ybwDJ17Flh4mBOnIeNCUW-gzGzoHsz",appKey:"sshkQAuti4qpWtrTV5y1WEPw",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
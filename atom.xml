<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hillyee-blog</title>
  
  
  <link href="https://hillyee.github.io/atom.xml" rel="self"/>
  
  <link href="https://hillyee.github.io/"/>
  <updated>2022-03-31T13:05:54.508Z</updated>
  <id>https://hillyee.github.io/</id>
  
  <author>
    <name>Hillyee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue3源码学习</title>
    <link href="https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-31T11:42:30.000Z</published>
    <updated>2022-03-31T13:05:54.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue3源码学习">Vue3源码学习</h3><blockquote><p>第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭</p></blockquote><h4 id="1-真实的DOM渲染">1. 真实的DOM渲染</h4><p>传统的前端开发中，我们是编写自己的HTML，最终被渲染到浏览器上的，这个过程大概是：</p><p>解析 html 转化成 DOM 树，然后渲染到页面</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06870cfbd95e41b6b19f557735a82565~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="2-虚拟DOM">2. 虚拟DOM</h4><h5 id="2-1-渲染过程">2.1 渲染过程</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5da766b840443a082d46dea3ef61179~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="3-Vue-源码的三大核心系统">3. Vue 源码的三大核心系统</h4><ul><li><p>Complier模块：编译模板系统</p></li><li><p>Runtime模块：也可以称之为 Renderer模块，真正渲染的模块</p></li><li><p>Reactivity模块：响应式系统</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2570e47944e340d09d20b337494d597a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li>三大系统协同工作</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917ae20ad154485f86dc308eb3841d69~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="4-实现-Mini-Vue">4. 实现 Mini-Vue</h4><blockquote><p>mini-vue的实现也是，后面有时间得回来重新看看</p></blockquote><p>包括三部分：</p><ul><li>渲染系统模块</li><li>可响应式系统模块</li><li>应用程序入口模块</li></ul><h4 id="4-1-渲染系统实现">4.1 渲染系统实现</h4><p>包含三个功能：</p><ul><li>h 函数，返回一个 VNode 对象</li><li>mount 函数，用于将 VNode 挂载到 DOM 上</li><li>patch 函数，用于对比两个 VNode，决定如何处理新的VNode（diff）</li></ul><h5 id="h函数生成-VNode">h函数生成 VNode</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 VNode</span></span><br><span class="line"><span class="comment">// 直接返回一个 VNode对象即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">h</span> = (<span class="params">tag, props, children</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mount函数挂载-vnode">mount函数挂载 vnode</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mount函数, 挂载VNode</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mount</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1.根据tag创建HTML元素,并且存储到vnode的el中</span></span><br><span class="line">  <span class="keyword">const</span> el = vnode.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>)</span><br><span class="line">  <span class="comment">// 2.处理props属性</span></span><br><span class="line">  <span class="comment">// 2.1 如果以on开头,那么监听事件</span></span><br><span class="line">  <span class="comment">// 2.2 普通属性直接通过 setAttribute 添加</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">props</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnode.<span class="property">props</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.<span class="property">props</span>[key]</span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.处理children</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      el.<span class="property">textContent</span> = vnode.<span class="property">children</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">mount</span>(item, el)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.将 el挂载到container上</span></span><br><span class="line">  container.<span class="title function_">appendChild</span>(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="patch函数-对比两个VNode">patch函数 - 对比两个VNode</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patch,对比两个 VNode</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. tag不同,直接加入新的节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1.<span class="property">tag</span> !== n2.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1Elparent = n1.<span class="property">el</span>.<span class="property">parentElement</span></span><br><span class="line">    n1Elparent.<span class="title function_">removeChild</span>(n1.<span class="property">el</span>)</span><br><span class="line">    <span class="title function_">mount</span>(n2, n1Elparent)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 取出element对象,并且在n2中进行保存</span></span><br><span class="line">    <span class="keyword">const</span> el = n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line">    <span class="comment">// 2. 处理props</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.1 获取所有的newProps添加到el</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key]</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123; <span class="comment">// 对事件监听的判断</span></span><br><span class="line">          el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), </span><br><span class="line">          newValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          el.<span class="title function_">setAttribute</span>(key, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2删除旧的props</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = oldProps[key]</span><br><span class="line">        el.<span class="title function_">removeEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.<span class="title function_">removeAttribute</span>(key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.处理children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span> || []</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.<span class="property">children</span> || []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123; <span class="comment">// 3.1newChildren本身是一个string</span></span><br><span class="line">      <span class="comment">// 边界情况 如果oldChildren也是一个字符串</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newChildren !== oldChildren) &#123;</span><br><span class="line">          el.<span class="property">textContent</span> = newChildren</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="property">innerHTML</span> = newChildren</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2 newChildren本身是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        el.<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        newChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">mount</span>(item, el)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// oldChildren 也是数组</span></span><br><span class="line">        <span class="comment">// 1. 前面有相同节点的</span></span><br><span class="line">        <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldChildren.<span class="property">length</span>, newChildren.<span class="property">length</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">          <span class="title function_">patch</span>(oldChildren[i], newChildren[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果新节点的length更长，那么剩余的新节点进行挂载操作</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &gt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          newChildren.<span class="title function_">slice</span>(oldChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">mount</span>(item, el)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果旧节点的length更长，那么移除剩余的旧节点进行</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &lt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          oldChildren.<span class="title function_">slice</span>(newChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            el.<span class="title function_">removeChild</span>(item.<span class="property">el</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-响应式系统">4.2 响应式系统</h4><h5 id="依赖收集系统-vue2响应式系统">依赖收集系统 + vue2响应式系统</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="comment">// 只要new Dep,就会给你添加subscribes属性 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 创建集合(里面放某属性依赖的函数)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  <span class="title function_">effect</span>() <span class="comment">// 原始数据先执行一次</span></span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDep</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据对象(target)取出对应的Map对象</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.取出具体的dep对象</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象拿到所有key,组成数组</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(raw).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取key对应的依赖</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(raw, key)</span><br><span class="line">    <span class="keyword">let</span> value = raw[key]</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(raw, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="comment">// 用到了某个key,调用get,所以可以在这里收集依赖</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; <span class="comment">// 当属性被重新赋值的时候,会调用set,所以在这里执行这个属性依赖的函数</span></span><br><span class="line">        <span class="comment">// raw[key] = newValue 不能这样设置,否则递归了(又对raw操作,又劫持,又来到set这里了)</span></span><br><span class="line">        <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">          value = newValue</span><br><span class="line">          dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hillyee&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect1</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">counter</span> * <span class="number">2</span>, info.<span class="property">name</span>, <span class="string">&#x27;w1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect2</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">counter</span> * info.<span class="property">counter</span>, <span class="string">&#x27;w2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// info.counter++ // 修改数据的时候,所有对这个数据有依赖的函数都应该被执行一次</span></span><br><span class="line"><span class="comment">// info.name = &quot;hahahhahah&quot;</span></span><br></pre></td></tr></table></figure><h5 id="响应式系统-vue3-proxy实现">响应式系统 vue3-proxy实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="comment">// Proxy(原对象,代理对象)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(raw, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(target, key) <span class="comment">// 获取该属性的依赖</span></span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(target, key)</span><br><span class="line">      target[key] = newValue</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么-Vue3-选择-Proxy-呢？">为什么 Vue3 选择 Proxy 呢？</h5><ul><li><p>Object.definedProperty 是劫持对象的属性时，如果新增元素，</p><p>那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理</p></li><li><p>修改对象的不同： 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截；</p><p>而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截；</p></li></ul><h4 id="4-3-框架外层-API-设计">4.3 框架外层 API 设计</h4><h5 id="createApp">createApp()</h5><p>用于创建一个app对象，该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">rootComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">mount</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector)</span><br><span class="line">      <span class="keyword">let</span> isMounted = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">let</span> oldVNode = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">watchEffect</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">          <span class="comment">// rootComponent.render() 返回根组件的vnode</span></span><br><span class="line">          oldVNode = rootComponent.<span class="title function_">render</span>()</span><br><span class="line">          <span class="title function_">mount</span>(oldVNode, container)</span><br><span class="line">          isMounted = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> newVNode = rootComponent.<span class="title function_">render</span>()</span><br><span class="line">          <span class="title function_">patch</span>(oldVNode, newVNode)</span><br><span class="line">          oldVNode = newVNode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用案例–计数">使用案例–计数</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../mini_vue/renderer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../mini_vue/reactive.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.创建根组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">counter</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;),</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">`当前计数:<span class="subst">$&#123;<span class="variable language_">this</span>.data.counter&#125;</span>`</span>),</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">counter</span>++</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">counter</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;, <span class="string">&quot;+1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        ])</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2.挂载根组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span></span><br><span class="line"><span class="language-javascript">    app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue3源码阅读">Vue3源码阅读</h3><blockquote><p>根据图的流程，加上源码，多看看叭，第一次看源码确实有点吃力了</p><p>先看熟悉流程，然后可以 debugger 在浏览器上简单过一下整个流程</p></blockquote><h4 id="createApp-2">createApp</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941441a206f545c488351612ee7f0a96~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="源码阅读之挂载根组件">源码阅读之挂载根组件</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e27cf0afe14494e963576c217bff7ab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;<span class="attr">props</span>: &#123;<span class="attr">message</span>: <span class="title class_">String</span>&#125;</span><br><span class="line">instance</span><br><span class="line"><span class="comment">// 1.处理props和attrs</span></span><br><span class="line">instance.<span class="property">props</span></span><br><span class="line">instance.<span class="property">attrs</span></span><br><span class="line"><span class="comment">// 2.处理slots</span></span><br><span class="line">instance.<span class="property">slots</span></span><br><span class="line"><span class="comment">// 3.执行setup</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">setup</span>()</span><br><span class="line">instance.<span class="property">setupState</span> = <span class="title function_">proxyRefs</span>(result);</span><br><span class="line"><span class="comment">// 4.编译template -&gt; compile</span></span><br><span class="line">&lt;template&gt; -&gt; render函数</span><br><span class="line">instance.<span class="property">render</span> = <span class="title class_">Component</span>.<span class="property">render</span> = render函数</span><br><span class="line"><span class="comment">// 5.对vue2的options api进行知识</span></span><br><span class="line">data/methods/computed/生命周期</span><br></pre></td></tr></table></figure><h4 id="组件化的初始化">组件化的初始化</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40e10ca0c2b044d78ba221099f6d9eef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="Compile过程">Compile过程</h4><p>对于不会改变的静态节点进行作用于提升</p><blockquote><p>我都没找到这部分函数。。。</p></blockquote><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd404365f8f946d89e99ccc604ffa235~tplv-k3u1fbpfcp-watermark.image?" alt="image.png " style="zoom:67%;" /><h4 id="Block-Tree-分析">Block Tree 分析</h4><p>vue3的一个优化：对于不会改变的静态节点进行作用域提升，仅对新的vnode进行创建</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c78021a3a241ca8ef00958116b4445~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="生命周期回调">生命周期回调</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8269743b1fb949219a2216950b8b1fb6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h4 id="template中数据的使用顺序">template中数据的使用顺序</h4><blockquote><p>如果setup跟data中有同一个属性,首先选择setup的,内部做了一个判断吧</p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6505298f6148e69434be3079bb168c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Vue3源码学习&quot;&gt;Vue3源码学习&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-真实的DOM渲染&quot;&gt;1. 真实的DOM渲染&lt;/h</summary>
      
    
    
    
    <category term="深入Vue3+Typescript学习" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="vue3" scheme="https://hillyee.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3_compositionAPI</title>
    <link href="https://hillyee.github.io/2022/03/31/Vue3-compositionAPI/"/>
    <id>https://hillyee.github.io/2022/03/31/Vue3-compositionAPI/</id>
    <published>2022-03-31T08:10:18.000Z</published>
    <updated>2022-03-31T10:47:45.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Composition-API">Composition API</h3><h4 id="1-setup">1. setup</h4><p><strong>1.1 setup函数有两个参数：props，context</strong></p><ul><li>props：其实就是父组件传递过来的属性，但是在setup外面依然需要用props接收</li><li>context：里面包含三个属性：<ul><li>attrs：父组件传递过来的没有被prop接收的属性</li><li>slots：父组件传递过来的插槽</li><li>emit：当组件内部需要发出事件的时候用（vue2里面是this.$emit，但是vue3中，setup不能访问this）</li></ul></li></ul><p><strong>1.2 setup 函数的返回值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup的返回值可以在模板 template 中使用，也就是可以代替data</p><p>但是直接这么返回变量，是没有响应式的</p><p><strong>1.3 setup 不可以使用 this</strong></p><ul><li>this 并没有指向当前组件实例</li><li>在 setup 被调用之前，data、computed、等都没有被解析</li><li>所以无法在 setup 中获取this</li></ul><h4 id="2-reactive-API">2. reactive API</h4><p>为setup中定义的数据提供响应式的特性</p><p>reactive API 传入的类型必须是对象或者数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>  <span class="comment">// 这时候这个name就是响应式的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-ref-API">3. ref API</h4><h5 id="3-1-ref-API-基本使用">3.1 ref API 基本使用</h5><p>可以传入基本数据类型，在开发中推荐使用 ref，便于代码的抽离，当然如果属性关系很紧密的时候，我们也可以用 reactive</p><p>ref 会返回一个可变的响应式对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>在 template 中引用 ref 的值时，Vue会自动帮我们进行解包，就是说我们不需要在模板中 xxx.value 来使用</li><li>但是在 setup 内部，它依然是一个 ref 的引用，所以要使用 <strong>ref.value</strong></li></ul><h5 id="3-2-ref-API-的补充">3.2 ref API 的补充</h5><ul><li>toRefs 和 toRef</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 当我们想解构的时候</span></span><br><span class="line"><span class="comment">// let &#123;name, age&#125; = info // 不再是响应式的了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望响应式的话</span></span><br><span class="line"><span class="comment">// 1. toRefs: 将 reactive 对象中所有属性都转成 ref</span></span><br><span class="line"><span class="comment">// let &#123;name, age&#125; = toRefs(info)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只希望单个响应式的话</span></span><br><span class="line"><span class="comment">// 2. toRef</span></span><br><span class="line"><span class="keyword">let</span> &#123;name&#125; = info <span class="comment">// 不是响应式</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="title function_">toRef</span>(info, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  age.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>shallowRef：创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的</li><li>triggerRef：手动触发和 shallowRef 相关联的副作用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info = <span class="title function_">shallowRef</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// info.value = &quot;hello&quot; 响应式</span></span><br><span class="line">  info.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&quot;james&quot;</span> <span class="comment">// 不是响应式</span></span><br><span class="line">  <span class="comment">// 手动触发和 shallowRef 相关联的副作用(变成响应式)</span></span><br><span class="line">  <span class="title function_">triggerRef</span>(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>customRef 自定义 ref</li></ul><h4 id="4-readonly">4. readonly</h4><ul><li><p>当我们希望我们给其他组件传递数据时，希望其他组件只是使用我们的内容，但是不允许它们修改的时候，可以用readonly</p></li><li><p>实际上，readonly 会返回原生对象的只读代理，也就是它依然是一个 Proxy，但是set方法被劫持</p></li><li><p>开发中常见的readonly方法会传入三个类型的值</p><ul><li>普通对象</li><li>reactive 返回的对象</li><li>ref 的对象</li></ul></li><li><p>readonly 使用时，readonly 返回的对象不允许修改，但是经过 readonly 处理的原来的对象是可以修改的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">readonly</span>(info)</span><br><span class="line">state.<span class="property">name</span> = <span class="string">&quot;aaa&quot;</span> <span class="comment">// 不可以</span></span><br><span class="line">info.<span class="property">name</span> = <span class="string">&quot;aaa&quot;</span> <span class="comment">// 可以</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-computed">5. computed</h4><ul><li><p>用法一：传入一个getter函数,computed的返回值是一个只读的ref对象(不能修改)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> firstName.<span class="property">value</span> + <span class="string">&quot;-&quot;</span> +lastName.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   firstName.<span class="property">value</span> = <span class="string">&quot;james&quot;</span> <span class="comment">// 可修改</span></span><br><span class="line">   fullName.<span class="property">value</span> = <span class="string">&quot;yuzi bing&quot;</span> <span class="comment">// 不可修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用法二：传入一个对象,对象包含 getter/setter,返回一个可读写的ref 对象</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> firstName.<span class="property">value</span> + <span class="string">&quot;-&quot;</span> +lastName.<span class="property">value</span>,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> names = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    firstName.<span class="property">value</span> = names[<span class="number">0</span>]</span><br><span class="line">    lastName.<span class="property">value</span> = names[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  fullName.<span class="property">value</span> = <span class="string">&quot;yuzi bing&quot;</span> <span class="comment">// 可修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-watchEffect">6. watchEffect</h4><p><strong>6.1 watchEffect 基本使用</strong></p><ul><li>watchEffect 传入的函数会被立即执行一次, 并在执行的过程中自动收集依赖（相当于你在这个函数使用了什么变量，它会自动收集到）</li><li>只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行</li></ul><p>下面案例中，name 的改变会被侦听到，而 age 不会被侦听</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watchEffect: 自动收集响应式的依赖</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;jenny&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params"></span>) =&gt; name.<span class="property">value</span> = <span class="string">&quot;tony&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeAge</span> = (<span class="params"></span>) =&gt; age.<span class="property">value</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name:&quot;</span>, name.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>6.2 watchEffect 停止侦听</strong></p><p>如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"><span class="comment">// watchEffect 会返回一个函数,供我们停止侦听使用</span></span><br><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;age:&quot;</span>, age.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  age.<span class="property">value</span>++</span><br><span class="line">  <span class="comment">// 案例：age 到25的时候就停止侦听</span></span><br><span class="line">  <span class="keyword">if</span> (age.<span class="property">value</span> &gt; <span class="number">25</span>) &#123;</span><br><span class="line">    <span class="title function_">stop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.3 watchEffect 清除副作用</strong></p><p>清除副作用？</p><p>比如我们需要在侦听器中执行网络请求，但是在网络请求还没完成之前，我们停止了侦听器或者修改了数据让侦听器侦听函数再次执行了，这时候我们应该清除上一次的副作用（数据改变了要重新发送请求或者说不需要发了）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网络请求成功~&#x27;</span>); <span class="comment">// 定时器模拟网络请求</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在传入的回调函数中执行一些清除工作</span></span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onInvalidate&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;age:&quot;</span>, age.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>6.4 watchEffect 执行时机</strong></p><ul><li><p>首先补充一下：在 setup 中如何属于 ref 或者元素或者组件？</p><p>定义一个 ref 对象，绑定到元素或组件的ref属性上</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2 ref=<span class="string">&quot;title&quot;</span>&gt;hello&lt;<span class="regexp">/h2&gt; /</span><span class="regexp">/ 绑定到元素的ref属性</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const title = ref(null) /</span><span class="regexp">/ 定义 ref 对象</span></span><br></pre></td></tr></table></figure><ul><li><p>watchEffect 执行时机</p><p>如果我们希望在副作用函数中获取元素，我们会发现打印结果有两个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220329144156444-16485361187171.png" alt="image-20220329144156444 " style="zoom:60%;" /><ul><li>这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null</li><li>当 DOM 挂载时，会给 title 的 ref 对象赋新的值，副作用函数会再次执行</li></ul></li><li><p>调整 watchEffect 的执行时机</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// flush: &quot;pre&quot; // 在元素挂载或更新之前执行</span></span><br><span class="line">    <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span> <span class="comment">// 元素挂载更新之后执行, 这时候只打印一次&lt;h2&gt;&lt;/h2&gt;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-watch">7. watch</h4><h5 id="7-1-侦听单个数据源">7.1 侦听单个数据源</h5><ul><li>侦听一个 getter 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. watch侦听时,传入一个getter函数, 具体监听某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> info.<span class="property">name</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue); <span class="comment">// Tom jenny</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接侦听一个可响应式的对象，reactive 或 ref （ref更常用）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个可响应式对象: reactive对象/ref对象</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="title function_">ref</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(info, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue); </span><br><span class="line">    <span class="comment">// Proxy &#123;name: &#x27;Tom&#x27;, age: 18&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(title, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue); <span class="comment">// world hello</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    title.<span class="property">value</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-侦听多个数据源">7.2 侦听多个数据源</h5><p>注：如果我们希望侦听一个数组或者对象，那么可以使用一个getter函数，并且对可响应对象进行解构</p><p>(不解构也行,不解构n,o就是一个Proxy对象)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> title = <span class="title function_">ref</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时侦听多个数据源</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">() =&gt;</span> (&#123;...info&#125;), title], <span class="function">(<span class="params">[newInfo, newTitle], [oldInfo, oldTitle]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newInfo, newTitle, oldInfo, oldTitle);</span><br><span class="line">    <span class="comment">// &#123;name: &#x27;Tom&#x27;, age: 18&#125; &#x27;world&#x27; </span></span><br><span class="line">    <span class="comment">// &#123;name: &#x27;jenny&#x27;, age: 18&#125; &#x27;hello&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    title.<span class="property">value</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-watch-的选项">7.3 watch 的选项</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jenny&quot;</span>,</span><br><span class="line">    <span class="attr">hobby</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;haha&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> (&#123;...info&#125;), <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度监听</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// 立即执行一次</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// info.name = &quot;Tom&quot;</span></span><br><span class="line">    info.<span class="property">hobby</span>.<span class="property">title</span> = <span class="string">&quot;hehe&quot;</span> <span class="comment">// 开启深度监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-生命周期钩子">8. 生命周期钩子</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在挂载开始之前被调用：相关的 render 函数首次被调用。</span></span><br><span class="line"><span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 实例挂载完毕后调用</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。</span></span><br><span class="line"><span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</span></span><br><span class="line"><span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载组件实例前调用, 这个阶段,实例仍然是完全正常的</span></span><br><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 卸载组件实例后调用,调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</span></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line"><span class="title function_">onActivated</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件失活时调用。</span></span><br><span class="line"><span class="title function_">onDeactivated</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="9-Provide-和-Inject">9. Provide 和 Inject</h4><p>父组件通过 provide 来提供数据（必须要在父组件中使用过子组件，建立联系才能提供数据）</p><p>provide(属性名，属性值)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;jenny&quot;</span>)</span><br><span class="line"><span class="comment">// 给后代组件提供属性或方法(为了不让子组件随意修改父组件的数据,可以使用readonly)</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;name&quot;</span>, <span class="title function_">readonly</span>(name))</span><br></pre></td></tr></table></figure><p>后代组件可以通过 Inject 来注入需要的属性和对应值</p><p>inject(要注入的属性名, 默认值) ，默认值就是如果父组件没有提供改数据的话就使用默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">inject</span>(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="10-composition-API-练习">10. composition API 练习</h4><p>自定义 hooks</p><h5 id="1-useTitle">1. useTitle</h5><p>改变页面标题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">title = <span class="string">&quot;默认的title&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> titleRef = <span class="title function_">ref</span>(title)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(titleRef, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = newValue</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> titleRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-useScrollPosition">2. useScrollPosition</h5><p>监听页面滚动位置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useScrollPosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> scrollX = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> scrollY = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    scrollX.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">scrollX</span></span><br><span class="line">    scrollY.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">scrollY</span></span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    scrollX,</span><br><span class="line">    scrollY</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-useMousePosition">3. useMousePosition</h5><p>监听鼠标位置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useMousePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mouseX = <span class="title function_">ref</span>(<span class="number">0</span>)  </span><br><span class="line">  <span class="keyword">const</span> mouseY = <span class="title function_">ref</span>(<span class="number">0</span>)  </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    mouseX.<span class="property">value</span> = event.<span class="property">pageX</span></span><br><span class="line">    mouseY.<span class="property">value</span> = event.<span class="property">pageY</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    mouseX,</span><br><span class="line">    mouseY</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-useLocalStorage">4. useLocalStorage</h5><p>使用 localStorage 存储和获取数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">ref</span>(value)</span><br><span class="line">  <span class="comment">// 如果有传value,表示要存储值,否则是获取值</span></span><br><span class="line">  <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.<span class="property">value</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(data, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newValue))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器存取值</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="title function_">useLocalStorage</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jenny&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeData</span> = (<span class="params"></span>) =&gt; data.<span class="property">value</span> = <span class="string">&quot;hahaha&quot;</span></span><br></pre></td></tr></table></figure><h5 id="5-useCounter">5. useCounter</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> doubleCounter = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counter.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; counter.<span class="property">value</span>++;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; counter.<span class="property">value</span>--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter, </span><br><span class="line">    doubleCounter, </span><br><span class="line">    increment, </span><br><span class="line">    decrement</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-认识自定义指令">11. 认识自定义指令</h4><h5 id="11-1-简单使用">11.1 简单使用</h5><ul><li><p>除了 v-for, v-show，等指令，Vue也允许我们自定义指令</p></li><li><p>自定义指令分为两种</p><ul><li>自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用</li><li>自定义全局指令：app的 directive 方法，可以在任意组件中被使用</li></ul></li><li><p>简单的案例：当某个元素挂载完成后可以自定获取焦点</p><ul><li><p>默认方式的实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref, onMounted&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const input = ref(null)</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      input.value.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      input</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义局部指令 v-focus</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; ref=&quot;input&quot; v-focus&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    // 自定义属性的名称(这里不需要写 v-)</span><br><span class="line">    focus: &#123;</span><br><span class="line">      mounted(el) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义全局指令 v-focus (main.js中)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.directive(&quot;focus&quot;, &#123;</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="11-2-指令的生命周期">11.2 指令的生命周期</h5><ul><li>一个指令定义的对象，Vue提供了如下的几个钩子函数：</li><li>created：在绑定元素的 attribute 或事件监听器被应用之前调用；</li><li>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用</li><li>mounted：在绑定元素的父组件被挂载后调用</li><li>beforeUpdate：在更新包含组件的 VNode 之前调用</li><li>updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用</li><li>beforeUnmount：在卸载绑定元素的父组件之前调用</li><li>unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次</li></ul><p>指令的生命周期可以拿到几个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// el: &lt;input&gt;</span></span><br><span class="line">  <span class="comment">// bindings: 包含一些属性的对象</span></span><br><span class="line">  <span class="comment">// vnode: 一个真实 DOM 元素</span></span><br><span class="line">  <span class="comment">// preVnode: 上一个虚拟节点</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, bindings, vnode, preVnode</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;focus created&quot;</span>, el, bindings, vnode, preVnode);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindings.<span class="property">value</span>); <span class="comment">// 拿到传入的参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindings.<span class="property">modifiers</span>); <span class="comment">// 指令的修饰符</span></span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="11-3-指令的参数和修饰符">11.3 指令的参数和修饰符</h5><ul><li><p>指令接受参数或者修饰符</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">v-指令名:参数名.修饰符=&quot;具体值&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-why:info.aaa.bbb</span>=<span class="string">&quot;&#123;title: &#x27;hello&#x27;, name: &#x27;me&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="11-4-自定义指令练习">11.4 自定义指令练习</h5><p>自定义时间格式化的指令 v-format-time</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&quot;dayjs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  app.<span class="title function_">directive</span>(<span class="string">&quot;format-time&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params">el, bindings</span>) &#123;</span><br><span class="line">      <span class="comment">// 默认格式</span></span><br><span class="line">      bindings.<span class="property">formatString</span> = <span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span></span><br><span class="line">      <span class="comment">// 如果有传入格式的参数，那么使用传入的格式</span></span><br><span class="line">      <span class="keyword">if</span> (bindings.<span class="property">value</span>) &#123;</span><br><span class="line">        bindings.<span class="property">formatString</span> = bindings.<span class="property">value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params">el, bindings</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> textContent = el.<span class="property">textContent</span> <span class="comment">// 节点及其后代的文本内容</span></span><br><span class="line">      <span class="keyword">let</span> timestamp = <span class="built_in">parseInt</span>(textContent)</span><br><span class="line">      <span class="keyword">if</span> (textContent.<span class="property">length</span> === <span class="number">10</span>) &#123;</span><br><span class="line">        timestamp = timestamp * <span class="number">1000</span> <span class="comment">// 转成毫秒</span></span><br><span class="line">      &#125;</span><br><span class="line">      el.<span class="property">textContent</span> = <span class="title function_">dayjs</span>(timestamp).<span class="title function_">format</span>(bindings.<span class="property">formatString</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他补充">其他补充</h3><h4 id="1-render函数">1. render函数</h4><h5 id="1-1-认识-h-函数">1.1 认识 h 函数</h5><ul><li><p>绝大多数情况下，我们的HTML都是用模板<code>&lt;template&gt;</code>创建的，如果在一些特殊的场景，真的需要JavaScript的完全编程能力，这个时候可以使用 渲染函数，它比模板更接近编译器</p><ul><li><p>Vue在生成真实的 DOM 之前，会将我们的节点转换成 VNode（虚拟节点），而VNode组合在一起形成一棵树结构，就是虚拟DOM（VDOM）</p></li><li><p>你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode</p></li></ul></li><li><p>h()函数是一个用于创建 VNode 的函数</p></li></ul><h5 id="1-2-h-函数基本使用">1.2 h 函数基本使用</h5><ul><li>h() 函数接收三个参数，（标签名，组件名…）（属性）（子节点，内容）</li><li>h 函数可以在两个地方使用，render 函数选项中或者 setup 函数选项中</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// render 函数选项中</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, &#123;<span class="attr">class</span>: <span class="string">&quot;title&quot;</span>&#125;, <span class="string">&quot;Hello Render&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, &#123;<span class="attr">class</span>: <span class="string">&quot;title&quot;</span>&#125;, <span class="string">&quot;Hello Render&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220330152843095-16486253285831.png" alt="image-20220330152843095 " style="zoom:67%;" /><h5 id="1-3-h-函数实现计数器案例">1.3 h 函数实现计数器案例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, &#123;<span class="attr">class</span>: <span class="string">&quot;app&quot;</span>&#125;, [</span><br><span class="line">            <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">`当前计数:<span class="subst">$&#123;<span class="variable language_">this</span>.counter&#125;</span>`</span>),</span><br><span class="line">            <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;<span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">counter</span>++&#125;, <span class="string">&quot;+1&quot;</span>),</span><br><span class="line">            <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;<span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">counter</span>--&#125;, <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">        ])</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-jsx">2. jsx</h4><ul><li><p>在项目中使用 jsx 需要添加对 jsx 的支持</p><ul><li><p>安装Babel支持Vue的jsx插件</p><p><code>npm install @vue/babel-plugin-jsx -D</code></p></li><li><p>在 babel.config.js 配置文件中配置插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&quot;@vue/babel-plugin-jsx&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基本使用：计数器案例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span>.<span class="property">counter</span>++;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span>.<span class="property">counter</span>--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;this.counter&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;decrement&#125;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-认识-Teleport">3. 认识 Teleport</h4><p>(先了解一下)</p><p>在组件化开发中，我们封装一个组件A，在另外一个组件B中使用，p 那么组件A中template的元素，会被挂载到组件B中template的某个位置，最终形成一棵 DOM 树结构</p><p>但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置，这个时候就可以通过teleport完成</p><h4 id="4-认识-Vue-插件">4. 认识 Vue 插件</h4><p>通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式</p><ul><li><p>对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) &#123; <span class="comment">//</span></span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$name</span> = <span class="string">&quot;hillyee&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数类型：一个function，这个函数会在安装插件时自动执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins_function.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(pluginsFunction)</span><br><span class="line">app.<span class="title function_">use</span>(pluginsObject)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Composition-API&quot;&gt;Composition API&lt;/h3&gt;
&lt;h4 id=&quot;1-setup&quot;&gt;1. setup&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.1 setup函数有两个参数：props，context&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="深入Vue3+Typescript学习" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>面试每日练 — JS篇</title>
    <link href="https://hillyee.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94JS%E7%AF%87/"/>
    <id>https://hillyee.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94JS%E7%AF%87/</id>
    <published>2022-03-31T01:17:39.000Z</published>
    <updated>2022-03-31T05:27:00.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS-数据类型">JS 数据类型</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JS-数据类型&quot;&gt;JS 数据类型&lt;/h3&gt;
</summary>
      
    
    
    
    <category term="面试题-js篇" scheme="https://hillyee.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手</title>
    <link href="https://hillyee.github.io/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://hillyee.github.io/2022/03/30/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2022-03-30T12:11:13.000Z</published>
    <updated>2022-03-31T06:26:33.081Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-TCP-三次握手过程">1. TCP 三次握手过程 ?</h4><p>（首先，两个概念：SYN：同步标志   ACK：确认标志）</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手：</p><p>第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态</p><p>第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</p><p>第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态</p><p>最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接</p><h4 id="2-为什么需要三次握手？两次不行吗？">2. 为什么需要三次握手？两次不行吗？</h4><p>其实这是由 TCP 的自身特点可靠传输决定的。</p><p>第一次握手，客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的</p><p>第二次握手，服务端发包，客户端收到了。这样客户端就能得出结论：服务端的发送能力、客户端的接收能力是正常的。</p><p>第三次握手，客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送，接收能力也正常。</p><h4 id="3-ISN-是固定的吗">3. (ISN) 是固定的吗?</h4><p>三次握手的一个重要功能是客户端和服务端交换 ISN ，以便让对方知道接下来接受数据的时候如何按序列号组装数据</p><p>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</p><h4 id="4-三次握手过程中可以携带数据吗">4. 三次握手过程中可以携带数据吗</h4><p>第三次握手的时候可以携带数据。因为假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常。然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，可能会让服务器更加容易受到攻击。</p><p>而对于第三次的话，客户端已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的，所以携带数据也没问题</p><h4 id="5-四次挥手？为什么要四次？">5. 四次挥手？为什么要四次？</h4><p>刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则：</p><p>刚开始双方都处于established状态，假如是客户端先发起关闭请求</p><p>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态</p><p>第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态</p><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态</p><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p><h4 id="6-SYN-攻击是什么？">6. SYN 攻击是什么？</h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h5 id="检测-SYN-攻击？">检测 SYN 攻击？</h5><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p><h5 id="常见的防御-SYN-攻击的方法？">常见的防御 SYN 攻击的方法？</h5><p>缩短超时时间</p><p>增加最大半连接数</p><p>过滤网关防护</p><p>SYN cookies技术</p><h4 id="7-什么是半连接队列？">7. 什么是半连接队列？</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，这种队列称之为半连接队列。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-TCP-三次握手过程&quot;&gt;1. TCP 三次握手过程 ?&lt;/h4&gt;
&lt;p&gt;（首先，两个概念：SYN：同步标志   ACK：确认标志）&lt;/p&gt;
&lt;p&gt;刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手：&lt;/p&gt;
&lt;p&gt;第一次握手，</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://hillyee.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>var_let_const区别</title>
    <link href="https://hillyee.github.io/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/"/>
    <id>https://hillyee.github.io/2022/03/30/var-let-const%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-30T12:08:54.000Z</published>
    <updated>2022-03-31T10:46:51.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="var、let、const-相关">var、let、const 相关</h3><p>var（ES5）let,const（ES6）</p><h4 id="1-作用域？"><strong>1. 作用域？</strong></h4><p>简单来说，作用域就是一个独立的地盘，外层作用域无法读取内层作用域的变量，但是内层作用域可以访问外层作用域的变量或者定义外层作用域的同名变量。</p><h4 id="2-var-变量提升？-var-特点？"><strong>2. var 变量提升？ var 特点？</strong></h4><p>无论在全局作用域还是在局部作用域中，使用 var 关键字声明的变量都会被提升到该作用域的最顶部，这就是我们常说的<strong>变量提升</strong></p><p>在代码预编译的时候，JavaScript 引擎会自动将所有代码里面以var 关键字声明的语句提升到<strong>当前作用域</strong>的顶端</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span></span><br></pre></td></tr></table></figure><h4 id="var-的特点"><strong>var 的特点</strong></h4><ul><li><p>存在变量提升</p></li><li><p>在变量未赋值时，变量为 undefined</p></li><li><p>一个变量可以多次声明，后面的声明会覆盖前面的声明</p></li><li><p>在函数中使用 var 声明变量的时候，该变量是局部的（因为在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum)  <span class="comment">// 报错 sum is not defined</span></span><br></pre></td></tr></table></figure><p><strong>如果函数内不使用 var 声明，该变量是全局的</strong>，sum 被添加到全局上下文（window）window.sum</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-let"><strong>3. let</strong></h4><ul><li><p>let 不存在变量提升，let 声明变量前，该变量不能使用(暂时性死区)</p></li><li><p>let 为块级作用域，所有外面的语句块访问不到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value)  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>let <strong>不允许重复声明</strong>，如果在同一个作用域中某个变量已经存在，再次使用 let 关键字声明的话会报错</p></li></ul><h4 id="4-const"><strong>4. const</strong></h4><p>与 let 没什么大不同</p><ul><li><p>const 声明的是常量，常量就是一旦定义完就不能修改的值。</p></li><li><p>必须初始化值，否则会报错。</p></li><li><p>需要注意的是：const 变量不能再被重新赋值为其他引用值，但对象的键不受限制</p><p>也就是说，并不是变量的值不能改动，而是变量指向的那个内存地址不得改动</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1 = &#123;&#125; <span class="comment">// 报错，不能给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span> &#125;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;tony&quot;</span>  <span class="comment">// 没问题</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-暂时性死区？"><strong>5. 暂时性死区？</strong></h4><p>如果区块中存在 let 和 const 命令，以这个命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错</p><p>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”(temporal dead zone 简称 TDZ )</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// TDZ 开始</span></span><br><span class="line">    tmp = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp)</span><br><span class="line">    </span><br><span class="line">    tmp = <span class="number">123</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的死区</p><h4 id="6-在-for-循环中使用-var，let-的区别"><strong>6. 在 for 循环中使用 var，let 的区别</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line">&#125;  <span class="comment">// 输出全是10</span></span><br><span class="line"><span class="comment">// 因为 i 是全局变量，最后访问的都是全局变量</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line">&#125;  <span class="comment">// 0123456789; </span></span><br><span class="line"><span class="comment">// i 是局部变量，每次循环改变的是对局部变量赋值</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;var、let、const-相关&quot;&gt;var、let、const 相关&lt;/h3&gt;
&lt;p&gt;var（ES5）let,const（ES6）&lt;/p&gt;
&lt;h4 id=&quot;1-作用域？&quot;&gt;&lt;strong&gt;1. 作用域？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;简单来说，作用域就是一个独</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://hillyee.github.io/categories/JavaScript/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>04_实现call_apply_bind</title>
    <link href="https://hillyee.github.io/2022/03/30/%E6%89%8B%E5%86%99call-apply-bind/"/>
    <id>https://hillyee.github.io/2022/03/30/%E6%89%8B%E5%86%99call-apply-bind/</id>
    <published>2022-03-30T11:49:46.000Z</published>
    <updated>2022-03-31T10:56:01.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="call、apply、bind-实现">call、apply、bind 实现</h3><h4 id="1-call-实现">1. call 实现</h4><p>首先我们要知道系统的 call 方法主要实现了什么</p><ul><li>执行了函数</li><li>改变了 this 的指向</li></ul><p>先看系统的call方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo函数被执行&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum函数被执行&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 传入对象</span></span><br><span class="line">foo.<span class="title function_">call</span>(&#123;&#125;) </span><br><span class="line"><span class="comment">// 2. 传入null/undefined</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// this自动替换为指向全局对象</span></span><br><span class="line"><span class="comment">// 3. 传入其他，字符串，数字，布尔值等等</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="string">&quot;abc&quot;</span>) <span class="comment">// this 指向相应的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = sum.<span class="title function_">call</span>(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b796e59e07f4560acdbfe38abe4ad79~tplv-k3u1fbpfcp-watermark.image?" alt="img0328_01.png"></p><p>接下来我们开始实现自己的call（主要是实现思路，没有把所有的边缘条件考虑完全，但是基本都有）</p><p><strong>1.1 让函数执行起来</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="variable language_">this</span> <span class="comment">// this就是我们想要执行的函数 foo,把它保存到 fn</span></span><br><span class="line">    <span class="comment">// 接着让函数执行起来</span></span><br><span class="line">    <span class="title function_">fn</span>() <span class="comment">// 但是这里是独立函数调用，this指向window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">mycall</span>() <span class="comment">// 这里相当于mycall隐式绑定了foo,因此 mycall中的this就是foo</span></span><br></pre></td></tr></table></figure><p><strong>2.2 显式绑定this</strong></p><p>现在我们要绑定我们指定的this</p><ul><li>先看第一种：<code>foo.mycall(&#123;name: 'hello'&#125;)</code>，绑定一个对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> <span class="comment">// this就是我们想要执行的函数 foo,把它保存到 fn</span></span><br><span class="line">  <span class="comment">// 接着调用这个函数</span></span><br><span class="line">  <span class="comment">// 我们的目的是让函数执行的时候绑定thisArg这个对象执行即thisArg.fn()(隐式绑定)</span></span><br><span class="line">  <span class="comment">// 但是现在 thisArg没有 fn 这个属性呀，怎么调用呢</span></span><br><span class="line">  <span class="comment">// 所以我们可以给thisArg添加一个属性 fn, 值就是我们想要执行的函数</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="comment">// 然后再调用</span></span><br><span class="line">  thisArg.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="comment">// 但是这样我们不就让thisArg多出来一个属性fn了吗？</span></span><br><span class="line">  <span class="comment">// 没关系，函数执行完 删掉就好</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果我们传入的不是对象呢？那就不能给thisArg添加属性啦</p><p><code>foo.mycall(&quot;123&quot;)</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> </span><br><span class="line">  <span class="comment">// 所以要把 thisArg 转成对象类型(Object构造函数可以将给定的值包装为一个新对象)</span></span><br><span class="line">  thisArg = <span class="title class_">Object</span>(thisArg)</span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  thisArg.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果传入的是 null / undefined 呢</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> </span><br><span class="line">  <span class="comment">// 如果thisArg传入的是 undefined / null, 应该让它指向全局对象</span></span><br><span class="line">  <span class="comment">// 所以我们要做一个判断</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  thisArg.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3 接下来要考虑参数了</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rest运算符</span></span><br><span class="line"><span class="comment">// ...args 会把我们传入的参数列表组合到一个数组 [num1,num2]</span></span><br><span class="line"><span class="comment">// ...args 也可以展开数组, 相当于对数组的一个遍历</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span> </span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="comment">// 把参数传入函数，并用 result 接收函数执行完的结果(例子中就是sum函数执行完的结果)</span></span><br><span class="line">  <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...args) <span class="comment">// ...[num1, num2] --&gt; num1, num2</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">  <span class="comment">// 最后把结果返回出去</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，基本的call就已经实现了</p><p>检验一下叭</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">mycall</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line">foo.<span class="title function_">mycall</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">foo.<span class="title function_">mycall</span>(<span class="literal">undefined</span>)</span><br><span class="line">foo.<span class="title function_">mycall</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">sum.<span class="title function_">mycall</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>&#125;, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> res1 = sum.<span class="title function_">mycall</span>(<span class="number">123</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4b709b153349f7afbde95a6b9af35c~tplv-k3u1fbpfcp-watermark.image?" alt="image0328_02.png style=&quot;zoom:70%;&quot;"></p><h4 id="2-apply-实现">2. apply 实现</h4><p>跟 call 类似，只不过参数的处理有不同</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myapply</span> = <span class="keyword">function</span>(<span class="params">thisArg, argsArray</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  thisArg.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="comment">// 没有传argArray,那么argsArray默认为 undefined,那么就不能使用展开运算符了</span></span><br><span class="line">  <span class="comment">// 所以如果没有传入参数, 那么把它初始化为 [], 空数组也是可以展开的 ...[]</span></span><br><span class="line">  argsArray = argsArray || []</span><br><span class="line">  <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...argsArray)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-bind-实现">3. bind 实现</h4><p>bind 需要我们返回一个新的函数，并且调用 bind 的时候不需要执行函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mybind</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    thisArg.<span class="property">fn</span> = fn</span><br><span class="line">    <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind 需要返回一个新的函数 你也可以直接 return function() &#123;...&#125;</span></span><br><span class="line">  <span class="keyword">return</span> newFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上也差不多，但我们可以就下面这种情况改进一下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum2</span>(<span class="params">num1, num2, num3, num4</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum2函数被执行&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> num1 + num2 + num3 + num4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newSum2 = sum2.<span class="title function_">mybind</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">10</span>,<span class="number">20</span>) <span class="comment">// 绑定的时候传入了两个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newSum2</span>(<span class="number">30</span>,<span class="number">40</span>)); <span class="comment">// 使用新返回的函数的时候再传入剩余的参数</span></span><br></pre></td></tr></table></figure><p>这种情况，我们就需要把两次传入的参数合并起来，再调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mybind</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span>) ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="comment">// 合并传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> allArgs = [...args, ...newArgs]</span><br><span class="line"></span><br><span class="line">    thisArg.<span class="property">fn</span> = fn</span><br><span class="line">    <span class="keyword">let</span> result = thisArg.<span class="title function_">fn</span>(...allArgs)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，基本的bind也实现了</p><p>最后说明一下，实现的思路是这样，但是方法不唯一的，可能还有一些边边角角没有考虑到的话，可以自己添加进去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;call、apply、bind-实现&quot;&gt;call、apply、bind 实现&lt;/h3&gt;
&lt;h4 id=&quot;1-call-实现&quot;&gt;1. call 实现&lt;/h4&gt;
&lt;p&gt;首先我们要知道系统的 call 方法主要实现了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行了函数&lt;/li&gt;
</summary>
      
    
    
    
    <category term="深入JS高级语法" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>03_JS函数的this指向</title>
    <link href="https://hillyee.github.io/2022/03/30/JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/"/>
    <id>https://hillyee.github.io/2022/03/30/JS%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91/</id>
    <published>2022-03-30T10:50:46.000Z</published>
    <updated>2022-03-31T10:55:50.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS-函数的-this-指向">JS 函数的 this 指向</h3><h4 id="1-this-在全局作用域下的指向">1. this 在全局作用域下的指向</h4><p>在浏览器中，this在全局作用域下指向 window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span>) <span class="comment">// hello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">title</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h4 id="2-this-的四个绑定规则">2. this 的四个绑定规则</h4><h4 id="2-1-规则一：默认绑定">2.1 规则一：默认绑定</h4><p>在<strong>独立函数调用</strong>的情况下会使用默认绑定</p><p>独立函数调用简单来说就是它没有绑定到某个对象上进行调用，简单看几个例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo1</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo2</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo3</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>以上的函数调用的时候，都是没有被绑定到对象中调用的，所以 this 都指向 window</p><h4 id="2-2-规则二：隐式绑定">2.2 规则二：隐式绑定</h4><p>函数通过某个对象进行调用的时候，这个对象会被 js 引擎绑定到函数中的 this 里</p><p>下面看几个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn</span>() <span class="comment">// obj 对象</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: obj1.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.<span class="title function_">bar</span>() <span class="comment">// obj2对象</span></span><br></pre></td></tr></table></figure><h4 id="2-3-显式绑定">2.3 显式绑定</h4><p>利用 call，apply，bind手动指定 this 的绑定，这种明确的绑定称为显示绑定</p><p><strong>(1) call，apply</strong></p><p>call，apply 都是可以调用函数的</p><p>fn.call(自定的this指向，参数1，参数2)  fn.apply(this指向，[参数1，参数2])</p><p>两者的区别在于传参的方式，下面例子可以看出来 call 传入参数列表，apply是数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2, num3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2 + num3, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.<span class="title function_">call</span>(<span class="string">&quot;123&quot;</span>, <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>) <span class="comment">// 手动让this指向&quot;123&quot;</span></span><br><span class="line">sum.<span class="title function_">apply</span>(obj, [<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) <span class="comment">// 手动让this指向obj</span></span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc769b40fc274f32b225566e2b2dec07~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220327114447032.png"></p><p><strong>(2) bind</strong></p><p>bind不会调用函数，而是返回一个新的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2, num3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2 + num3, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var obj = &#123;</span></span><br><span class="line"><span class="comment">//   title: &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.call(&quot;123&quot;, 20,30,40) // 手动让this指向&quot;123&quot;</span></span><br><span class="line"><span class="comment">// sum.apply(obj, [20,30,40]) // 手动让this指向obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newSum = sum.<span class="title function_">bind</span>(<span class="string">&#x27;aaa&#x27;</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="title function_">newSum</span>() <span class="comment">// 60 String &#123;&#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>咦？newSum 不也是独立函数调用吗，怎么不指向 window 了</p><p>这就是默认绑定和显示绑定bind的冲突，显示绑定的优先级更高！</p><h4 id="2-4-new绑定">2.4 new绑定</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="comment">// 实际上这里是会把 this 返回出去的,即return this（默认）</span></span><br><span class="line">  <span class="comment">// this = 创建出来的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 会创建一个全新的对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jenny&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tony&quot;</span>, <span class="number">15</span>)</span><br></pre></td></tr></table></figure><h4 id="3-一些内置函数的-this-绑定">3. 一些内置函数的 this 绑定</h4><p>有时候我们会调用一些 JS 的内置函数，这些函数要求我们传入另外一个函数，并且我们不会自己去调用这些函数，而是 JS 内部会帮助我们执行。</p><p>这个时候，this 的绑定就跟内部帮我们指向函数的方式有关系了。</p><p>看几个例子吧</p><h5 id="3-1-setTimeout">3.1 setTimeout</h5><p>内部通过 apply 调用函数，并绑定了this对象，是window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h5 id="3-2-数组的内置函数-forEach">3.2 数组的内置函数 forEach</h5><p>默认情况下传入的函数是自动调用函数（默认绑定）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 三次 window</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以通过传入第二个参数，改变this指向</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 三次 &#x27;obj&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;obj&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="3-3-点击事件">3.3 点击事件</h5><p>在发生点击时，回调函数被调用，会将 this 绑定到该函数中</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>)</span><br><span class="line">box.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// box对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，某些内置的函数，我们很难确定它内部是如何调用传入的回调函数的，可以自己测试一下，记一下，看源码当然更好啦</p><h4 id="4-几个规则的优先级">4. 几个规则的优先级</h4><p>从高到低：new绑定 &gt; 显式绑定(bind) &gt; 隐式绑定 &gt; 默认绑定</p><p>new绑定和call，apply是不允许同时使用的，（毕竟都会调用函数），所以不存在谁的优先级更高</p><ul><li><p>显示绑定高于隐式绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式绑定和隐式绑定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// obj 对象</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// &#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>new 绑定高于隐式绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">foo</span>() <span class="comment">// 输出 foo 对象而不是 obj</span></span><br></pre></td></tr></table></figure></li><li><p>new 绑定高于bind</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj) <span class="comment">// 显式绑定obj</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">bar</span>() <span class="comment">// 打印 foo对象 而不是 obj</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-两种特殊情况">5. 两种特殊情况</h4><p><strong>5.1 在显示绑定中传入 null 或 undefined</strong></p><p>这时候，显示绑定会被忽略，使用默认规则</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj) <span class="comment">// obj</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p><strong>5.2 间接函数引用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来看一下这个赋值的结果, 是 foo 函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((obj2.<span class="property">foo</span> = obj1.<span class="property">foo</span>)); <span class="comment">// foo函数</span></span><br><span class="line"><span class="comment">// 这种叫做间接函数引用，是会把赋值语句右边的结果返回，然后直接调用，是独立函数调用</span></span><br><span class="line">(obj2.<span class="property">foo</span> = obj1.<span class="property">foo</span>)() <span class="comment">// 相当于直接调用 foo 函数，所以是默认绑定，输出window</span></span><br></pre></td></tr></table></figure><h4 id="6-箭头函数的this">6. 箭头函数的this</h4><p>箭头函数不绑定 this，也就是说它没有自己的 this，而是根据外层作用域来决定this</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 在这里this的外层作用域就是 window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// window</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>再来看一个案例：</p><p>使用<strong>setTimeout</strong>模拟一个网络请求，如果我们想把返回来的数据保存到 data 中，该怎么做</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">getData</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj 对象</span></span><br><span class="line">      <span class="comment">// 这里的 this 不是应该指向window吗？</span></span><br><span class="line">      <span class="comment">// 如果我们这里使用的是普通的函数 function() &#123;console.log(this)&#125;</span></span><br><span class="line">      <span class="comment">// 那么这个函数在内部调用的时候，会绑定this，就是window</span></span><br><span class="line">      <span class="comment">// 但是我们使用了箭头函数，它不绑定this，会往上层作用域中找到对应的this</span></span><br><span class="line">      <span class="comment">// 所以找到了 obj</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span> = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// --&gt; obj.data = &quot;hello&quot;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure><h4 id="7-this-的面试题">7. this 的面试题</h4><p>如果每题都会了，那么 this 绑定的问题，就是你的送分题而不是送命题了哈哈哈</p><p>建议把我的答案跟注释都删掉，自己一点点理清哦</p><p><strong>题一</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>; <span class="comment">// window.name = &quot;window&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">// window 很明显是独立函数调用,没有与任何对象关联</span></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">// person 隐式绑定,与person关联</span></span><br><span class="line">  (person.<span class="property">sayName</span>)(); <span class="comment">// person 同上(加括号只是代表这是一个整体)</span></span><br><span class="line">  <span class="comment">// console.log((b = person.sayName)); // 这里实际上就是sayName这个函数</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)(); <span class="comment">// 间接函数引用，是独立函数调用, 输出 window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure><p><strong>题二</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定person1对象</span></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// person1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定person2</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2);  <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数不适用任何规则, 向上层作用域中找this</span></span><br><span class="line">person1.<span class="title function_">foo2</span>(); <span class="comment">// window</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3()返回了一个函数，然后独立调用</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3.call(person2) 返回的是一个函数，然后独立调用</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3()返回一个函数，然后显式绑定到 person2</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2); <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4()返回一个箭头函数，往上层作用域找，找到foo4中绑定的this,是 person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>()(); <span class="comment">// person1</span></span><br><span class="line"><span class="comment">// foo4显示绑定到 person2</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// person1.foo4()返回箭头函数，往上层作用域找</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2); <span class="comment">// person1</span></span><br></pre></td></tr></table></figure><p><strong>题三</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo1</span>() <span class="comment">// person1 隐式绑定</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2) <span class="comment">// person2 显式绑定</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>() <span class="comment">// person1 隐式绑定</span></span><br><span class="line"><span class="comment">// 箭头函数不适用显式绑定规则，直接向上层作用域找</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2) <span class="comment">// person1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3() 返回一个函数，在全局调用</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()() <span class="comment">// window</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window // 同理</span></span><br><span class="line"><span class="comment">// person1.foo3() 返回的函数使用 .call 显式绑定 person2</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2) <span class="comment">//person2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4() 返回一个箭头函数，再调用，向上层作用域找</span></span><br><span class="line">person1.<span class="title function_">foo4</span>()() <span class="comment">// person1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4.call(person2) 返回箭头函数，并且foo4显式绑定this为person2</span></span><br><span class="line"><span class="comment">// 再调用这个箭头函数，向上找就找到 foo4 的this 为person2</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4() 返回箭头函数,不适用显式绑定，向上找到 person1</span></span><br><span class="line"><span class="comment">// 注意这里跟上面的区别，这里的foo4调用不是.call调用的，而是.foo4()这样调用的</span></span><br><span class="line"><span class="comment">// call是来调用箭头函数的，而箭头函数不适用显式绑定，向上找到的是person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2) <span class="comment">// person1</span></span><br></pre></td></tr></table></figure><p><strong>题四</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.obj.foo1()返回一个函数，在全局中调用</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>()() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// person1.obj.foo1.call(person2) 返回一个函数 在全局中调用</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo1</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// person1.obj.foo1() 返回一个函数，显式绑定person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>().<span class="title function_">call</span>(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数调用，向上找到 foo2 中的this是obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>()() <span class="comment">// obj</span></span><br><span class="line"><span class="comment">// foo2调用的时候显式绑定person2，箭头函数向上层找到的就是person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo2</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// 箭头函数不适用 显式绑定，向上找找到 obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>().<span class="title function_">call</span>(person2) <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JS-函数的-this-指向&quot;&gt;JS 函数的 this 指向&lt;/h3&gt;
&lt;h4 id=&quot;1-this-在全局作用域下的指向&quot;&gt;1. this 在全局作用域下的指向&lt;/h4&gt;
&lt;p&gt;在浏览器中，this在全局作用域下指向 window&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="深入JS高级语法" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>02_JS内存管理和闭包</title>
    <link href="https://hillyee.github.io/2022/03/30/JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>https://hillyee.github.io/2022/03/30/JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/</id>
    <published>2022-03-30T10:49:50.000Z</published>
    <updated>2022-03-31T10:55:36.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JS-的内存管理">一、JS 的内存管理</h2><h4 id="1-JS-的内存管理">1. JS 的内存管理</h4><ul><li>JavaScript 会在定义变量时为我们分配内存</li><li>内存分配的方式是一样的吗？<ul><li>JS 对于基本数据类型内存的分配，会在执行时直接在栈空间进行分配</li><li>JS 对于复杂数据类型内存的分配，会在堆内存中开辟一块空间，并且将这块空间的地址保存在栈空间</li></ul></li></ul><h4 id="2-JS-的垃圾回收">2. JS 的垃圾回收</h4><ul><li>垃圾回收的英文是 Garbage Collection，简称 GC</li><li>对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放出更多的内存空间</li><li>JavaScript的运行环境 js引擎都会内存垃圾回收器</li></ul><h4 id="3-常见的两个-GC-算法">3. 常见的两个 GC 算法</h4><p>GC怎么知道哪些对象是不再使用的呢？这里就要用到 GC 算法了</p><h5 id="3-1-引用计数"><strong>3.1 引用计数</strong></h5><ul><li><p>当一个对象有一个引用指向它的时候，那么这个对象的引用就 +1，当一个对象的引用为 0 时，这个对象就可以被回收掉</p></li><li><p>但是这个算法有一个很大的弊端，就是会产生循环引用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">friend</span>: obj2&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">friend</span>: obj1&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5ae097e453a43cc84b2ff11211ac823~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220326000211839.png"></p><hr><h5 id="3-2-标记清除">3.2 标记清除</h5><ul><li>这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d16ee47dfe794e74a2cef9747d341bcc~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220326000504460.png"></p><p>​图中从 A 开始找，找到 D 的时候结束，M,N不可达，被认为是不可用的对象</p><ul><li>这个算法可以很好的解决循环引用的问题</li></ul><p>注：JS 引擎比较广泛采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，在算法的实现细节上也会结合一些其他的算法</p><h2 id="二、JS中的闭包">二、JS中的闭包</h2><h4 id="1-什么是闭包？">1. 什么是闭包？</h4><p>JavaScript 中的一个函数，如果它访问了外层作用域的变量，那么这个函数是一个闭包。</p><p>MDN中的一个解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name)<span class="comment">// name访问了外层作用域的变量name</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// age访问了外层作用域的变量age</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bar <span class="comment">// 返回一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h4 id="2-闭包的访问过程">2. 闭包的访问过程</h4><p>简单描述上面函数的执行过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="attr">GO</span>: &#123;<span class="attr">foo</span>:地址<span class="number">1</span>, <span class="attr">fn</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="number">2.</span> 执行代码：</span><br><span class="line">   <span class="number">2.1</span> <span class="title function_">foo</span>():只要执行函数，就会创建一个函数执行上下文</span><br><span class="line">     (<span class="number">1</span>)<span class="attr">VO</span>: &#123;<span class="variable constant_">AO</span>对象:&#123;<span class="attr">name</span>: <span class="literal">undefined</span>;<span class="attr">age</span>:<span class="literal">undefined</span>;<span class="attr">bar</span>:地址<span class="number">2</span>&#125;&#125;</span><br><span class="line">        <span class="attr">scopechain</span>:[<span class="variable constant_">VO</span>+parent scopes]</span><br><span class="line"> (<span class="number">2</span>)开始执行代码 &#123;<span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>;&#125; <span class="keyword">return</span> bar地址<span class="number">2</span></span><br><span class="line"> (<span class="number">3</span>)foo执行完毕</span><br><span class="line">   <span class="number">2.2</span> <span class="attr">fn</span>: bar地址<span class="number">2</span></span><br><span class="line">   <span class="number">2.3</span> <span class="title function_">fn</span>(),即执行 bar地址<span class="number">2</span>中的函数执行体,创建bar的函数执行上下文</span><br><span class="line">      (<span class="number">1</span>)&#123;<span class="attr">AO</span>:&#123;&#125;,scopechain&#125;</span><br><span class="line">       (<span class="number">2</span>)执行代码:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name):在自己的<span class="variable constant_">AO</span>中找不到，通过作用域链找到foo的<span class="variable constant_">AO</span>，找到<span class="attr">name</span>:<span class="string">&quot;foo&quot;</span>,输出 <span class="string">&quot;foo&quot;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(age)同理</span><br><span class="line">   (<span class="number">3</span>)<span class="title function_">fn</span>()执行完毕</span><br><span class="line"><span class="number">3.</span>执行完毕</span><br><span class="line">地址<span class="number">1</span>:foo函数对象: &#123;<span class="attr">parentScope</span>: <span class="variable constant_">GO</span>&#125;,&#123;foo函数的执行体&#125;</span><br><span class="line">地址<span class="number">2</span>:bar函数对象: &#123;<span class="attr">parentScope</span>: foo的<span class="variable constant_">AO</span>对象&#125;,&#123;bar函数的执行体&#125;</span><br></pre></td></tr></table></figure><p>你可能会有疑惑：foo函数执行完毕之后，不是应该弹出栈吗，foo的AO对象不应该被释放了吗？怎么bar还能找到 name，找到 age 呢？</p><p>看下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0596bf34709b420e83d0b18255b35a8e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220326190828378.png"></p><p>可以看到，当我们执行完 foo 函数的时候，返回的是 bar 函数(或者说是bar的地址)，然后因为 <code>fn = foo()</code>，把这个地址赋值给了fn，因此会存在 fn 指向 bar函数对象，而bar的父作用域又指向了 foo 的AO对象，因此foo的AO是不会被释放的</p><h4 id="3-闭包的内存泄漏">3. 闭包的内存泄漏</h4><p><strong>为什么总说闭包是有内存泄漏的呢？什么是内存泄漏？</strong></p><p>拿上面的例子说，如果后续我们不会再用 foo，bar 这些函数了，但是在全局作用域下 fn 变量对bar函数对象有引用，而bar的作用域中AO对foo的AO有引用，所以会造成这些内存都是无法被释放的。</p><p>这就是我们所说的内存泄漏，其实就是刚才的引用链中的对象无法释放</p><p><strong>怎么解决这个问题呢？</strong></p><p>很简单，设置 fn = null，就不再对 bar 函数对象有引用，那么从GO出发，bar是不可达的，那么对应的AO对象(foo) 同样也就不可达。</p><p>在下一次 GC 的的检测中，它们就会被销毁掉</p><p><strong>还有一个问题，形成闭包之后，是不是所有的属性都不会被释放呢？</strong></p><p>还是这个例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="comment">// console.log(age) </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><p>如果age不使用了，会不会被销毁掉呢？<br>答案是会的，测试如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf0ce1e854b45628e802630620b740b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220327110308371.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ae9ba0420c41a0bc10be84501afbd4~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220327110407999.png"></p><p>这是因为 V8 引擎做的优化，因为规范中闭包的属性应该是不会被销毁的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、JS-的内存管理&quot;&gt;一、JS 的内存管理&lt;/h2&gt;
&lt;h4 id=&quot;1-JS-的内存管理&quot;&gt;1. JS 的内存管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript 会在定义变量时为我们分配内存&lt;/li&gt;
&lt;li&gt;内存分配的方式是一样的吗？
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="深入JS高级语法" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>01_深入JS运行原理</title>
    <link href="https://hillyee.github.io/2022/03/30/%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://hillyee.github.io/2022/03/30/%E6%B7%B1%E5%85%A5JS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-30T10:49:46.000Z</published>
    <updated>2022-03-31T10:46:03.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-从输入-URL-到页面展示-发生了什么？">1. 从输入 URL 到页面展示 发生了什么？</h3><p>总体分为以下过程：</p><ul><li>DNS 域名解析：将域名解析成 IP 地址</li><li>TCP 连接：TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ul><h3 id="2-浏览器工作原理">2. 浏览器工作原理</h3><p>在浏览器中输入查找内容，浏览器是怎样将页面加载出来的？</p><p>大致流程如下：</p><ul><li>首先，用户输入服务器地址，与服务器建立连接</li><li>服务器返回对应的静态资源（index.html）</li><li>然后浏览器拿到 index.html 后进行解析</li><li>当解析时遇到 css 或 js 文件，就向服务器请求并下载对应的 css 和 js 文件</li><li>最后浏览器对页面进行渲染，执行 js 代码</li></ul><h3 id="3-浏览器渲染过程">3. 浏览器渲染过程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fceb0c8f81764c578d11e3b428d9ec61~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325160129577.png"></p><ol><li><p>HTML Parser 将 HTML解析转换成 DOM 树</p></li><li><p>CSS Parser 将 样式表转换成 CSS 规则树</p></li><li><p>合并 DOM 树和 CSS 规则树，生成 render（渲染） 树</p></li><li><p>布局 render 树（Layout）</p><p>通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</p></li><li><p>绘制 render 树（painting），进行 Display 展示</p></li></ol><p>注意图中顶部的紫色 DOM 三角形，实际上是 js 对 DOM 的相关操作。</p><h3 id="4-一个强大的-JavaScript-引擎-—-V8-引擎">4. 一个强大的 JavaScript 引擎 — V8 引擎</h3><p>在解析 HTML 的过程中，遇到了 JavaScript 标签，该怎么办呢？</p><ul><li>会停止解析 HTML ，而去加载和执行 JavaScript 代码</li></ul><p>那么，JavaScript 代码由谁来执行呢？</p><ul><li><p>JavaScript 引擎</p><p>高级的编程语言最终都要转成机器指令来执行的，</p><p>所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行</p></li></ul><h4 id="（1）V8-引擎的架构">（1）<strong>V8 引擎的架构</strong></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b0f83a00e64e2587ab3d79a4c524fd~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325165859884.png"></p><p>V8 的底层架构主要有三个核心模块（Parse、Ignition、TurboFan）</p><p><strong>1. Parse</strong>：</p><p>该过程主要是对 JavaScript 源代码进行<strong>词法分析</strong>和<strong>语法分析</strong>。</p><p><strong>词法分析</strong>：对代码中的每一个词每一个符号进行解析，最终生成很多 tokens</p><p>例如：对 const name = “curry”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先对const进行解析，因为const为一个关键字，所以类型会被记为一个关键词，值为const</span></span><br><span class="line"><span class="attr">tokens</span>: [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;keyword&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;const&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着对name进行解析，因为name为一个标识符，所以类型会被记为一个标识符，值为name</span></span><br><span class="line"><span class="attr">tokens</span>: [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;keyword&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;const&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;identifier&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;name&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以此类推...</span></span><br></pre></td></tr></table></figure><p><strong>语法分析</strong>：在词法分析的基础上，拿到 tokens 中的一个个对象，根据不同类型，再进一步分析具体语法，最终生成 AST 抽象语法树</p><p>可以详细查看通过 Parse 转换后的 AST 的工具：AST Explorer</p><p><strong>2. Ignition</strong></p><p>一个解析器，可以将 AST 转换成 ByteCode（字节码）</p><p><strong>3. TurboFan</strong></p><p>一个编译器，可以将字节码编译为 CPU 认识的机器码</p><h4 id="（2）V8-引擎的执行过程">（2）V8 引擎的执行过程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f816f1a12884ef6bf8fe4ffec33a2ce~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325171051967.png"></p><ul><li>Blink 内核将 JS 源码交给 V8 引擎</li><li>Stream 获取到 JS 源码进行编码转换</li><li>Scanner 进行词法分析，将代码转换成 tokens</li><li>Parser 和 PreParser<ul><li>Parser ：直接解析，将 tokens 转成 AST 树</li><li>PreParser：预解析，对不必要的函数进行预解析，也就是只解析暂时需要的内容，而在函数被调用时才进行函数的全量解析</li></ul></li><li>生成 AST 树后，会被 Ignition 转成字节码，之后就是代码的执行过程</li></ul><h3 id="5-JavaScript-的执行过程">5. JavaScript 的执行过程</h3><p>假如要执行如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> title = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">30</span></span><br><span class="line"><span class="keyword">var</span> result = num1 + num2</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><p>（1）首先，<strong>代码被解析</strong>，V8 引擎内部会帮助我们创建一个全局对象：Global Object（GO）</p><ul><li><p>GO 可以访问所有的作用域</p></li><li><p>里面会包含 Date、Array、String、setTimeout等等（所以我们可以直接 new Date() ）</p></li><li><p>GO 还有一个window 属性指向自己（所以window.window.window还是指向 GO自己）</p></li></ul><p>用伪代码表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalObject = &#123;</span><br><span class="line">    <span class="title class_">String</span>: 类,</span><br><span class="line">    <span class="attr">setTimeout</span>: 函数,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">window</span>: globalObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<strong>然后运行代码</strong></p><ol><li><p>首先我们要知道 js 引擎内部有一个<strong>执行上下文栈</strong>（Execution Context Stack，简称 ESC），它是用于执行代码的调用栈。</p></li><li><p>为了全局代码能够正常执行，首先需要创建一个**全局执行上下文 **（Global Execution Context，简称GEC），全局代码需要被执行时才会创建</p></li><li><p>然后全局执行上下文会被放入执行上下文栈中执行，包含两个部分：</p><ul><li>在代码执行前，会将全局定义的变量，函数等加入到 <strong>GlobalOject</strong> 中，但是并不会赋值（也称为<strong>变量的作用域提升</strong>）</li></ul></li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/848e146926d641b99e2b502e31c08913~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325191605422.png"></p><ul><li><p>开始依次执行代码：</p><p>title = “hello” // 赋值</p><p>console.log(num1) // undefined, 不会报错</p><p>num1= 20 …</p></li></ul><p><strong>遇到函数如何执行?</strong></p><p>先根据函数体创建一个<strong>函数执行上下文</strong>，并且压入到执行上下文栈中</p><p><strong>作用域链？</strong></p><p>由 VO(变量对象，在函数中就是 AO 对象)和 父级 VO组成，查找时会一层层查找</p><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello Global&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// Hello Global</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;Hello Bar&quot;</span></span><br><span class="line">  <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure><p>比如说这里，当执行 foo 函数的时候， foo 的 AO 中没有message，就会去它的父级 VO 中查找。一定要注意！当第一次代码解析的时候， foo 的函数执行上下文就已经确定了，其中包括三部分：</p><ul><li><p>第一部分：在解析函数成为 AST 树结构的时候，会创建一个 AO（Activation）</p><p>其中包含形参、arguments、函数定义、指向函数对象或定义的变量</p></li><li><p>第二部分：就是作用域链</p></li><li><p>第三部分：this 绑定的值</p></li></ul><p>因此！当foo在自己的AO找不到message的时候，去父级 VO 找，这个父级 VO 就是一开始解析时候保存的 GO，所以message为 “Hello Global”</p><p>简单描述一下这个过程吧：(我不专业的表达)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 GO</span></span><br><span class="line"><span class="attr">GO</span>: &#123;<span class="variable language_">window</span>; <span class="attr">message</span>:<span class="literal">undefined</span>; <span class="attr">foo</span>: 地址<span class="number">1</span>; <span class="attr">bar</span>: 地址<span class="number">2</span>;&#125;</span><br><span class="line"><span class="comment">// 执行代码</span></span><br><span class="line"><span class="attr">GO</span>: &#123;<span class="variable language_">window</span>; <span class="attr">message</span>:<span class="string">&quot;Hello Global&quot;</span>; <span class="attr">foo</span>: 地址<span class="number">1</span>; <span class="attr">bar</span>: 地址<span class="number">2</span>;&#125;</span><br><span class="line">bar函数执行,创建一个函数执行上下文,</span><br><span class="line">其中包括 <span class="variable constant_">VO</span>对象: <span class="attr">AO</span>:&#123;<span class="attr">message</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line">然后开始执行 bar函数</span><br><span class="line"><span class="attr">message</span>:<span class="string">&quot;Hello Bar&quot;</span> (赋值)</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">  foo函数执行，创建一个foo的函数执行上下文</span><br><span class="line">  其中包括：<span class="attr">VO</span>: <span class="attr">AO</span>: &#123;&#125; </span><br><span class="line">  然后开始执行代码</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">  发现自己的<span class="variable constant_">AO</span>没有message,会向上找，即从自己保存的父级<span class="variable constant_">VO</span>中查找，找到<span class="variable constant_">GO</span>中的message为 <span class="string">&quot;Hello Global&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5dfbf8412334fbfbec579813c39c58d~tplv-k3u1fbpfcp-watermark.image?" alt="image-20220325231532928.png"><br>(图来源于coderwhy)</p><h4 id="几道常见的作用域提升面试题：">几道常见的作用域提升面试题：</h4><ol><li><pre><code class="language-js">var n = 100function foo() &#123;  n = 200&#125;foo()console.log(n) // 200<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   function foo() &#123;</span><br><span class="line">     console.log(n) // undefined</span><br><span class="line">     var n = 200</span><br><span class="line">     console.log(n) // 200</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   var n = 100</span><br><span class="line">   foo()</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-js">var a = 100function foo() &#123;  console.log(a) // undefined  return  var a = 200&#125;foo()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```js</span><br><span class="line">   function foo() &#123;</span><br><span class="line">     m = 100</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   foo()</span><br><span class="line">   console.log(m) // 100</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-js">function foo() &#123;  var a = b = 10  // =&gt; 转成下面的两行代码  // var a = 10  // b = 10&#125;foo()//console.log(a) // 报错 a is not defined(因为当 foo函数执行完之后，foo的函数执行上下文就会弹出栈(没啦！哪里还会有a呢))console.log(b) // 10</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-从输入-URL-到页面展示-发生了什么？&quot;&gt;1. 从输入 URL 到页面展示 发生了什么？&lt;/h3&gt;
&lt;p&gt;总体分为以下过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 域名解析：将域名解析成 IP 地址&lt;/li&gt;
&lt;li&gt;TCP 连接：TCP 三次握手&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="深入JS高级语法" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hillyee.github.io/2022/03/29/hello-world/"/>
    <id>https://hillyee.github.io/2022/03/29/hello-world/</id>
    <published>2022-03-29T14:25:03.367Z</published>
    <updated>2022-03-29T14:25:03.367Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>

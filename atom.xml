<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hillyee-blog</title>
  
  
  <link href="https://hillyee.github.io/atom.xml" rel="self"/>
  
  <link href="https://hillyee.github.io/"/>
  <updated>2022-07-02T16:31:22.707Z</updated>
  <id>https://hillyee.github.io/</id>
  
  <author>
    <name>Hillyee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题—HTML篇</title>
    <link href="https://hillyee.github.io/2022/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94HTML%E7%AF%87/"/>
    <id>https://hillyee.github.io/2022/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94HTML%E7%AF%87/</id>
    <published>2022-07-02T16:28:59.000Z</published>
    <updated>2022-07-02T16:31:22.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML面试题">HTML面试题</h2><h3 id="从浏览器地址栏输入url到页面渲染发生了什么？">从浏览器地址栏输入url到页面渲染发生了什么？</h3><blockquote><p>推荐文章：<a href="https://juejin.cn/post/6935232082482298911">从输入URL开始建立前端知识体系</a></p></blockquote><blockquote><p>总体来说分为以下几个过程：</p><p><strong>1. 输入网址并解析</strong></p><p>输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求。浏览器发送请求前，会先判断是否命中强缓存策略，如果命中，直接从缓存中获取资源，如果没有命中，浏览器会发送请求，判断是否命中协商缓存，如果命中，直接从缓存获取资源。否则，直接从服务器获取资源</p><p>DNS域名解析，在发起http请求之前，浏览器首先要去获得我们想访问网页的<strong>IP地址</strong>，浏览器会发送一个UDP的包给DNS域名解析服务器。</p><p><strong>2. TCP/IP连接：三次握手</strong></p><p>第一次握手，客户端给服务器发送一个SYN报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态</p><p>第二次握手，服务器收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且指定了自己的初始化序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</p><p>第三次握手，客户端收到 SYN 报文之后，会回应一个 ACK 报文，也是一样的把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态</p><p>最后服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立连接</p><p><strong>3. 发送HTTP请求</strong></p><p><strong>4. 服务器处理请求并返回HTTP报文</strong></p><p><strong>5. 浏览器渲染页面</strong></p><p>首先解析 HTML，构建 DOM 树；然后解析 CSS，生成 CSS 规则树；合并 DOM 树和 CSS 规则树，生成 render 树；布局 render 树（Layout），负责各元素尺寸、位置的计算；最后绘制 render 树（Paint），绘制页面像素信息</p><p><strong>6. 断开连接：TCP四次挥手</strong></p><p>刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则：</p><p>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态</p><p>第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态</p><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态</p><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。</p><p>需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p></blockquote><p>这个问题可以延伸出来的问题太多了！！</p><h3 id="如何理解重排和重绘">如何理解重排和重绘</h3><blockquote><p>推荐文章：<a href="https://juejin.cn/post/7075515261121626119">如何回答如何理解重排和重绘</a></p></blockquote><h4 id="关键渲染路径（CRP）">关键渲染路径（CRP）</h4><p><strong>关键渲染路径</strong>(<strong>Critical Rendering Path</strong>)是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。</p><p>大致步骤是这样：在解析 HTML 时会创建 DOM，HTML 可以请求 JavaScript，而 JavaScript 反过来，又可以更改 DOM。HTML 包含或请求样式，依次来构建 CSSOM。</p><p>浏览器引擎将两者结合起来以创建 Render Tree (渲染树)，Layout(布局)确定页面上所有内容的大小和位置，确定布局后，将像素 Paint (绘制)到屏幕上。</p><h4 id="重排和重绘">重排和重绘</h4><p>重排(Reflow)：元素的 <strong>位置发生变动</strong> 时发生重排，也叫回流。<strong>此时在 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高</strong>。</p><p>重绘(Repaint): 元素的 <strong>样式发生变动</strong> ，但是位置没有改变。<strong>此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化。</strong></p><h4 id="参考回答">参考回答</h4><blockquote><p>重排和重绘是浏览器关键渲染路径上的两个节点， 浏览器的关键渲染路径就是 DOM 和 CSSOM 生成渲染树，然后根据渲染树通过一个布局(也叫 layout)步骤来确定页面上所有内容的大小和位置，确定布局后，将像素绘制 (也叫 Paint)到屏幕上。</p><p>其中重排就是当元素的位置发生变动的时候，浏览器重新执行布局这个步骤，来重新确定页面上内容的大小和位置，确定完之后就会进行重新绘制到屏幕上，所以重排一定会导致重绘。</p><p>如果元素位置没有发生变动，仅仅只是样式发生变动，这个时候浏览器重新渲染的时候会跳过布局步骤，直接进入绘制步骤，这就是重绘，所以重绘不一定会导致重排。</p></blockquote><h3 id="强缓存、协商缓存">强缓存、协商缓存</h3><blockquote><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</p><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0f5e26bfdb749e6a9e339dfac224fe1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:80%;" /></blockquote><h3 id="src和-href的区别">src和 href的区别</h3><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p><ul><li><p><strong>src</strong>：表示<strong>对资源的引用</strong>，当浏览器解析到该元素时，会将资源嵌入到当前文档中元素定义的位置，例如当浏览器发现</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>页面的加载和处理会暂停</strong>，直到浏览器获取、编译和执行文件。它类似于将 js 文件的内容转储到<code>script</code>标签内。<code>img</code>标签的情况类似。它是一个空标签，包含在其中的内容由<code>src</code>属性定义。浏览器暂停加载，直到它获取并加载图像。</p></li><li><p><strong>href</strong>：表示<strong>超文本引用</strong>，它指定一些Web资源的位置，建立引用文档和外部资源之间的链接关系。常用在a、link等标签上。</p></li></ul><p>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器识别到这个资源是一个样式表，并且<strong>页面的处理解析不会暂停</strong>，（渲染可能会暂停，因为浏览器需要样式规则来绘制和渲染页面）。</p><h3 id="对-HTML-语义化的理解">对 HTML 语义化的理解</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--没有语义化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is a footer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--语义化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is a footer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220622145640010.png" alt="image-20220622145640010" style="zoom:67%;" /><p>常见的语义化标签：</p><ul><li>元素放置的位置</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span> 头部</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure><ul><li>嵌入媒体</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span> 视频资源</span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span> 音频资源</span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;xxx.gif&quot;</span>/&gt;</span> 可用于实现任何类型的媒体</span><br></pre></td></tr></table></figure><ul><li>section 和 article</li></ul><p><code>&lt;section&gt;</code>定义文档中的元素，例如章节、标题或具有相同主题的文档的任何其他区域。</p><p><code>&lt;article&gt;</code>包含本身有意义的内容，例如文章、博客和评论。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>主题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>aside</li></ul><p>表示一个和其余页面内容几乎无关的部分，通常，此信息将位于<strong>侧边栏</strong>或不妨碍主要内容的位置。例如：文章旁边出现的广告</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主要内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--其他信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOCTYPE及作用">DOCTYPE及作用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>DOCTYPE是document type（文档类型）的简写，是HTML5中一种标准通用标记语言的<strong>文档类型声明</strong></p></li><li><p>作用：它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚至 JavaScript 脚本的解析。它必须声明在HTML文档的第一行。</p></li><li><p>浏览器渲染页面的两种模式（可通过document.<strong>compatMode</strong>获取）：</p></li></ol><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><p>如果没有DOCTYPE的声明，那么浏览器就会进入怪异模式，那么样式啥的就会失效或怪异。</p><h3 id="script标签中defer和async的区别">script标签中defer和async的区别</h3><blockquote><p>在补充知识有</p></blockquote><p>script 是会阻碍 HTML 解析的，只有下载好并执行完脚本才会继续解析 HTML</p><p>defer 和 async有一个共同点：<strong>下载</strong>此类脚本都不会阻止页面呈现（异步加载），区别在于：</p><ol><li>async 执行与文档顺序无关，先加载哪个就先执行哪个；defer会按照文档中的顺序执行</li><li>async 脚本加载完成后立即执行，可以在DOM尚未完全下载完成就加载和执行；而defer脚本需要等到文档所有元素解析完成之后才执行</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea091aed8364b88a653a13c4845a824~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png" style="zoom:67%;" /><h3 id="meta-标签常用属性与用法">meta 标签常用属性与用法</h3><p>meta用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，常用属性：</p><ol><li><code>charset</code>，用于指定HTML文档的字符编码</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>keywords</code>，页面关键词</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>description</code>，页面描述</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>author</code>，页面作者</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;author_name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p><code>refresh</code>，页面刷新</p><p>如：每30秒刷新一次文档：</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用：结合url实现页面的定时刷新或跳转</p><p>例：5s后跳转到你指定的页面（注意跳转到其他页面浏览器后退按钮是不能用的）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转到某个你指定的网站 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5; url=&#x27;https://www.baidu.com/&#x27;&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 跳转到首页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5; url=&#x27;/&#x27;&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>比如有一个场景：登录成功！xx秒后跳转到首页…</p><ol start="6"><li><p><code>viewport</code>，适配移动端，可以控制视口的大小和比例</p><p>视口是网页中用户可见的区域。它会随着设备的不同而不同</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>width=device-width：设置页面的宽度跟随设备的屏幕宽度(根据设备而变化)。</p><p>initial-scale=1.0：设置浏览器首次加载页面时的初始缩放比例</p></blockquote><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220622133431871.png" alt="image-20220622133431871" style="zoom:80%;" /><ol start="7"><li><code>robots</code>，搜索引擎索引方式</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>index</code>：告诉搜索引擎抓取这个页面</li><li><code>follow</code>：告诉搜索引擎可以从这个页面上找到连接，然后继续访问抓取下去</li><li><code>noindex</code>：告诉搜索引擎不允许抓取这个页面</li><li><code>nofollow</code>：告诉搜索引擎不允许从此页找到链接、拒绝其继续访问</li></ul><p>可以抓取本页，而且可以顺着本页继续索引别的链接（默认行为）：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index, follow&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不允许抓取本页，但是可以顺着本页继续索引别的链接</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;noindex, follow&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以抓取本页，但是不可以顺着本页继续索引别的链接</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index, nofollow&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不允许抓取本页，也不可以顺着本页继续索引别的链接</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;noindex, nofollow&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML5-有哪些更新">HTML5 有哪些更新</h3><p>总结：</p><p>（1）新增语义化标签：nav、header、footer、aside、section、article</p><p>（2）音频、视频标签：audio、video</p><p>（3）数据存储：localStorage、sessionStorage</p><p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p><p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p><p>（6）history API：go、forward、back、pushstate</p><ol><li><p><strong>语义化标签</strong></p><p>header、nav、footer、artical、section、aside</p></li><li><p><strong>媒体标签</strong></p><ul><li><strong>audio</strong>：音频</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 属性</span></span><br><span class="line"><span class="comment">    ● controls 控制面板</span></span><br><span class="line"><span class="comment">    ● autoplay 自动播放</span></span><br><span class="line"><span class="comment">    ● loop=&quot;true&quot; 循环播放</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220622144722909.png" alt="image-20220622144722909" style="zoom:50%;" /><ul><li><strong>video</strong>：视频</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;&quot;</span> <span class="attr">height</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 属性</span></span><br><span class="line"><span class="comment">    ● poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一帧画面，当然通过poster也可以自己指定。</span></span><br><span class="line"><span class="comment">    ● controls：控制面板</span></span><br><span class="line"><span class="comment">    ● width</span></span><br><span class="line"><span class="comment">    ● height</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220622145158828.png" alt="image-20220622145158828" style="zoom:50%;" /></li><li><p><strong>表单</strong></p></li></ol><p><strong>表单类型</strong>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>date ： 日期选择年月日</li><li>datetime ： 时间和日期(目前只有Safari支持)</li><li>datetime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><blockquote><p>建议都自己尝试一遍</p></blockquote><p><strong>表单属性</strong>：</p><ul><li><p>placeholder ：提示信息</p></li><li><p>autofocus ：自动获取焦点</p></li><li><p>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li><p>pattern=&quot; &quot; 里面写入想要的正则模式，例如手机号pattern=“^(+86)?\d{10}$”</p></li><li><p>multiple：可以选择多个文件或者多个邮箱</p></li><li><p>form=“form表单的ID”</p></li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件</li></ul><ol start="4"><li><strong>进度条、度量器</strong></li></ol><ul><li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;90&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220622155233821.png" alt="image-20220622155233821" style="zoom:50%;" /><ul><li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p></li><li><ul><li>high/low：规定被视作高/低的范围</li><li>max/min：规定最大/小值</li><li>value：规定当前度量值</li></ul></li></ul><ol start="5"><li><strong>DOM查询操作</strong></li></ol><ul><li>document.querySelector()：选择第一个满足的</li><li>document.querySelectorAll()：所有满足的</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><ol start="6"><li><strong>Web存储</strong></li></ol><ul><li>HTML5 提供了两种在客户端存储数据的新方法：<ul><li>localStorage：永久存储，需要手动清除</li><li>sessionStorage：会话存储，当前会话关闭就会被清除</li></ul></li></ul><ol start="7"><li>其他</li></ol><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>canvas：提供了一个通过 JavaScript 和 HTML的元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2d：二维渲染上下文</span></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span> = <span class="string">&quot;green&quot;</span></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">100</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置</li></ul><h3 id="img的-srcset-属性的作用？">img的 srcset 属性的作用？</h3><p>srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image-128.png&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;image-256.png 2x&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png</p></blockquote><p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image-128.png&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 360px) 340px, 128px&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸临界点。</p><p>对于 srcset 中的 w 单位，是宽度描述符，例如，渲染一个 450 像素宽的图像对应的描述符字符串： <code>450w</code>。如果可视区域小于这个值，就可以使用这张图片。浏览器会自动选择一个最小的可用图片。</p><p>这里的size意味着：默认显示128px, 如果视区宽度小于360px, 则显示340px。</p><p>size语法：sizes=&quot;[media query] [length], [media query] [length] … &quot;</p></blockquote><h3 id="b与strong的区别、i与em的区别">b与strong的区别、i与em的区别</h3><ul><li>strong与b都表现为粗体，而strong标签有语义，是起到加重语气，强调的效果而b标签应用场合于：摘要中的关键字、评论中的产品名称，或其他典型的应该加粗显示的文字（除此之外无其它特别强调）。而搜索引擎更侧重strong标签。</li><li>i与em都表现为斜体，i仅仅内容展示为斜体，em表示强调的文本</li></ul><h3 id="常用的行内元素、块级元素、空元素有哪些？">常用的行内元素、块级元素、空元素有哪些？</h3><ul><li><p>行内元素有：<code>a b span img input select strong</code></p></li><li><p>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code></p></li><li><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul></li></ul><blockquote><p>补充：</p><ul><li><p><code>&lt;b&gt;</code> 应用场合如：摘要中的关键字、评论中的产品名称，或其他典型的应该加粗显示的文字（除此之外无其它特别强调）。</p><p>不要将<code>&lt;b&gt;</code>元素与<code> &lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。<code> &lt;strong&gt;</code>元素表示某些重要性的文本，<code>&lt;em&gt;</code>强调文本，而<code>&lt;mark&gt;</code>元素表示某些相关性的文本。 <code>&lt;b&gt;</code>元素不传达这样的特殊语义信息；仅在没有其他合适的元素时使用它。（MDN）</p></li><li><p>select ：size属性设置显示几个，multiple设置能否多选</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;pets&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pet-select&quot;</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--Please choose an option--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dog&quot;</span>&gt;</span>Dog<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cat&quot;</span>&gt;</span>Cat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;hamster&quot;</span>&gt;</span>Hamster<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;parrot&quot;</span>&gt;</span>Parrot<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="行内元素和块级元素的区别">行内元素和块级元素的区别</h3><p>一、行内元素和块级元素的区别</p><ol><li>行内元素不会占据整行，在一条直线上排列，都是同一行，水平方向排列；块级元素会占据一行，垂直方向排列。</li><li>块级元素可以包含行内元素和块级元素；行内元素不能包含块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上，行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。</li></ol><p>二、行内元素和块级元素的相互转换</p><ol><li>行内元素转化为块元素： display:block;</li><li>块元素转化为行内元素： display:inline;</li></ol><h3 id="对-web-worker-的理解">对 web worker 的理解</h3><p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。它是真正的操作系统线程，可以在当前页面的后台生成，以便于执行复杂且资源密集型的任务。</p><p>想象一下，如果有很多数据要从服务器获取，或者需要在 UI 上完成一些复杂的渲染。如果直接在该网页上执行此操作，则该页面的加载可能会出现问题，并会影响 UI。</p><p>为了缓解这种情况，我们可以简单地创建一个线程——即 web worker——并让 web worker 处理复杂的事情。</p><p>另外，可以通过一种非常简单的方式与 Web Worker 进行通信，该方式可用于在 Worker 和 UI 之间来回传输数据。</p><p>Web Worker 常见应用：</p><ul><li>显示股票价格、实时活跃用户等<strong>实时数据</strong>的仪表板页面</li><li>从服务器获取大文件</li><li>自动保存功能</li></ul><p>创建 Web Worker：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>Worker</code>是一个 API 接口，可让我们在后台创建线程。我们需要传递一个参数，即一个<code>&lt;worker_file&gt;.js</code>文件，用于指定 API 需要执行的文件。</p><p><strong>注意</strong>：一旦发起调用，就会创建一个线程。这个线程只和它的创建者通信，也就是创建这个线程的文件。</p><p>如果希望一个worker被共享或使用（应用在多个不同的页面），可以用 <code>SharedWorker</code>创建</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&quot;worker.js&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="HTML5的离线储存">HTML5的离线储存</h3><blockquote><p>尚未实际操作</p></blockquote><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p><strong>原理：<strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的</strong>缓存机制</strong>(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p><p>**如何更新缓存：**更新 manifest 文件、通过 javascript 操作、清除浏览器缓存</p><p><strong>浏览器如何对 HTML5 的离线储存资源进行管理和加载？</strong></p><ul><li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li><li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li></ul><h3 id="什么是-iframe-以及优缺点">什么是 iframe 以及优缺点</h3><ol><li><strong>什么是 iframe 内联框架？</strong></li></ol><p>本质上，iframe（内联框架）是在文档中加载另一个 HTML 页面的HTML元素。它本质上是在父页面中放置另一个网页。</p><ol start="2"><li><strong>如何使用？</strong></li></ol><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220625174518518.png" alt="image-20220625174518518" style="zoom:67%;" /><img src="D:/web_a/typora%E5%9B%BE%E7%89%87/image-20220625174641714.png" alt="image-20220625174641714" style="zoom:80%;" /><ol start="3"><li><strong>原理？</strong></li></ol><p>当 Web 浏览器遇到 iframe 元素时，它会创建一个新的 HTML 文档环境来加载其中的内容。它从引用的 src 或 srcdoc 中获取代码，并将其呈现为自己的网站，然后将其完全放在父浏览页面中。</p><p>子 iframe 是在父框架内的完整浏览环境。它可以独立于父级加载自己的JavaScript 和 CSS ，也可以从父站点异步刷新和加载。</p><p>父站点可以定义 iframe 的各个方面，例如大小、位置等。</p><ol start="4"><li><strong>应用场景？</strong></li></ol><p>通常用于将外部广告、视频、标签、地图或其他交互元素嵌入到页面中。</p><ol start="5"><li><strong>iframe的优缺点</strong></li></ol><p><strong>优点</strong>：</p><ul><li>使用方便</li><li>浏览器兼容性较好</li><li>允许嵌入第三方内容</li><li>绕过 CORS （跨域）限制，实现跨子域通信</li></ul><p><strong>缺点</strong>:</p><ul><li><p>减慢页面加载速度</p></li><li><p>第三方网站不受控制</p><ul><li>所以如果你认为某个网站不安全，不要将其内容放入 iFrame 元素中</li></ul></li><li><p>可能会影响搜索引擎优化</p></li><li><p>会产生很多页面，不容易管理</p><h3 id="label-的作用是什么？如何使用？"><code>&lt;label&gt;</code>的作用是什么？如何使用？</h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p><p>使用方法1：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>点击click me 的时候也可以勾选上</p></blockquote><p>使用方法2：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>click me</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Canvas-和-SVG的区别">Canvas 和 SVG的区别</h3><ol><li><strong>SVG</strong></li></ol><p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言<strong>XML</strong>描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">viewbox</span>=<span class="string">&quot;0 0 600 600&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>Red rectangle shape<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;10&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#c00&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其特点如下：</p><ul><li>不依赖分辨率（放大缩小不失真）</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><ol start="2"><li><strong>Canvas</strong>：</li></ol><p>Canvas是画布，通过Javascript来绘制图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。（Canvas 是一个 JavaScript 绘图 API）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;578&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myCanvas&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> centerX = canvas.<span class="property">width</span> / <span class="number">2</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> centerY = canvas.<span class="property">height</span> / <span class="number">2</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> radius = <span class="number">70</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">beginPath</span>()</span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">arc</span>(centerX, centerY, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>)</span></span><br><span class="line"><span class="language-javascript">    context.<span class="property">fillStyle</span> = <span class="string">&quot;green&quot;</span></span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">fill</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器（Canvas 没有 DOM ）</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><blockquote><p>推荐文章：<a href="https://www.sitepoint.com/canvas-vs-svg/">Canvas vs SVG</a></p></blockquote><h3 id="head-标签有什么作用，其中什么标签必不可少？">head 标签有什么作用，其中什么标签必不可少？</h3><p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt; </code>中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;</code>。</p><blockquote><p>HTML<code>&lt;base&gt;</code>元素 指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个<code>&lt;base&gt;</code>元素。</p></blockquote><p>其中<code>&lt;title&gt;</code>定义文档的标题，它是 head 部分中唯一必需的元素。</p><h3 id="说一下-HTML5-drag-API">说一下 HTML5 drag API</h3><ul><li>dragstart：事件主体是被拖放元素，在<strong>开始拖放</strong>元素时触发。</li><li>drag：事件主体是被拖放元素，在<strong>正在拖放</strong>被拖放元素时触发。</li><li>dragenter：事件主体是目标元素，在被拖放元素<strong>进入某元素时</strong>触发。</li><li>dragover：事件主体是目标元素，在被拖放<strong>在某元素内移动时</strong>触发。</li><li>dragleave：事件主体是目标元素，在被拖放元素<strong>移出目标元素</strong>时触发。</li><li>drop：事件主体是目标元素，在<strong>被拖放元素释放到目标元素时</strong>触发。 （阻止默认行为）</li><li>dragend：事件主体是被拖放元素，在<strong>整个拖放操作结束时</strong>触发。（释放鼠标）</li></ul><blockquote><p><a href="https://web.dev/drag-and-drop/">使用 HTML5 拖放 API</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML面试题&quot;&gt;HTML面试题&lt;/h2&gt;
&lt;h3 id=&quot;从浏览器地址栏输入url到页面渲染发生了什么？&quot;&gt;从浏览器地址栏输入url到页面渲染发生了什么？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐文章：&lt;a href=&quot;https://juejin.cn/</summary>
      
    
    
    
    <category term="😣前端面试题大全" scheme="https://hillyee.github.io/categories/%F0%9F%98%A3%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Promise面试题(持续更新~)</title>
    <link href="https://hillyee.github.io/2022/04/22/Promise%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://hillyee.github.io/2022/04/22/Promise%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-04-22T03:01:08.000Z</published>
    <updated>2022-04-22T03:10:50.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise面试题">Promise面试题</h2><h3 id="几道打印的基础题">几道打印的基础题</h3><h4 id="题1">题1</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1 2 4 3</p></blockquote><h4 id="题2">题2</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>, promise2)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751fd1862f5d45da84fd5c78be97f7b6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="题3">题3</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1<br>2<br>success</p></blockquote><h4 id="题4">题4</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>2<br>1<br>success</p></blockquote><h3 id="Promise结合setTimeout">Promise结合setTimeout</h3><h4 id="题1-2">题1</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1432</p></blockquote><h4 id="题2-2">题2</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>14523success</p></blockquote><h4 id="题3-2">题3</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>51342</p></blockquote><h4 id="题4-2">题4</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88748175c2814348aa8e523c251bbee9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Promise面试题&quot;&gt;Promise面试题&lt;/h2&gt;
&lt;h3 id=&quot;几道打印的基础题&quot;&gt;几道打印的基础题&lt;/h3&gt;
&lt;h4 id=&quot;题1&quot;&gt;题1&lt;/h4&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;c</summary>
      
    
    
    
    <category term="😣面试题-js篇" scheme="https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"/>
    
    
    <category term="promise" scheme="https://hillyee.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>手写promise</title>
    <link href="https://hillyee.github.io/2022/04/17/%E6%89%8B%E5%86%99promise/"/>
    <id>https://hillyee.github.io/2022/04/17/%E6%89%8B%E5%86%99promise/</id>
    <published>2022-04-17T15:24:47.000Z</published>
    <updated>2022-04-18T01:35:17.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写Promise">手写Promise</h2><h3 id="Promise规范">Promise规范</h3><blockquote><p><a href="https://promisesaplus.com/">https://promisesaplus.com/</a>  PromiseA+规范</p><p>A+规范只有then方法</p></blockquote><h3 id="Promise-类设计">Promise 类设计</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种方式，我选第一种</p></blockquote><h3 id="构造函数constructor设计">构造函数constructor设计</h3><p>实现：</p><ol><li>让executor函数执行起来</li><li>定义状态常量</li><li>定义resolve，reject回调，执行的时候改变状态</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUE_PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUE_FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUS_REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存状态与值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_PENDING</span>  </span><br><span class="line">    <span class="comment">// 由于后面的then方法可能会用到这些参数值，需要保存起来</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义resolve回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 改变状态并保存值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve执行&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 定义reject回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 改变状态并保存值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject执行&quot;</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>为了不让resolve，reject回调可以同时执行，我们需要加一个判断，只有状态为pending的时候才执行回调</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;  <span class="comment">// 加一个判断</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve执行&quot;</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123; <span class="comment">// 加一个判断</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject执行&quot;</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then-方法的实现">then 方法的实现</h3><h4 id="简单实现">简单实现</h4><ol><li>then方法接收两个参数，分别是成功时的回调onFulfilled，失败时的回调onRejected</li><li>把回调保存到当前的promise实例，并在对应的resolve，reject回调时执行</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve执行&quot;</span>, value);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>) <span class="comment">// 在这里执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject执行&quot;</span>, reason);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)  <span class="comment">// 在这里执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilled</span> = onFulfilled  <span class="comment">// 保存方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejected</span> = onRejected <span class="comment">// 保存方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候我们会发现，报错了：this.onFulfilled is not a function</p><p>为什么？？</p><p>我们捋一捋代码的执行过程就可以发现，当执行<code>resolve(&quot;111&quot;)</code> 的时候，都还没有到then那一步，也就是说还没执行then方法，那么怎么可能会有 <code>onFulfilled, onRejected</code> 方法呢！</p><p>这时候我们就用到了一个方法：<code>queueMicrotask()</code></p><blockquote><p>MDN：<a href="https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask">https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask</a></p><p>简单来说，这个方法可以把我们传入的方法加入到微任务队列，让它延迟到当前主线程的任务执行完之后再执行</p></blockquote><p>所以可以在resolve方法执行的时候，先不执行onFulfilled，把它加入到微任务队列，接着就会继续执行下面的then方法，这时候就有<code>onFulfilled, onRejected</code> 方法了，最后主线程任务执行完，再执行微任务队列中的 onFulfilled，，（reject同理）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;   <span class="comment">// 加入到微任务队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 加入到微任务队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个时候又出现了一个问题，resolve和reject可以同时调用了</p><p>因为我们执行resolve的实现，加入到微任务队列，因此状态没有被改变，依然是pending</p><p>接着执行reject，判断状态是pending，所以也加入到微任务队列了</p><p>解决：在执行微任务的代码一开始加入一个判断，如果状态已经不是pending了，直接return出去，停止执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span>  <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span> <span class="comment">// 添加判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，有人可能会说把状态改变放到微任务外面不就行了吗？</p><p>不行！！这样在后面实现链式调用会出现问题</p><p>你后面可以试一下，多个then执行和链式调用一起的时候，执行顺序是有问题的</p><p>至于为什么，那就自己捋一捋整个代码的执行顺序叭</p></blockquote><h4 id="同时调用多个then的实现">同时调用多个then的实现</h4><p>上面的实现是不能同时调用多个then的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res2: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err2: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>后面的then会覆盖前面的，因此只会执行 res2 或者 err2</p><p>实现思路：我们需要把then传入的回调保存到一个数组，到时候一起执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = [] <span class="comment">// 定义数组存放成功的回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [] <span class="comment">// 定义数组存放失败的回调</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;   <span class="comment">// 加入到微任务队列</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUE_FULFILLED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">          <span class="comment">// 用forEach遍历执行数组中的回调 </span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;  </span><br><span class="line">            <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 加入到微任务队列</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">STATUE_PENDING</span>) <span class="keyword">return</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">STATUS_REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">          <span class="comment">// 用forEach遍历执行数组中的回调</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled)  <span class="comment">// 保存到数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res2: &quot;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err2: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="延迟调用then">延迟调用then</h4><p>还有一种情况：resolve或reject执行完之后，延迟执行then</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res3: &quot;</span>, res);</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err3: &quot;</span>, err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>setTimeout 会在主线程的任务执行完，并且微任务队列也执行完后才执行</p><p>捋一捋执行顺序：</p><ol><li><p>首先主线程 <code>resolve(&quot;111&quot;)</code>执行，先<strong>改变状态为fulfilled</strong>，保存value，然后在微任务队列中加入一个任务</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7c758c4c8fc4368951ba935c8a4ea75~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li><li><p>然后继续往下，<strong>setTimeout</strong> 被加入到宏任务队列，并未执行then</p></li><li><p>主线程任务执行完，执行微任务队列中的任务，<strong>遍历数组中的函数并执行</strong>，但我们可以看到，前面then没有执行，数组中并没有对应回调，所以没有执行</p></li><li><p>接着执行宏任务队列中setTimeout，也就是then方法被执行，</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc271dd9a1d84d3c8defab59010b4b35~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p><strong>这个时候才把回调加入数组</strong>。。。任务结束</p></li></ol><p>因此可以想到实现思路：在then方法中加入判断，如果当前状态是确定的，（fulfilled或rejected），那么直接执行这个回调，不用添加到数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式调用then">链式调用then</h4><p>then需要返回一个promise，后面才能继续调用then</p><p>并且下一次的then是在上次回调执行完之后才执行的，而且需要拿到上次onFulfilled/onRejected 执行完之后的结果，再去执行resolve，reject</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>() <span class="comment">// 这里需要拿到上次回调的结果并且传进去</span></span><br><span class="line">    <span class="title function_">reject</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有个问题，就是怎么拿到上次执行的结果值？</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0042b6e0559549e1b91351eb795be282~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>思路：把上面那一坨代码放到new里面执行，这样就让里边具备了拿到返回结果的能力</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="comment">// 比如这里就可以拿到结果</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="comment">// 然后再执行(这里已经是下一个promise的resolve了)</span></span><br><span class="line">      <span class="title function_">resolve</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">      <span class="comment">// 注意这里调用的应该是resolve，除非上一次的错误回调函数抛出了错误</span></span><br><span class="line">      <span class="title function_">resolve</span>(reason)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为即使我们不链式调用，里面的代码还是会执行的，我们只是想拿到想要的结果，并且在某个时机调用 resolve, reject</p><p>两种情况都调用resolve？那什么时候调用reject呢？</p><p>我们知道，只有在上次的then中抛出异常了，下次才会执行reject</p><p>所以我们再改进一下：使用try…catch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(reason)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(onFulfilled) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(onRejected) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面都是在状态已经确定之后的情况，我们知道在状态为pending的时候，我们是把回调保存到数组，然后在上面的resolve、reject中遍历数组执行的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">let</span> value = <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">value</span>)  <span class="comment">// 在这里执行的</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那这个执行结果怎么拿到呢然后传给下面的resolve、reject呢？</p><p>解决方案：改进我们添加到数组的方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>()</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>()</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不直接把回调添加到数组，而是使用一个函数包裹起来，那么到时上面遍历执行的就是这个包裹的函数，然后我们在这里内部执行onFulfilled，就可以在这里拿到onFulfilled的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(value)</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(reason)</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，try…catch改进一下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reason = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(reason)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候发现，有一种情况我们没有处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="comment">// resolve(&quot;111&quot;)</span></span><br><span class="line">  <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改进，在 <strong>executor</strong> 那里加try…catch，如果抛出了异常直接执行reject</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err); <span class="comment">// 执行这里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bbb&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res2: &quot;</span>, res); <span class="comment">// 然后来到这里</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err2: &quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/076b7b8527004ff7b91edd5f07a20ddd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>测试没问题！！</p><h4 id="工具函数">工具函数</h4><p>到这里then方法基本就实现完了，但是我们发现很多 try…catch的重复代码</p><p>我们可以做一个抽取，定义一个工具函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">execFunctionWithCatchError</span>(<span class="params">exeFn, value, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title function_">exeFn</span>(value)</span><br><span class="line">    <span class="title function_">resolve</span>(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后优化then方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="comment">// try &#123;</span></span><br><span class="line">      <span class="comment">//   const value = onFulfilled(this.value)</span></span><br><span class="line">      <span class="comment">//   resolve(value)</span></span><br><span class="line">      <span class="comment">// &#125; catch (err) &#123;</span></span><br><span class="line">      <span class="comment">//   reject(err)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="catch-方法的实现">catch 方法的实现</h3><p>catch接收一个参数，也就是失败的回调，因为catch实际上就相当于语法糖，而且也是返回一个新的promise，所以我们可以直接调用then</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="comment">// resolve(111)  </span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>额，报错了</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b877817e3a7c4cc093ddafaea55b641a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>别急，分析原因。</p><p>我们可以观察一下，本来我们的失败回调应该是在第一个then中传入的，是作为第一个promise的失败的回调的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);</span><br><span class="line">&#125;).<span class="title function_">catch</span>()</span><br></pre></td></tr></table></figure><p>但是现在我们写到catch里面，意味着这个catch传入的回调是被加入到一个新的promise中，作为新的promise的失败的回调了，所以执行不到这个回调了</p><blockquote><p>promise1 -&gt; undefined</p><p>promise2 -&gt; err ={}</p></blockquote><p>那么我们怎么样让promise1执行到err ={} 呢？？</p><p>实现思路：假如说promise1的失败回调没有值，我们直接抛出去，这样就会来到promise2中失败的回调了</p><blockquote><p>promise1 -&gt; err =&gt; {throw err} // 抛出去</p><p>promise2 -&gt; err ={} // 就会执行到这里</p></blockquote><p>还有一个地方是，既然onFulfilled或onRejected可能会传进来undefined，那么我们最好加上一个判断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">defaultOnRejected</span> = err =&gt; &#123; <span class="keyword">throw</span> err &#125;  <span class="comment">// 添加部分</span></span><br><span class="line">  onRejected = onRejected || defaultOnRejected</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span> &amp;&amp; onFulfilled) &#123;</span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;</span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onFulfilled) <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">if</span> (onRejected) <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally-方法的实现">finally 方法的实现</h3><p>接收一个参数，无论成功或失败，最后都会执行</p><p>也就是说，成功与失败的回调都是你传入的那个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finally</span></span><br><span class="line"><span class="title function_">finally</span>(<span class="params">onFinally</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFinally</span>()</span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFinally</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还会有一个问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending~&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">111</span>)  <span class="comment">// 调用resolve有问题</span></span><br><span class="line">  <span class="comment">// reject(222) 调用reject没问题</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res); <span class="comment">// 圈1</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);<span class="comment">// 圈2</span></span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>); <span class="comment">// 圈3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分析：捋一捋</p><blockquote><p>如果上面是resolve的话，那么就会执行圈1，然后来到promise2的成功回调</p><p>promise1：成功回调是 圈1，失败回调是我们默认的reject</p><p>promise2：没有成功回调，失败回调是圈2，</p><p>​没有成功回调，这时候就会出错了，后面也不会继续执行了，因此要给默认的成功回调 value =&gt; { return value }</p><p>然后才会执行finally的第一个回调</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">defaultOnRejected</span> = err =&gt; &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">  onRejected = onRejected || defaultOnRejected</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加部分</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">defaultOnFulfilled</span> = value =&gt; &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">  onFulfilled = onFulfilled || defaultOnFulfilled</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 来到这里就可以保证 onRejected，onFulfilled 是有值的了，所以下面的判断也可以不要了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_FULFILLED</span>) &#123;  <span class="comment">// 改了这里</span></span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUS_REJECTED</span>) &#123; <span class="comment">// 改了这里</span></span><br><span class="line">      <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">STATUE_PENDING</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onFulfilled) <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="variable language_">this</span>.<span class="property">value</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">if</span> (onRejected) <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">execFunctionWithCatchError</span>(onRejected, <span class="variable language_">this</span>.<span class="property">reason</span>, resolve, reject)</span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-reject-类方法的实现">resolve reject 类方法的实现</h3><p>resolve 类方法本质就是new了一个 promise，然后直接调用resolve</p><p>reject同理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="number">123</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="all-方法的实现">all 方法的实现</h3><p>all方法接收一个promise数组，同样返回一个promise</p><p>关键思路：什么时候要执行resolve, 什么时候要执行reject</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> values = [] <span class="comment">// 定义结果数组</span></span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        values.<span class="title function_">push</span>(res)</span><br><span class="line"><span class="comment">// 当结果的个数等于传入promise个数的时候，表示已经执行完了，然后再回调resolve</span></span><br><span class="line">        <span class="keyword">if</span> (values.<span class="property">length</span> === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(values)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err) <span class="comment">// 失败直接执行回调reject</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">    <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [&#x27;111&#x27;, &#x27;222&#x27;, &#x27;333&#x27;]</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// 如果p2调用reject，就会执行这里，输出 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="allSettled-方法的实现">allSettled 方法的实现</h3><p>与all类型，区别就是无论成功与否都会把结果保存到数组</p><p>测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">    <span class="comment">// reject(&quot;222&quot;)</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c6ab0512854961862eb9db477b1e1e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="race-方法的实现">race 方法的实现</h3><p>只要状态改变就执行回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// promise.then(res =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//   resolve(res)</span></span><br><span class="line">      <span class="comment">// &#125;, err =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//   reject(err)</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">      <span class="comment">// 也可以这么写</span></span><br><span class="line">      promise.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="any-方法的实现">any 方法的实现</h3><p>等到第一个fulfilled状态，才执行resolve回调</p><p>如果全都是rejected状态，那么抛出异常</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> reasons = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res)</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reasons.<span class="title function_">push</span>(err)</span><br><span class="line">        <span class="comment">// 当全部promise执行完之后</span></span><br><span class="line">        <span class="keyword">if</span> (reasons.<span class="property">length</span> === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(reasons))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试全都是reject的情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">any</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err, err.<span class="property">errors</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c3b3d01b0fd4086a807b8896d97ac16~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>到此，手写promise就差不多大功告成啦！</p>]]></content>
    
    
    <summary type="html">一步步手写promise</summary>
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="promise" scheme="https://hillyee.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>promise详解</title>
    <link href="https://hillyee.github.io/2022/04/17/promise%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hillyee.github.io/2022/04/17/promise%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-17T15:22:28.000Z</published>
    <updated>2022-04-18T01:36:19.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise详解">Promise详解</h2><blockquote><p>ES6 新增 Promise</p></blockquote><h3 id="介绍">介绍</h3><p>Promise 是异步编程的一种解决方案：</p><p>从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</p><p>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p><p>1.为什么需要有Promise？</p><p>promise主要解决的问题：</p><ul><li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li><li>promise可以支持多个并发的请求，获取并发请求中的数据</li><li>这个promise可以解决异步的问题，本身不能说promise是异步的</li></ul><blockquote><p>补充一下，什么是回调函数？</p><p>就是我给你传一个函数，你反过来调用我</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78475af436354b338af3be4b9a9083da~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></blockquote><p>一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当参数a大于10且参数fn2是一个方法时 执行fn2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a, fn2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">10</span> &amp;&amp; <span class="keyword">typeof</span> fn2 == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">fn2</span>() <span class="comment">// 回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">11</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is a callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.Promise是什么？怎么使用？</p><ul><li><p>Promise 是一个类，字面意思：承诺、期约</p></li><li><p>通过 new 可以创建一个 Promise 对象，并且需要传入回调函数（executor）</p><p>这个回调函数会被<strong>立即执行</strong>，并且会传入另外两个回调函数 resolve、reject</p><p>当我们调用resolve回调函数时，会执行Promise对象的then方法传入的第一个回调函数，当调用reject的时候，会执行第二个回调</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success message&quot;</span>)</span><br><span class="line">  <span class="comment">// reject(&quot;failure&quot;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise的三种状态">Promise的三种状态</h3><p>Promise使用过程，我们可以将它划分成三个状态：</p><p><strong>pending</strong>：待定，初始状态，既没有被兑现，也没有被拒绝；当执行executor中的代码时，处于该状态；</p><p><strong>fulfilled</strong>：已兑现， 意味着操作成功完成；执行了resolve时，处于该状态； （也有的地方叫resolved状态）</p><p><strong>rejected</strong>：已拒绝，意味着操作失败； 执行了reject时，处于该状态；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// pending待定</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>() <span class="comment">// fulfilled(已完成)</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">reject</span>() <span class="comment">// rejected(已拒绝)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：Promise的状态一旦确定，就不可更改，只有两种状态改变：</p><p><code>pending</code> -&gt;<code> fulfilled</code>             <code>pending</code> -&gt;<code> rejected</code></p><blockquote><p>另外我们如果抛出异常，状态也是rejected，会回调then的第二个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;异常&quot;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// Error: 异常</span></span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure></blockquote><h3 id="resolve不同值的区别">resolve不同值的区别</h3><p><strong>resolve(参数)</strong>：resolve的参数，三种情况</p><ol><li><p>参数是普通值(数值/字符串/普通对象/undefined)，状态变化 pending -&gt; fulfilled</p></li><li><p>参数又是一个Promise对象，那么这个新Promise会决定原Promise的状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hahhaha&quot;</span>)</span><br><span class="line">  <span class="comment">// reject()</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(newPromise) <span class="comment">// 状态由newPromise决定</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// hahhaha</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>参数是一个对象，并且这个对象有实现then方法，那么会执行该then方法，并且根据 then方法的结果来决定Promise的状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;resolve message&quot;</span>)</span><br><span class="line">      <span class="comment">// reject()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(obj)</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Promise对象方法">Promise对象方法</h3><blockquote><p>then，catch，finally</p></blockquote><h4 id="then方法">then方法</h4><p><strong>1. 两个参数</strong></p><p>then方法是Promise对象上的方法，实际上是放在Promise的原型上的：Promise.prototype.then</p><p>then方法接收两个参数：</p><ul><li>fulfilled的回调函数：当状态变成fulfilled时会回调的函数</li><li>reject的回调函数：当状态变成reject时会回调的函数</li></ul><p><strong>2. 多次调用</strong></p><p>同一个Promise是可以被多次调用then方法的，当resolve方法被回调时，所有的then方法传入的回调函数都会被调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这不是链式调用</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res3); <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3. then的返回值</strong></p><p>then方法本身是有返回值的，它的返回值是Promise</p><ul><li>如果我们then的第一个回调返回的是一个普通值(数值/字符串/普通对象/undefined), 那么这个普通的值会被作为一个新的Promise的resolve值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newPromise = promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPromise); </span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c95c82ce3e094f79a428d32429a89591~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>所以我们可以进行<strong>链式调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span> </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bbb&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果返回的是一个Promise</li></ul><p>那么这个Promise会决定下一个then返回的promise的状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1111</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">    <span class="comment">// reject(&#x27;err&#x27;)</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 3秒后打印 1111</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果返回的是一个对象, 并且该对象实现了then方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">2222</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>其实一样的，既然then返回一个promise，那就跟前面一样的处理，也就是可以继续链式调用then去处理，自己多尝试各种情况看看就都可以理解了</p></blockquote><h4 id="catch方法">catch方法</h4><p>catch方法也是Promise对象上的一个方法：它也是放在Promise的原型上的 Promise.prototype.catch()</p><ul><li>catch方法传入错误（拒绝）捕获的回调函数</li><li>catch也可以多次调用</li><li>我们可以把catch方法理解为 then 方法的语法糖</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;reject message&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意下面两种情况，catch的处理</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;err message&quot;</span>) </span><br><span class="line">    <span class="comment">// 如果这里调用reject,也就是这个promise的状态是rejected</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;reject2 message&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// err message</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// 如果这里调用resolve,fulfilled状态</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;   <span class="comment">// 先调用 then 的第一个回调</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;reject2 message&quot;</span>)  </span><br><span class="line">      <span class="comment">// then返回的promise的状态是rejected</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// reject2 message   catch可以捕获到</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以说catch会处理首次出现拒绝状态的Promise</p><ul><li>catch方法也是会返回一个Promise对象的，所以catch方法后面我们可以继续调用then方法或者catch方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// &quot;111&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;222&quot;</span>  <span class="comment">// 这个catch返回的promise的状态为 fulfilled</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 222</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="finally方法">finally方法</h4><p>finally是在ES9（ES2018）中新增的一个特性：无论Promise对象变成fulfilled还是reject状态，最终都会被执行，所以finally也不需要接收参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); </span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally&quot;</span>); <span class="comment">// &quot;finally&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>finally 也会返回一个promise，但是一般我们不会继续再后面做处理了</p></blockquote><h3 id="Promise类方法">Promise类方法</h3><blockquote><p>也就是直接通过Promise调用的方法，不需要创建实例</p></blockquote><h4 id="Promise-resolve">Promise.resolve</h4><p>直接把某个内容转成Promise来使用</p><p>Promise.resolve的用法相当于new Promise，并且执行resolve操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>resolve的参数跟前面一样的三种，普通的值，Promise，有then方法的obj</p><h4 id="Promise-reject">Promise.reject</h4><p>会将Promise对象的状态设置为reject状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：Promise.reject无论传入的参数是什么形态，都是会直接作为reject状态的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err) <span class="comment">// err: Promise &#123;&lt;fulfilled&gt;: &#x27;123&#x27;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-all">Promise.all</h4><p>将多个Promise包裹在一起形成一个新的Promise，新的Promise状态由包裹的所有Promise共同决定：</p><ul><li><p>当所有的Promise状态变成 fulfilled 状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">333</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [ 111, 222, 333 ]</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-allSettled-2">Promise.allSettled</h4><p>ES11（ES2022）新增</p><p>该方法会在所有的Promise都有结果（无论是fulfilled还是reject）后才会有最终的状态，并且返回的Promise的状态一定是fulfilled</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">333</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res); <span class="comment">// 执行的是这里</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a3fc81e9e0645de87394ad13d3bc9cd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>打印的结果是一个数组，存放每一个Promise的结果</p><p>status：状态，value：值</p><h4 id="Promise-race">Promise.race</h4><blockquote><p>race：竞赛，这个方法可以理解为Promise的竞赛</p></blockquote><p>只要有一个Promise变成fulfilled状态, 那么就结束，并使用这个promise的结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)  <span class="comment">// 先执行完</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">333</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err); <span class="comment">// err: 222</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-any">Promise.any</h4><p>ES12新增，和race方法类似</p><p>any方法会等到第一个fulfilled状态，才会决定新Promise的状态</p><p>如果所有的Promise都是reject的，那么会报一个AggregateError的错误</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">111</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">222</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([p1, p2]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err); <span class="comment">// err: 222</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// err: AggregateError: All promises were rejected</span></span><br><span class="line"><span class="comment">// err.errors可以拿到全部错误信息</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于promise的方法</summary>
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="promise" scheme="https://hillyee.github.io/tags/promise/"/>
    
    <category term="js" scheme="https://hillyee.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>面试题—JS篇之代码输出结果是什么</title>
    <link href="https://hillyee.github.io/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://hillyee.github.io/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E7%AF%87%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2022-04-15T13:12:15.000Z</published>
    <updated>2022-04-24T13:05:28.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>包含类型判断、作用域、this指向、原型、事件循环等知识点</p></blockquote><h1>请问下面的代码输出结果是什么？</h1><h2 id="第1题">第1题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">b</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>答案：2  1</p></blockquote><h2 id="第2题">第2题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> (b = c, c = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><blockquote><p>报错：Cannot access ‘c’ before initialization</p></blockquote><h2 id="第3题">第3题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = b = <span class="number">10</span></span><br><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="keyword">let</span> a = b = <span class="number">20</span> </span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure><blockquote><p>答案：10、20</p></blockquote><h2 id="第4题">第4题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a.<span class="property">x</span> = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>)</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined、{n: 2}</p></blockquote><h2 id="第5题">第5题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x === <span class="literal">undefined</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><blockquote><p>答案：[ ]</p></blockquote><h2 id="第6题">第6题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World&#x27;</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Goodbye &#x27;</span> + name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>答案：Goodbye Jack</p></blockquote><h2 id="第7题">第7题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="title class_">NaN</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span> + <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="literal">undefined</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + &#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + [])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] + &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>答案：NaN、13、NaN、1、1[object Object]、1、[object Object]</p></blockquote><h2 id="第8题">第8题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,</span><br><span class="line">    b=&#123;<span class="attr">key</span>:<span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    c=&#123;<span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">a[b]=<span class="number">123</span></span><br><span class="line">a[c]=<span class="number">456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])</span><br></pre></td></tr></table></figure><blockquote><p>答案：456</p></blockquote><h2 id="第9题">第9题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> inner = &#123;</span><br><span class="line">  <span class="attr">out</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">out</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((inner.<span class="property">func</span>, inner.<span class="property">func</span>)())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inner.<span class="title function_">func</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((inner.<span class="property">func</span>)())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((inner.<span class="property">func</span> = inner.<span class="property">func</span>)())</span><br></pre></td></tr></table></figure><blockquote><p>答案：25、20、20、25</p></blockquote><h2 id="第10题">第10题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125; = &#123; <span class="attr">c</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br></pre></td></tr></table></figure><blockquote><p>答案：1、2、3</p></blockquote><h2 id="第11题">第11题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>[4, 5, 3]</p></blockquote><h2 id="第12题">第12题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span>(x++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: ++x</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: ++x</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: ++x</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>答案：4</p></blockquote><h2 id="第13题">第13题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span> == <span class="keyword">typeof</span> <span class="variable constant_">NULL</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; == <span class="keyword">typeof</span> <span class="keyword">class</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>答案：true、true</p></blockquote><h2 id="第14题">第14题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> count === <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="keyword">typeof</span> count === <span class="string">&quot;number&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>答案：true、false</p></blockquote><h2 id="第15题">第15题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>答案：2、2</p></blockquote><h2 id="第16题">第16题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：1</p></blockquote><h2 id="第17题">第17题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;bcd&#x27;</span></span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined</p></blockquote><h2 id="第18题">第18题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, obj1))</span><br></pre></td></tr></table></figure><blockquote><p>答案：{a: {b: 1}}</p></blockquote><h2 id="第19题">第19题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> getNum = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="title function_">getNum</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined、1、2</p></blockquote><h2 id="第20题">第20题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()()</span><br></pre></td></tr></table></figure><blockquote><p>答案：undefined</p></blockquote><h2 id="第21题">第21题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> ()&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [fn]</span><br><span class="line">arr[<span class="number">0</span>]()</span><br></pre></td></tr></table></figure><blockquote><p>答案：打印出arr数组本身</p></blockquote><h2 id="第22题">第22题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure><blockquote><p>答案：1、b函数本身、b函数本身</p></blockquote><h2 id="第23题">第23题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>()</span><br><span class="line"><span class="title function_">getName</span>()</span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>()</span><br><span class="line"><span class="title function_">getName</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：2、4、1、1、2、3、3</p></blockquote><h2 id="第24题">第24题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line"> <span class="attr">address</span>: &#123;</span><br><span class="line">  <span class="attr">country</span>:<span class="string">&quot;china&quot;</span>,</span><br><span class="line">  <span class="attr">city</span>:<span class="string">&quot;hangzhou&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`it&#x27;s <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, from <span class="subst">$&#123;<span class="variable language_">this</span>.address.country&#125;</span>`</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">setCountry</span>:<span class="keyword">function</span> (<span class="params">country</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">address</span>.<span class="property">country</span>=country</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;Matthew&quot;</span></span><br><span class="line">p1.<span class="title function_">setCountry</span>(<span class="string">&quot;American&quot;</span>)</span><br><span class="line"></span><br><span class="line">p2.<span class="property">name</span> = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">p2.<span class="title function_">setCountry</span>(<span class="string">&quot;England&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">say</span>()</span><br><span class="line">p2.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure><blockquote><p>答案：it’s Matthew, from England</p><p>it’s Bob, from England</p></blockquote><h2 id="第25题">第25题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>答案：2、3、5、4、1</p></blockquote><h2 id="第26题">第26题</h2><p>注：process是Node.js提供的一个对象，它代表当前Node.js进程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>答案：1、7、6、8、2、4、3、5、9、11、10、12</p></blockquote><blockquote><p>1-26 来源：<a href="https://mp.weixin.qq.com/s/fks9SuTSY0ivUfPn6G-TOw">https://mp.weixin.qq.com/s/fks9SuTSY0ivUfPn6G-TOw</a></p></blockquote>]]></content>
    
    
    <summary type="html">包含类型判断、作用域、this指向、原型、事件循环等知识点</summary>
    
    
    
    <category term="😣面试题-js篇" scheme="https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="js" scheme="https://hillyee.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>学习TypeScript</title>
    <link href="https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/"/>
    <id>https://hillyee.github.io/2022/04/15/%E5%AD%A6%E4%B9%A0TypeScript/</id>
    <published>2022-04-15T11:22:29.000Z</published>
    <updated>2022-04-18T01:36:32.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript初识">TypeScript初识</h2><blockquote><p>JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题</p></blockquote><h3 id="TS简介">TS简介</h3><p>Typescript是拥有类型的JavaScript超集</p><p>JavaScript所拥有的特性，TS全部都支持，并且在语言层面上添加了类型约束，还加上一些语法的扩展</p><h3 id="TS的编译环境">TS的编译环境</h3><p>TS最终还是会被编译成JS代码运行，所以我们需要搭建对应的环境</p><p>在电脑上安装Typescript，这样就可以通过TypeScript的Compiler将其编译成JavaScript</p><p>全局安装：<code>npm install typescript -g</code></p><p>查看版本：<code>tsc --version</code></p><h3 id="TS的运行环境">TS的运行环境</h3><p>运行的两个步骤：</p><ol><li><code>tsc xxx.ts</code> 把ts文件编译成JS代码</li><li>在浏览器或Node环境下运行JS代码</li></ol><p>如果每次都要做这两个步骤，那就太麻烦了</p><p>有什么简化的方式呢？</p><p>第一种：通过webpack，配置本地的TS编译环境和开启一个本地服务，可以直接运行在浏览器上</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f81ce51bbcd4d06b0e99f3148f0056f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" /><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d656d7ffb32e46f4b65292186998a1cf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>第二种：通过ts-node库，为TS的运行提供执行环境</p><ul><li><p>安装 ts-node：<code>npm install ts-node -g</code></p></li><li><p>另外 ts-node需要安装依赖 tslib 和 @types/node 两个包</p><p><code>npm install tslib @types/node -g</code></p></li><li><p>然后可以直接通过 ts-node 来运行 TS 的代码：</p><p><code>ts-node xxx.ts</code></p></li></ul><h2 id="变量的声明">变量的声明</h2><ul><li><p>定义的时候给标识符加类型：  var/let/const 标识符: 数据类型 = 赋值</p><p>但是 var 不推荐使用</p><p>另外注意 string 和 String 的区别</p><p>string是TypeScript中定义的字符串类型，String是ECMAScript中定义的一个包装类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: string = <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>类型推断（推导），就是说我们第一次给变量赋值的时候，会根据这个赋值的内容，自动推断变量的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span> <span class="comment">// 自动类型推断为number类型</span></span><br><span class="line">num = <span class="string">&quot;123&quot;</span>  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>推荐：如果可以自动推导出变量的类型的时候，不加类型</p><p>不确定类型的时候，要自己加上类型</p></blockquote><h2 id="数据类型">数据类型</h2><p>我们常说TS是JS的一个超集</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cbda679e37349e98f0c39d0213cfef9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="JS类型">JS类型</h3><blockquote><p>TS和JS都有的数据类型</p></blockquote><ol><li><strong>number类型</strong></li></ol><p>TS 和 JS一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: number = <span class="number">123</span></span><br><span class="line">num = <span class="number">222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// num = &quot;123&quot; // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TS 也支持进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num1</span>: number = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: number = <span class="number">0b100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num3</span>: number = <span class="number">0o100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num4</span>: number = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4); <span class="comment">// 100 4 64 256</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>boolean类型</strong></li></ol><p>true、false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: boolean = truelet <span class="attr">flag</span>: boolean = <span class="literal">true</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">flag = <span class="number">20</span> &gt; <span class="number">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>string类型</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;hello&quot;</span></span><br><span class="line">message = <span class="string">&#x27;hello ts&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样也支持ES6的模板字符串</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`hi <span class="subst">$&#123;message&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// hi hello ts</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Array类型</strong></li></ol><p>固定数组里面存放的数据类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">name1</span>: string[] = [] <span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// name1.push(1) // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name2</span>: <span class="title class_">Array</span>&lt;string&gt; = [] <span class="comment">// 不推荐(react jsx中是有冲突)   </span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Object类型</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>:object = &#123;  <span class="comment">// 在这里设置了object类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;kkk&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[<span class="string">&quot;age&quot;</span>]);</span><br></pre></td></tr></table></figure><p>设置了object类型不能获取数据也不能设置数据<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/688374ddd57d49b89dd0ebe6506e3ec1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></p><p>如果去掉了:object就可以获取，并且里面的属性类型也有推断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info[<span class="string">&quot;name&quot;</span>] = <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[<span class="string">&quot;age&quot;</span>]) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>Symbol类型</strong></li></ol><blockquote><p>跟 JS 一样，主要用于设置唯一属性名</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">title1</span>: symbol = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"><span class="comment">// title1 = 2 // number赋值给symbol类型,报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title2 = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>) <span class="comment">// 推断</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [title1]: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  [title2]: <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>Null 和 Undefined类型</strong></li></ol><p>null：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n1</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">n1 = <span class="number">123</span> <span class="comment">// number -&gt; null 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="literal">null</span>  <span class="comment">// 推断是 any类型</span></span><br><span class="line">n2 = <span class="number">123</span> <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>同理：undefined：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n3</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line">n3 = <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n4 = <span class="literal">undefined</span></span><br><span class="line">n4 = <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="TypeScript类型">TypeScript类型</h2><h3 id="any类型">any类型</h3><p>any表示任意类型</p><p>在不确定变量类型的时候，可以使用any类型，但是一旦使用了，意味着我们可以对any类型的变量进行任何的操作，包括赋值任何类型的值；获取不存在的属性、方法</p><p>非常不安全，不推荐使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: any = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">message = <span class="number">123</span></span><br><span class="line">message = <span class="literal">true</span></span><br><span class="line">message = &#123;&#125;</span><br><span class="line"></span><br><span class="line">message.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="unknown类型">unknown类型</h3><p>用于描述类型不确定的变量</p><p>unknown类型只能赋值给any和unknown类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: unknown  <span class="comment">// 如果使用any就不会报错了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  result = <span class="title function_">foo</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免拿到结果之后乱用</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = result </span><br><span class="line"><span class="comment">// 不能将类型“unknown”分配给类型“string”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h3 id="void类型">void类型</h3><p>void通常来指定一个函数没有返回值的，那么它的返回值就是void类型</p><p>另外，这个函数可以返回 null，undefined</p><blockquote><p>一般都不写的，因为没有返回值默认推断就是void</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);         <span class="comment">// 这里写不写void都一样的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="never类型">never类型</h3><p>表示永远不会发生值的类型</p><blockquote><p>never表示函数用于执行不到返回值那一步（抛出异常或死循环）的返回值类型</p><p>而void是函数没有返回值，可以返回null，undefined</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>() <span class="comment">// 抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>never 有什么应用场景？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function handleMessage(message: string | number ) &#123;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: string | number | boolean </span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> message) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;number方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;boolean方式处理message&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      <span class="comment">// 默认不会执行到返回值那一步,所以如果你没有对应的处理逻辑,就会报错</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">check</span>: never = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候有人想要传入 boolean类型</span></span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 但发现报错了, 然后就给函数参数加上boolean类型</span></span><br><span class="line"><span class="comment">// 然后就不报错了,但是函数里面并没有处理boolean参数的逻辑,他并不知道</span></span><br><span class="line"><span class="comment">// 如果, 加上default那一段,就会报错</span></span><br><span class="line"><span class="comment">// 这时候这个人就知道里面需要有boolean的处理逻辑,然后就去加上</span></span><br></pre></td></tr></table></figure><h3 id="tuple类型">tuple类型</h3><p>tuple 是<strong>元组</strong>类型，元组中每个元素都有自己特定的类型，根据索引值获取到的值可以确定对应的类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: [string, number, number] = [<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = info[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">length</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>而数组通常建议存放相同类型的值</p></blockquote><p>tuple应用场景</p><p>tuple通常可以作为返回的值，在使用的时候会非常的方便</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> useState&lt;T&gt;(<span class="attr">state</span>: T) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeState</span> = (<span class="params">newState: T</span>) =&gt; &#123;</span><br><span class="line">    currentState = newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">info</span>: [string, number] = [<span class="string">&#x27;xxx&#x27;</span>, <span class="number">18</span>]</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">tuple</span>: [T, <span class="function">(<span class="params">newState: T</span>) =&gt;</span> <span class="keyword">void</span>] = [currentState, changeState]</span><br><span class="line">  <span class="keyword">return</span> tuple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">setCounter</span>(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">const</span> [title, setTitle] = <span class="title function_">useState</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = <span class="title function_">useState</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="函数的参数和返回值类型">函数的参数和返回值类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般可以不写返回值的类型，会自动推断</span></span><br><span class="line"><span class="comment">// function sum(num1: number, num2: number): number &#123;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: number, num2: number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>, <span class="number">321</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>]</span><br><span class="line"><span class="comment">// 我们并没有指定item的类型</span></span><br><span class="line"><span class="comment">// 但是TypeScript会根据forEach函数的类型以及数组的类型推断出item的类型, 这个时候可以不添加的类型注解</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象类型">对象类型</h3><p>如果我们希望限定一个函数接收的参数是一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123;x: number, y: number&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(&#123;<span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">321</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="联合类型">联合类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: number | string</span>) &#123;</span><br><span class="line"><span class="comment">// id 可以是number 也可以是 string类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用联合类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: number | string</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用联合类型的值时，需要特别的小心</span></span><br><span class="line">  <span class="comment">// narrow：缩小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定id是string类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选类型">可选类型</h3><p>对象类型也可以指定哪些属性是可选的，可以在属性后面加一个?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123;x: number, y:number, z?:number&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个属性可传可不传</p><p>另外，可选类型可以看做是类型和undefined的联合类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message?: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 什么都不传实际上就是代表undefined</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><h3 id="类型别名">类型别名</h3><p>我们可以给对象类型起一个别名，方面我们后续使用</p><p>用到了关键字 <strong>type</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">IDType</span> = string | number</span><br><span class="line">type <span class="title class_">PointType</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">  z?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: PointType</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言-as">类型断言 as</h3><p>将类型转换为更具体的类型</p><p>本来不加类型断言的话，TS只会把el推断为HTMLElement类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;xxx&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br><span class="line">el.<span class="property">src</span> = <span class="string">&quot;url地址&quot;</span></span><br></pre></td></tr></table></figure><p>案例2：Person 是 Student 的父类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">p: Person</span>) &#123;</span><br><span class="line">  <span class="comment">// 不断言的话会报错：类型“Person”上不存在属性“studying”</span></span><br><span class="line">  (p <span class="keyword">as</span> <span class="title class_">Student</span>).<span class="title function_">studying</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非空类型断言">非空类型断言!</h3><p>! 用于确定某个标识符是有值的，跳过 ts 在编译阶段时对它的检测</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message 可以是string/undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message?: string</span>) &#123;</span><br><span class="line">  <span class="comment">// 当然可以直接if判断</span></span><br><span class="line">  <span class="comment">// if(message) &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是！更简洁</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message!.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链">可选链</h3><blockquote><p>实际上是 ES11 增加的特性</p></blockquote><p><code>?.</code> 操作符，作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  friend?: &#123;</span><br><span class="line">    f1?: &#123;</span><br><span class="line">      <span class="attr">name</span>: string</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(info.friend.f1); // friend不存在,取不到f1,报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">f1</span>); <span class="comment">// undefined, 不报错</span></span><br><span class="line"><span class="comment">// info.friend存在吗？存在再继续取f1</span></span><br></pre></td></tr></table></figure><h3 id="和-运算符">?? 和 !! 运算符</h3><blockquote><p>?? 是 ES11新增的特性</p></blockquote><p>**空值合并操作符 ?? **，是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> res = message ?? <span class="string">&quot;123&quot;</span>  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure><p><strong>!!操作符</strong>，将一个其他类型转换成boolean类型，类型Boolean(变量)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> flag1 = <span class="title class_">Boolean</span>(message)</span><br><span class="line"><span class="keyword">let</span> flag2 = !!message</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag1); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字面量类型">字面量类型</h3><p>字面量也可以当做类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">msg</span>:<span class="string">&quot;hello&quot;</span> = <span class="string">&quot;hello&quot;</span> <span class="comment">// 但是msg的值只能是&quot;hello&quot;</span></span><br><span class="line">msg = <span class="string">&quot;asd&quot;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>那有什么意义呢？可以将多个类型联合在一起</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Alignment</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;center&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAlign</span>(<span class="params">align: Alignment</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改方向:&#x27;</span>, align);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeAlign</span>(<span class="string">&quot;center&quot;</span>) <span class="comment">// 只能传入定义的三个字面量类型</span></span><br></pre></td></tr></table></figure><h3 id="字面量推理">字面量推理</h3><p>下面的代码，默认情况下info 进行类型推断的时候，method是string类型</p><p>加上as const 后，methods就是&quot;GET&quot;字面量类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;https://hillyee.github.io&quot;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">&#125;  <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// 加上as const 后，methods就是&quot;GET&quot;字面量类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: string, method: <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">request</span>(info.<span class="property">url</span>, info.<span class="property">method</span>) <span class="comment">// https://hillyee.github.io GET</span></span><br><span class="line"><span class="comment">// 默认：类型“string”的参数不能赋给类型“&quot;GET&quot; | &quot;POST&quot;”的参数。</span></span><br></pre></td></tr></table></figure><h3 id="类型缩小">类型缩小</h3><p>Type Narrowing 类型缩小</p><p>可以通过类似于 typeof padding === “number” 的判断语句，来改变TypeScript的执行路径</p><p>在给定的执行路径中，缩小比声明时更小的类型，这个过程称之为 缩小</p><p>而我们编写的<code>typeof padding === &quot;number</code> 可以称之为类型保护</p><p>常见的类型保护：</p><ul><li><p>typeof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">IDType</span> = number | string</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;</span><br><span class="line">  <span class="comment">// 这外面使用id是 IDtype 类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里面确认id是string类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 确认是number类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>平等缩小（=== == !== !=/switch）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;top&quot;</span> | <span class="string">&quot;bottom&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.if判断</span></span><br><span class="line">  <span class="comment">// if (direction === &#x27;left&#x27;) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(direction)</span></span><br><span class="line">  <span class="comment">// &#125; else if ()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.switch判断</span></span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//  case ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>instanceof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params">p: Student | Teacher</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p <span class="keyword">instanceof</span> <span class="title class_">Student</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>in</p><blockquote><p>属性是否存在某对象上</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">animal: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;swimming&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">running</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fish</span>:<span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">walk</span>(fish)</span><br></pre></td></tr></table></figure></li></ul><h2 id="TS函数类型">TS函数类型</h2><ol><li><p>定义常量时，编写函数的类型</p><p>(num1: number, num2: number) =&gt; number 就是一个函数类型，并接收两个参数num1，num2，并且都是number类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number</span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">a1: number, a2: number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数作为参数时，在参数中如何编写类型？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">FooFnType</span> = <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn: FooFnType</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(foo)</span><br></pre></td></tr></table></figure></li><li><p>参数的可选类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: number, y?: number</span>) &#123;&#125; <span class="comment">// y可选</span></span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: number, y: number = <span class="number">6</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩余参数</p><p>将一个不定数量的参数放到一个数组中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: number[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    total += num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="this类型">this类型</h2><p>当this不确定的时候，通常TS会要求我们明确的指定this的类型</p><p>如果不指定的话，非常不安全，因为有可能直接调用函数或者通过别的对象来调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type thisType = &#123; <span class="attr">name</span>: string &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"><span class="variable language_">this</span>: thisType, message: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">eating</span>: eating</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">info.<span class="title function_">eating</span>(<span class="string">&quot;asd&quot;</span>) <span class="comment">// this是info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定</span></span><br><span class="line">eating.<span class="title function_">call</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;kkk&quot;</span>&#125;, <span class="string">&quot;hehehe&quot;</span>)</span><br><span class="line"><span class="comment">// &#123; name: &#x27;kkk&#x27; &#125;</span></span><br><span class="line"><span class="comment">// kkk eating hehehe</span></span><br></pre></td></tr></table></figure><h2 id="函数的重载">函数的重载</h2><blockquote><p>函数的重载在实际开发也不是必须要用的，如果本来可以用联合类型简单实现的话，优先选择联合类型</p></blockquote><p>例如有一个需求，希望对字符串和数字类型进行相加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: number | string, a2: number | string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a1 + a2</span></span><br><span class="line">  <span class="comment">// TS 会把 string | number 当做是一个类型</span></span><br><span class="line">  <span class="comment">// 运算符“+”不能应用于类型“string | number”和“string | number”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>以上通过联合类型的方式实现有两个缺点：</p><ul><li>进行很多的逻辑判断（类型缩小）</li><li>返回值的类型依然不确定</li></ul><p><strong>函数的重载是什么？</strong></p><p>函数的名称相同，但是参数不同的几个函数就是函数的重载，并且是没有函数执行体的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构成函数重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: number, num2: number</span>):number</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: string, num2: string</span>):string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line"><span class="comment">// 如果有函数重载，执行体是不能直接被调用的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: any, num2: any</span>): any &#123;</span><br><span class="line">  <span class="comment">// 如果是 string 就返回长度相加</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> num2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1.<span class="property">length</span> + num2.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 先找到函数的声明 再找执行体</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">add</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add(&#123;name: &quot;xxx&quot;&#125;, &#123;age: 18&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>以上案例确实使用函数重载实现更方便，所以可以选择函数重载</p></blockquote><h2 id="TS类的使用">TS类的使用</h2><blockquote><p>这部分，实际开发中相对用的少一点，所以笔记暂时记的比较粗糙</p></blockquote><p><strong>类的定义</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的继承</strong>   extends super 关键字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number, sno: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的多态</strong></p><blockquote><p>不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现</p></blockquote><p><strong>类的成员修饰符</strong></p><ol><li><p>public</p><p>共有的，默认编写的属性就是public</p></li><li><p>private</p><p>仅在同一类中可见</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  private <span class="attr">_name</span>: string = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问器setter/getter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 setter/getter 是访问器属性，这样外界就可以存储</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">p.<span class="property">name</span> <span class="comment">// 会调用get访问器</span></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;kkk&quot;</span> <span class="comment">// set</span></span><br></pre></td></tr></table></figure></li><li><p>protected</p><p>仅在类自身<strong>及子类</strong>中可见、受保护的属性和方法</p></li></ol><p><strong>只读属性readonly</strong></p><p>只读属性是可以在构造器中赋值, 赋值之后就不可以修改</p><p>属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string</span><br><span class="line">  age?: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>静态成员</strong></p><p>通过关键字<strong>static</strong>来定义，直接通过类调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">time</span>: string = <span class="string">&quot;20:00&quot;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">attendClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;去上课&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property">time</span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">attendClass</span>()</span><br></pre></td></tr></table></figure><p><strong>抽象类abstract</strong></p><p>抽象类：</p><ul><li>以abstract 声明的类是抽象类</li><li>抽象类和其他类区别不大，但是不能被实例化（不能通过new调用）</li><li>抽象类就是专门用来被继承的类</li></ul><p>抽象方法：没有具体实现（没有方法体），抽象方法必须存在于抽象类中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shape.<span class="title function_">getArea</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  abstract <span class="title function_">getArea</span>(): number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  private <span class="attr">width</span>: number</span><br><span class="line">  private <span class="attr">height</span>: number</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: number, height: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写方法</span></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">20</span>, <span class="number">30</span>) </span><br><span class="line"><span class="title function_">makeArea</span>(rectangle)</span><br></pre></td></tr></table></figure><p><strong>类的类型</strong></p><p>类本身可以作为一个类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = &#123;  <span class="comment">// p1的类型是Person类，所以必须要传name</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS接口的使用">TS接口的使用</h2><p>除了可以通过type开声明一个对象类型，还可以通过接口来声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，接口中也可以定义可选属性，只读属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string</span><br><span class="line">  age?: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>索引类型</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IndexLanguage</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: number]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">frontLanguage</span>: <span class="title class_">IndexLanguage</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;HTML&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;CSS&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&quot;Vue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数类型</strong></p><p>用过接口interface来定义函数类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">CalcFunc</span> &#123;</span><br><span class="line">  (<span class="attr">num1</span>: number, <span class="attr">num2</span>: number):number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然还是推荐使用类型别名来定义函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1: number, num2: number</span>) =&gt;</span> number</span><br></pre></td></tr></table></figure><p><strong>接口继承</strong></p><p>接口和类一样可以进行继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IRunning</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IPerson</span> <span class="keyword">extends</span> <span class="title class_">ISwim</span>, <span class="title class_">IRunning</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">action</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的实现</strong></p><p><strong>implements</strong> 用于指定 class 满足某个接口，而且类可以实现多个接口</p><blockquote><p>不是很懂</p><p>面向接口开发</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> implements <span class="title class_">ISwim</span>, <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swim</span>(<span class="params">swimmer: ISwim</span>) &#123;</span><br><span class="line">  swimmer.<span class="title function_">swimming</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title function_">swim</span>(p)</span><br></pre></td></tr></table></figure><p><strong>交叉类型</strong></p><p>一种类型合并，表示需要满足多个类型的条件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">MyType</span> = number &amp; string</span><br></pre></td></tr></table></figure><p><strong>interface 和 type 区别</strong></p><p>interface可以重复对某个接口来定义属性和方法</p><p>而type定义的是别名，别名是不能重复的</p><p><strong>字面量赋值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="attr">height</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">person: IPerson</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printInfo(&#123;</span></span><br><span class="line"><span class="comment">//   name: &quot;xxx&quot;,</span></span><br><span class="line"><span class="comment">//   age: 18,</span></span><br><span class="line"><span class="comment">//   height: 1.88,</span></span><br><span class="line"><span class="comment">//   address: &quot;广州市&quot;  // 报错</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="comment">// 定义字面量</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printInfo</span>(info) <span class="comment">// 再赋值就不会报错</span></span><br></pre></td></tr></table></figure><p>这是因为TypeScript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。</p><p>但是之后如果我们是将一个 变量标识符赋值给其他的变量时，会进行freshness擦除操作</p><h2 id="TS枚举类型">TS枚举类型</h2><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型</p><p>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</p><p>定义枚举类型的关键字：<strong>enum</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">turnDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">LEFT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向左&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">RIGHT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向右&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">TOP</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向上&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">BOTTOM</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向下&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">foo</span>: never = direction;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS泛型">TS泛型</h2><blockquote><p>非常重要！</p></blockquote><h3 id="基本使用">基本使用</h3><p>简单来说就是，类型参数化</p><p>类型决定在调用函数的时候</p><p>基本使用：多加一个<code>&lt;Type&gt;</code>参数来接收类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> sum&lt;<span class="title class_">Type</span>&gt;(<span class="attr">num1</span>: <span class="title class_">Type</span>):<span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum&lt;number&gt;(<span class="number">10</span>)</span><br><span class="line">sum&lt;string&gt;(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">sum&lt;&#123;<span class="attr">name</span>: string&#125;&gt;(&#123;<span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>还有一种调用方式，类型推导</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sum</span>(<span class="number">50</span>) <span class="comment">// 那么类型Type就是字面量50</span></span><br></pre></td></tr></table></figure><p>另外，还可以传入多个类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> foo&lt;T, E, O&gt;(<span class="attr">arg1</span>: T, <span class="attr">arg2</span>: E, <span class="attr">arg3</span>: O, ...<span class="attr">args</span>: T[]) &#123;</span><br><span class="line"><span class="comment">// ...args: T[] 是剩余参数,放到一个数组，只能选择前面&lt;&gt;定义的类型,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo&lt;number, string, boolean&gt;(<span class="number">10</span>, <span class="string">&quot;aaa&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>开发时常用的名称：</p><p>T：Type的缩写，类型</p><p>K、V：key和value的缩写，键值对</p><p>E：Element的缩写，元素</p><p>O：Object的缩写，对象</p><h3 id="泛型接口">泛型接口</h3><p>定义接口中使用泛型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">IPerson</span>&lt;string&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类">泛型类</h3><p>定义类使用泛型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;<span class="variable constant_">T1</span>, <span class="variable constant_">T2</span>&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable constant_">T1</span></span><br><span class="line">  <span class="attr">age</span>: <span class="variable constant_">T2</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: T1, age: T2</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kkk&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己定义类型</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;string, number&gt;(<span class="string">&#x27;xxx&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>:<span class="title class_">Person</span>&lt;string, number&gt; = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><h3 id="泛型约束">泛型约束</h3><blockquote><p>给类型参数一点约束</p></blockquote><p>关键字 <strong>extends</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的参数必须有length属性</span></span><br><span class="line"><span class="title function_">getLength</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="title function_">getLength</span>([<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>])</span><br><span class="line"><span class="title function_">getLength</span>(&#123;<span class="attr">length</span>: <span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="TS其他内容">TS其他内容</h2><h3 id="模块化开发">模块化开发</h3><p>TS有两种方式控制作用域</p><h4 id="模块化">模块化</h4><p>支持ES Module，CommonJS</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ebf34f36dc4e0299f70e0bfb5cf699~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><h4 id="命名空间namespace">命名空间namespace</h4><p>是将一个模块内部再进行作用域的划分，防止一些命名 冲突的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了其他文件能使用，这里还要导出</span></span><br><span class="line"><span class="keyword">export</span> namespace time &#123;</span><br><span class="line">  <span class="comment">// 内部要export导出，才能在这个ts模块中使用</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">time: string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2022-4-13&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他的逻辑</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">name</span>: string = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> namespace price &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">price: number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;99.99&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TS早期的东西，个人还是选择模块化</p></blockquote><h3 id="类型的查找">类型的查找</h3><p>在之前，我们除了自己编写类型，还有用到一些其他的类型，比如说</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;image&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br></pre></td></tr></table></figure><p>HTMLImageElement 类型来自哪里呢？</p><p>首先我们需要知道一种ts文件：<code>.d.ts</code>为后缀名的文件</p><ul><li>这种文件是用来做类型的声明的（declare）。它仅仅用来做类型检测，告诉typescript我们有哪些类型</li><li>这种文件是不需要转成js文件来运行的</li></ul><p>那么typescript会在哪里查找我们的类型声明呢？</p><p>有三种：</p><ul><li><p>内置类型声明</p><p>typescript自带的，帮助我们内置了JS运行时的一些标准化API的声明文件</p><p>比如如Math、Date等内置类型，也包括DOM API，比如Window、Document等</p><p>内置类型声明通常在我们安装typescript环境中会带有</p><blockquote><p>github:<a href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></p></blockquote></li><li><p>外部定义类型声明</p><p>通常是我们使用一些库时，需要的一些类型声明</p><p>这些库有两种类型声明方式</p><ol><li>在自己库中进行类型声明（编写.d.ts文件），比如axios</li><li>通过社区的一个公有库DefinitelyTyped存放类型声明文件</li></ol><blockquote><p>github链接：</p><p>该库的GitHub地址：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></p><p>该库查找声明安装方式的地址：<a href="https://www.typescriptlang.org/dt/search?search=">https://www.typescriptlang.org/dt/search?search=</a></p><p>比如我们需要安装react的类型声明，就可以去查找安装方式</p></blockquote></li><li><p>自定义类型声明</p><p>比如我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p><p>这时候我们要自己声明类型文件：</p><p>任意一个项目文件夹下定义<code>.d.ts</code> 文件，ts会自己找到的</p><p>声明模块关键字：<strong>declare</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明模块</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: any[]</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>声明变量-函数-类</strong></p><p>在<code>.d.ts</code> 文件中声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="keyword">let</span> <span class="attr">myName</span>: string</span><br><span class="line">declare <span class="keyword">let</span> <span class="attr">myAge</span>: number</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是声明类型, 不需要执行体</span></span><br><span class="line">declare <span class="keyword">function</span> <span class="title function_">myFoo</span>(<span class="params"></span>): <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">declare <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他地方使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFoo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>声明模块</strong></p><p>声明模块的语法: declare module ‘模块名’ {}。</p><p>在声明模块的内部，可以通过export导出对应库的类、函数等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: any[]</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明文件</strong></p><blockquote><p>文件会被当成模块使用，然后就可以引入</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jepg&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span></span><br></pre></td></tr></table></figure><p>在别的地方<code>import</code>使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">&#x27;./img/xxx.jpg&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>声明命名空间</strong></p><p>比如在index.html中直接引入jQuery</p><p>然后在声明文件中（<code>.d.ts</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare namespace $ &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">settings: any</span>):any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在别的文件使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;...&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TypeScript初识&quot;&gt;TypeScript初识&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript没有类型检测，这会让我们的代码不安全，TS可以很好的解决这个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;TS简介&quot;&gt;TS简介&lt;/h3&gt;</summary>
      
    
    
    
    <category term="深入Vue3+Typescript学习⚡" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"/>
    
    
    <category term="TS" scheme="https://hillyee.github.io/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>面试题—JS手写篇</title>
    <link href="https://hillyee.github.io/2022/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E6%89%8B%E5%86%99%E7%AF%87/"/>
    <id>https://hillyee.github.io/2022/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94JS%E6%89%8B%E5%86%99%E7%AF%87/</id>
    <published>2022-04-14T02:11:41.000Z</published>
    <updated>2022-04-14T02:12:34.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现instanceof">实现instanceof</h3><blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><p>Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）</p><p>要懂原型和原型链</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">target, origin</span>) &#123;</span><br><span class="line">  <span class="comment">// 基本数据类型直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 拿到 target 的__proto__</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(target)</span><br><span class="line">  <span class="comment">// proto不为null就继续</span></span><br><span class="line">  <span class="keyword">while</span>(proto) &#123;</span><br><span class="line">    <span class="comment">// 找到相同的原型对象</span></span><br><span class="line">    <span class="keyword">if</span> (proto == origin.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 继续沿着原型链找</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(<span class="string">&quot;111&quot;</span>, <span class="title class_">String</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;111&quot;</span>), <span class="title class_">String</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">People</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="JS如何实现继承？">JS如何实现继承？</h3><h4 id="方式1：借助原型链">方式1：借助原型链</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;pName&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 获得Person类的属性方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们让Student的原型指向p</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>); <span class="comment">// pName</span></span><br><span class="line">stu.<span class="title function_">sayHello</span>() <span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 可见我们已经拿到了父类的属性和方法</span></span><br></pre></td></tr></table></figure><p>这种实现方法存在的问题：</p><p>1.当我们打印实例stu的时候，继承的属性不能直观看到，只能在<code>__proto__</code>属性中看到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu)<span class="comment">// Student &#123;height: 1.88&#125;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b22630e56f0f4495b46de38b9142b383~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" /><p>2.另外，如果我们创建两个实例对象，并改变friends属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>); <span class="comment">// [&#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure><p>明明改变的是stu1的属性，为什么stu2也变了？</p><p>因为我们它们的隐式原型指向的是同一个对象，p</p><p>3.前面实现的过程都没有传递参数</p><h4 id="方式2：借助构造函数">方式2：借助构造函数</h4><p>使用call调用构造函数，传入的this为当前实例，并且可以把参数传给父类处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age) <span class="comment">// 这里可以获得父类的属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 依然需要这里来获得方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="number">18</span>, <span class="number">1.78</span>)</span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;bbb&#x27;</span>, <span class="number">20</span>, <span class="number">1.88</span>)</span><br><span class="line"></span><br><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2);</span><br><span class="line">stu1.<span class="title function_">sayHello</span>() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>构造函数的方法可以解决原型链方式的问题，但是依然存在弊端</p><ol><li>Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person）</li><li>stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的）</li></ol><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d55255c9445464c9e38514c08dd0d4c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="方式3：寄生组合式继承-最终方案">方式3：寄生组合式继承(最终方案)</h4><blockquote><p>**<code>Object.create()</code>**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p><p>Object.create(XXX) 也就是传入的对象XXX，作为新对象的原型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, friends</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = friends</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, friends, height</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取父类中的属性和方法</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, friends)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再获取一份父类的prototype中的属性和方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="number">18</span>, [<span class="string">&#x27;fre1&#x27;</span>], <span class="number">1.88</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9029791227bd4b56903a268afb40c68d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>当然，我们也可以封装一个方法来继承父类prototype中的属性和方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">SubType, SuperType</span>) &#123;</span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当然子类的prototype还需要有constructor指向子构造函数本身</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">SubType</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure><h3 id="JS柯里化实现">JS柯里化实现</h3><blockquote><p>要求，传入一个函数，返回一个柯里化的函数</p><p>思路：当已经传入的参数 大于等于 所需要的参数时，就执行函数</p><p>没有达到个数时，需要返回一个新的函数，继续来收集参数，接收到参数后，递归调用curried来检查函数的个数是否达到</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurrying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 当已经传入的参数 大于等于 需要的参数时, 就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// fn()</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有达到个数时, 需要返回一个新的函数,继续来接收参数</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">curried2</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收到参数后, 需要递归调用curried来检查函数的个数是否达到</span></span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args, ...args2])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> curried2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个柯里化的函数</span></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryAdd = <span class="title function_">myCurrying</span>(add1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现instanceof&quot;&gt;实现instanceof&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;运算符&lt;/strong&gt;用于检测构造函数的 &lt;code&gt;prototy</summary>
      
    
    
    
    <category term="😣面试题-js篇" scheme="https://hillyee.github.io/categories/%F0%9F%98%A3%E9%9D%A2%E8%AF%95%E9%A2%98-js%E7%AF%87/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="js" scheme="https://hillyee.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Proxy-Reflect-响应式原理</title>
    <link href="https://hillyee.github.io/2022/04/11/Proxy-Reflect-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://hillyee.github.io/2022/04/11/Proxy-Reflect-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-11T09:03:22.000Z</published>
    <updated>2022-04-11T09:06:05.734Z</updated>
    
    <content type="html"><![CDATA[<h1>Proxy</h1><h2 id="监听对象的操作">监听对象的操作</h2><p>如果我们希望监听一个对象中的属性被设置或获取的过程</p><p>在之前，我们可以通过 <code>Object.defineProperty</code> 的存储属性描述符（get set）来监听到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[key]</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到obj对象的<span class="subst">$&#123;key&#125;</span>属性被访问了`</span>);</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到obj对象的<span class="subst">$&#123;key&#125;</span>属性被设置值`</span>);</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;asd&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>但是如果我们想要监听更加丰富的操作，比如说新增属性、删除属性，那么这个方法是无能为力的</p><p>而且我们要知道，这个方法的存储描述符设计的初衷也不是为了监听一个完整的对象的</p><h2 id="Proxy的基本使用">Proxy的基本使用</h2><blockquote><p>这也是我们监听对象操作的第二种方式</p></blockquote><p>在 ES6 中，新增了Proxy<strong>类</strong>，用于帮助我们创建一个代理</p><p>如果我们希望监听一个对象的相关操作，我们可以先根据这个对象创建一个代理对象（Proxy对象）。</p><p>然后对该对象的所有操作，我们都通过代理对象完成，因为这个代理对象可以帮我们监听我们对原对象进行的操作</p><p>怎么来使用这个Proxy代理呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 获取值时的捕获器</span></span><br><span class="line">  <span class="comment">// target:原对象, key:属性</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性被访问了`</span>, target);</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置值的捕获器</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性被设置值`</span>, target);</span><br><span class="line">    target[key] = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听in的捕获器</span></span><br><span class="line">  <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性in操作`</span>, target);</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听delete的捕获器</span></span><br><span class="line">  <span class="attr">deleteProperty</span>: <span class="keyword">function</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听到对象的<span class="subst">$&#123;key&#125;</span>属性delete操作`</span>, target);</span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// 监听到对象的name属性被访问了 &#123;name: &#x27;xxx&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 监听到对象的name属性被设置值 &#123;name: &#x27;xxx&#x27;, age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// kkk</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> objProxy); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> objProxy.<span class="property">name</span> </span><br></pre></td></tr></table></figure><blockquote><p>为什么我们对代理对象做出的改变，原对象也是会变的？</p><p>因为我们设置值的时候，就是直接对原对象设置的，target[key] = newValue</p></blockquote><h2 id="Proxy所有捕获器">Proxy所有捕获器</h2><p>有13个捕获器</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ced0dad1f1e422c8187a8e27703ebcb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddc940ec5cdc479b83241f9bf53894ae~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>Proxy 对函数的监听：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(foo, &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span>(<span class="params">target, thisArg, arrArray</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;对foo函数进行了apply调用&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">apply</span>(thisArg, arrArray)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, arrArray, newTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;对foo函数进行了new调用&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...arrArray)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fooProxy.<span class="title function_">apply</span>(&#123;&#125;, [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>])</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">fooProxy</span>(<span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;fff&quot;</span>)</span><br></pre></td></tr></table></figure><h1>Reflect</h1><h2 id="简单介绍">简单介绍</h2><ul><li><p><strong>Reflect是什么？</strong></p><p>ES6 新增的一个API，它是一个<strong>对象</strong>，字面意思是反射</p></li><li><p><strong>有什么用呢？</strong></p><p>主要是提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法</p><p>比如：Reflect.getPrototype(target) 类似于 Object.getPrototype(target)</p></li><li><p>那有Object可以做这些操作，为什么还要新增 Reflect 对象呢？</p><p>因为在早期的 ECMA 规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范，所以将这些API放在 Object 上</p><p>但是Object作为一个构造函数，这些操作放到它身上并不合适</p><p>另外还包含一些类似于 in、delete操作符，Reflect让原本的命令式变成函数式 .has ()等</p><p>所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上</p></li><li><p>Object和Reflect对象之间的API关系</p><blockquote><p>MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods</a></p></blockquote></li></ul><h2 id="Reflect常见方法">Reflect常见方法</h2><blockquote><p>跟Proxy一一对应的，也是13个</p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1901525696149e1981fe1941c906f4c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>Reflect 和 Proxy 一起使用</p><p>我们可以对前面Proxy案例中，对原对象的操作都修改为Reflect来操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get---------&quot;</span>)</span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">    <span class="comment">// 不直接修改原对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set---------&quot;</span>)</span><br><span class="line">    <span class="comment">// target[key] = newValue</span></span><br><span class="line">    <span class="comment">// 可以拿到设置成功与否的结果,一个布尔值</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后就可以根据结果做一些操作</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>); <span class="comment">// kkk</span></span><br></pre></td></tr></table></figure><h2 id="Receiver参数的作用">Receiver参数的作用</h2><p>访问器还有一个参数 receiver</p><p>作用：如果我们的源对象有setter，getter的访问器属性，那么可以通过receiver来改变里面的this</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>  <span class="comment">// 改变这里的this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// receiver是创建出来的代理对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(receiver === objProxy);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get方法被访问&#x27;</span>, key, receiver);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set成功&#x27;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>改变this，让它指向代理对象 又对代理对象有操作，所以捕获了两次</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9c67d9919194a99b3e95124be862853~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h2 id="Reflect中的construct">Reflect中的construct</h2><blockquote><p>很少很少用到叭，ryfES6文档：</p><p><strong>Reflect.construct(target, args)</strong></p><p>等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p></blockquote><p>应用场景，直接看例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行Student函数中的内容，但是创建出来的对象是Teacher对象</span></span><br><span class="line"><span class="keyword">const</span> teacher = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Student</span>, [<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>], <span class="title class_">Teacher</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(teacher);</span><br><span class="line"><span class="comment">// Teacher &#123;name: &#x27;xxx&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(teacher.<span class="property">__proto__</span> === <span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1>响应式原理</h1><h2 id="什么是响应式">什么是响应式</h2><p>先看一段代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">m = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>当 m 发生改变的时候，上面依赖m的一段代码自动重新执行</p><p>这种可以自动响应数据变量的代码机制，我们就称之为<strong>响应式</strong>的</p><h2 id="实现响应式">实现响应式</h2><h3 id="响应式函数设计与封装">响应式函数设计与封装</h3><p>首先，需要重新执行的代码可能有很多行，因此我们可以将这些代码放到一个函数中</p><p>当数据发生变化的时候，我们让这个函数执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖obj的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj变了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 当数据发生变化的时候,函数再次执行</span></span><br><span class="line"><span class="title function_">objFn</span>()</span><br></pre></td></tr></table></figure><p>这是我们简单的思想，如果我们有多个响应式函数需要再次执行呢？</p><p>那么我们可以封装一个函数，把这些响应式函数都收集起来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="comment">// 把响应式函数收集到数组中   // 改</span></span><br><span class="line"><span class="keyword">let</span> reactiveFns = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  reactiveFns.<span class="title function_">push</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们把需要响应式的函数传入watchFn</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;           <span class="comment">// 改</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj变了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 当数据发生变化的时候,执行收集的响应式函数</span></span><br><span class="line">reactiveFns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;   <span class="comment">// 改</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="响应式依赖的收集">响应式依赖的收集</h3><p>目前我们收集的依赖全都放到一个数组来保存，这存在很大的问题。</p><p>实际开发中我们需要监听很多对象的响应式，这些对象需要监听的属性也不止一个，它们都会有对应的响应式函数</p><p>所以我们要设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123; <span class="comment">// 改</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()  <span class="comment">// 改</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  depend.<span class="title function_">addDepend</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name变了&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 当数据发生变化的时候,执行收集的响应式函数</span></span><br><span class="line">depend.<span class="title function_">notify</span>()      <span class="comment">// 改</span></span><br></pre></td></tr></table></figure><h3 id="自动监听对象变化">自动监听对象变化</h3><p>现在我们有一个问题，数据发生改变的时候，我们是手动去调用notify()让依赖函数执行的</p><p>我们需要自动监听对象变化</p><blockquote><p>注意，我们创建了代理对象之后，对原对象的操作都通过代理对象完成了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  depend.<span class="title function_">addDepend</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  <span class="comment">// 改</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对代理对象操作</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span>   <span class="comment">// 改</span></span><br></pre></td></tr></table></figure><blockquote><p>Vue3 用的Proxy，Vue2用Object.defineProperty() 监听</p></blockquote><h3 id="依赖收集的管理">依赖收集的管理</h3><p>我们可以看出来，上面只创建了一个depend对象来管理obj.name变化需要监听的响应式函数</p><p>如果我们有多个对象，需要监听不同的属性，那么我们可以怎么样来管理不同对象的不同依赖关系呢？</p><p>依赖收集的数据结构，这里必须要理清楚这种结构的设计，我们用到了 Map，WeakMap</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8aee3bb829143a296f7142a54ffe103~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>伪代码：结构大概就是这样子</p><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name的所有depend&quot;</span>)</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;age的所有depend&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj2Map.<span class="title function_">set</span>(<span class="string">&quot;height&quot;</span>, <span class="string">&quot;height的所有depend&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">targetMap</span>(obj1, obj1Map)</span><br><span class="line"><span class="title function_">targetMap</span>(obj2, obj2Map)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当数据变化</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到obj1的name属性的所有依赖</span></span><br><span class="line"><span class="comment">// 根据对象拿对应的map,再根据属性拿依赖函数</span></span><br><span class="line"><span class="keyword">const</span> depend = targetMap.<span class="title function_">get</span>(obj).<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>具体代码实现：</p><p>先创建一个weakMap，并封装一个获取depend的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数      </span></span><br><span class="line"><span class="keyword">const</span> depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  depend.<span class="title function_">addDepend</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数       // 改</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象获取map</span></span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果没有获取到map,说明这个对象是第一次添加依赖</span></span><br><span class="line">  <span class="comment">// 我们要给这个对象新建一个map</span></span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  </span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获获取值的操作,获取依赖,然后执行</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)   <span class="comment">// 改</span></span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name变了&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对代理对象操作</span></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span>  </span><br></pre></td></tr></table></figure><p>现在我们执行会发现，根本没有实现响应式，为什么？</p><p>因为我们在watchFn添加依赖函数的时候，不管三七二十一，全都添加到一个depend里面了</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/799b1477919d4463ac9a400d2069f5c0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>所以当我们获取依赖的时候，根本无法根据对象，key来正确的获取对应key的依赖函数</p><ul><li><p>那么正确的依赖应该在哪里收集呢？</p><p>应该在我们调用Proxy的get捕获器的时候。当我们第一次获取属性值的时候，我们就应该对这个key收集它自己的依赖</p></li><li><p>另外，当我们在get里面添加依赖的时候出现一个问题，我们怎么拿到这个响应函数呢？</p><p>定义一个全局的变量 activeReactiveFn</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params">reactiveFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">push</span>(reactiveFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知执行依赖</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="keyword">let</span> activeReactiveFn = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;       <span class="comment">// 改！！</span></span><br><span class="line">  activeReactiveFn = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 用原数据先执行一次函数, 收集依赖</span></span><br><span class="line">  activeReactiveFn = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象获取map</span></span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果没有获取到map,说明这个对象是第一次添加依赖</span></span><br><span class="line">  <span class="comment">// 我们要给这个对象新建一个map</span></span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;    </span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据target,key获取对应的depend    // 改！</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)  </span><br><span class="line">    <span class="comment">// 给depend对象中添加响应式函数</span></span><br><span class="line">    depend.<span class="title function_">addDepend</span>(activeReactiveFn)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获获取值的操作,获取依赖,然后执行</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj的name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age&#x27;</span>, objProxy.<span class="property">age</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----------修改前---&#x27;</span>);</span><br><span class="line"></span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// objProxy.age = 20</span></span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8653f4e8dbab4f4da63aa84f402c1530~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><blockquote><p>一个注意的地方：在watchFn()函数里面，我们会先调用一次传入的函数，为什么呢？</p><p>因为这个函数如果有对某个属性有get的操作的话，我们就能捕获到，而我们在get里面进行收集依赖的操作，就可以收集到这个属性的依赖了</p></blockquote><h3 id="对-Depend-重构">对 Depend 重构</h3><p>现在依然存在问题：</p><ul><li><p>如果函数中用到了两次key，那么我们这个函数就会被收集两次，即重复收集了依赖，后面我们执行depend里面的函数的时候，就会重复执行这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name22&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----------修改前---&#x27;</span>);</span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da09599720c465c84d5d07174a4fcfd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li></ul><p>​解决方法：使用Set来保存依赖函数（Set元素不重复）</p><ul><li>还有一个可以优化的地方：我们并不希望将添加 activeReactiveFn 方法放在get里面，因为这是属于 Depend 类的行为</li></ul><p>修改后：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前需要收集的响应式函数</span></span><br><span class="line"><span class="keyword">let</span> activeReactiveFn = <span class="literal">null</span>   <span class="comment">// 改！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()   <span class="comment">// 改！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeReactiveFn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">add</span>(activeReactiveFn) <span class="comment">// 改！</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeReactiveFn = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 用原数据先执行一次函数, 收集依赖</span></span><br><span class="line">  activeReactiveFn = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的响应式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动监听对象的属性变化</span></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; </span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据target,key获取对应的depend</span></span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">    <span class="comment">// 给depend对象中添加响应式函数</span></span><br><span class="line">    depend.<span class="title function_">depend</span>()     <span class="comment">// 改！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">    depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name22&#x27;</span>, objProxy.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----------修改前---&#x27;</span>);</span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ebfc7d446f4a39a043c616e3785e3f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="对象的响应式操作">对象的响应式操作</h3><p>最后一个问题，前面我们都是对一个对象（obj）实现响应式，那么如果是多个对象呢？</p><p>所以我们要创建一个函数<code>reactive</code>，针对所有的对象都可以变成响应式对象</p><p>也就是实现多个对象的响应式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前需要收集的响应式函数</span></span><br><span class="line"><span class="keyword">let</span> activeReactiveFn = <span class="literal">null</span>   </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeReactiveFn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">add</span>(activeReactiveFn) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reactiveFns</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个响应式的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeReactiveFn = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 用原数据先执行一次函数, 收集依赖</span></span><br><span class="line">  activeReactiveFn = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个获取depend的函数</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepends</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>( target, map)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key获取依赖</span></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>()</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个对象，返回一个响应式对象  // 改！！！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  </span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据target,key获取对应的depend</span></span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">      <span class="comment">// 给depend对象中添加响应式函数</span></span><br><span class="line">      depend.<span class="title function_">depend</span>()     <span class="comment">// 改！</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(target, key)</span><br><span class="line">      depend.<span class="title function_">notify</span>() <span class="comment">// 在这里执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把需要响应式的对象传到reactive函数</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">reactive</span>(&#123;     <span class="comment">// 改！！</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = <span class="title function_">reactive</span>(&#123;    <span class="comment">// 改！！</span></span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;     </span><br><span class="line">  <span class="comment">// 注意这里 因为reactive返回的就是代理对象，我们用obj接收，obj就是响应式的了,所以直接对obj操作</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name22&#x27;</span>, obj.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;height&#x27;</span>, info.<span class="property">height</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------修改前---&#x27;</span>);</span><br><span class="line"></span><br><span class="line">info.<span class="property">height</span> = <span class="number">1.78</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kkk&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ce8b15ee6e64351b51a599174ab05ce~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>到此！我们的响应式就实现完成了</p><h3 id="Vue2响应式原理">Vue2响应式原理</h3><p>前面所实现的响应式的代码，其实是Vue3中的响应式原理</p><p>Vue3主要是通过Proxy来监听数据的变化以及收集相关 的依赖的</p><p>而Vue2是通过Object.defineProerty 的方式来实现对象属性的监听</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = obj[key]</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(obj, key)</span><br><span class="line">        depend.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> depend = <span class="title function_">getDepends</span>(obj, key) </span><br><span class="line">        value = newValue</span><br><span class="line">        depend.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在传入对象的时候，遍历所有的key，并且通过属性存储描述符来监听属性的获取和修改，</p><p>其他的逻辑和前面Vue3的响应式实现是一致的</p>]]></content>
    
    
    <summary type="html">包含ES6中Proxy,Reflect的知识 另外还有一步步实现Vue3，Vue2响应式原理</summary>
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="js" scheme="https://hillyee.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>10_ES6-ES12知识点</title>
    <link href="https://hillyee.github.io/2022/04/10/10_ES6-ES12%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://hillyee.github.io/2022/04/10/10_ES6-ES12%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-04-10T02:57:25.000Z</published>
    <updated>2022-04-21T11:55:45.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6">ES6</h2><h3 id="字面量的增强">字面量的增强</h3><p>属性（Property Shorthand）、方法（Method Shorthand）的简写，计算属性名（Computed Property Names）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;fks&#x27;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 1. 属性的简写</span></span><br><span class="line">  <span class="comment">// name: name</span></span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  <span class="comment">// 2. 方法的简写</span></span><br><span class="line">  <span class="comment">// foo: function() &#123;&#125;,</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;, <span class="comment">// obj.foo() this是obj</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 这是不一样的</span></span><br><span class="line">  <span class="comment">// foo: () =&gt; &#123;&#125; // this是全局</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.计算属性名</span></span><br><span class="line">  [name + <span class="number">123</span>]: <span class="string">&#x27;hahahah&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;fks&#x27;, age: 20, foo: [Function: foo], fks123: &#x27;hahahah&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="解构Destructuring">解构Destructuring</h3><ul><li>解构数组</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;asd&quot;</span>, <span class="string">&#x27;fgd&#x27;</span>, <span class="string">&#x27;dkb&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本来根据索引拿值</span></span><br><span class="line"><span class="comment">// var item1 = names[0]</span></span><br><span class="line"><span class="comment">// var item2 = names[1]</span></span><br><span class="line"><span class="comment">// var item3 = names[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">var</span> [item1, item2, item3] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item1, item2, item3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构后面的元素</span></span><br><span class="line"><span class="keyword">var</span> [ , , itemz] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构一个元素，后面的元素放到一个新数组</span></span><br><span class="line"><span class="keyword">var</span> [itemx, ...newNames] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemx, newNames) <span class="comment">// asd [ &#x27;fgd&#x27;, &#x27;dkb&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构的默认值</span></span><br><span class="line"><span class="keyword">var</span> [itema, itemb, itemc, itemd = <span class="string">&quot;ddd&quot;</span>] = names</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemd);</span><br></pre></td></tr></table></figure><ul><li><p>解构对象</p><p>根据key解构</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不规定顺序，只根据key来解构</span></span><br><span class="line"><span class="keyword">var</span> &#123;age, name&#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age, name); <span class="comment">// 20 asd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对key新命名</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: newName &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值,如果属性不存在,会使用默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">address</span>: newAddress = <span class="string">&#x27;广州&#x27;</span> &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newAddress); <span class="comment">// 广州</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数参数中解构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;name, age&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(obj) <span class="comment">// asd 20</span></span><br></pre></td></tr></table></figure><h3 id="let-const">let/const</h3><h4 id="let-const使用">let/const使用</h4><p>let 声明一个变量</p><p>const 声明一个常量、衡量（constant）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span> <span class="comment">//定义变量</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span> <span class="comment">// 常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意1：const 本质上是传递的值不可以修改，如果传递的是一个引用类型（内存地址），是可以通过引用找到对应的对象去修改内部的属性值的</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;bbb&#x27;</span> <span class="comment">//可以改</span></span><br><span class="line">obj = &#123;&#125; <span class="comment">// 不可以改 TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let / const 定义的变量名是不可以重复定义的</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo2&#x27;</span> <span class="comment">// Identifier &#x27;foo&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h4 id="let-const作用域提升">let/const作用域提升</h4><ul><li><p>使用let声明的变量，在声明之前访问会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 声明之前访问会报错</span></span><br><span class="line"><span class="comment">// 在这里bar已经被创建出来了</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span> <span class="comment">// Reference(引用)Error: Cannot access &#x27;bar&#x27; before initialization</span></span><br></pre></td></tr></table></figure></li><li><p>那么是不是意味着foo变量只有在代码执行阶段才会创建呢？</p><ul><li>事实上并不是，我们可以看一下ECMA262对 let 和 const 的描述</li></ul><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0603965a6f6f4d9fb8e842bcb0f1e7f4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><ul><li>这些变量会被创建在包含他们的词法环境被实例化的时候，但是是不可以访问它们的，直到词法绑定被求值</li></ul></li><li><p>那 let/const有没有作用域提升呢？</p><p>作用域提升：在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升</p><p>所以被创建出来了，但不能被访问，不能称之为作用域提升</p><p>总结：let、const没有进行作用域提升，但是会在解析阶段被创建出来、</p></li></ul><h4 id="let-const变量保存">let/const变量保存</h4><p>let / const 在全局声明变量保存在哪里了？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">foo</span>); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">bar</span>); <span class="comment">// undefined 所以不在window</span></span><br></pre></td></tr></table></figure><ul><li>let, const 是不会给window添加任何属性的</li><li>最新的ECMA标准中对执行上下文的描述</li></ul><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cef4d8ab524242eb92e470879b79e1cd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>也就是说我们声明的变量和环境记录是被添加到变量环境中的（在一个对象保存）</p><ul><li><p>但是标准没有规定这个对象是 window对象或者是其他对象</p></li><li><p>所以JS引擎在解析的时候，会有自己的实现</p></li><li><p>比如v8中其实是通过VariableMap的一个hashmap来实现它们的存储的</p></li><li><p>那么window对象呢？</p><p>window对象是早起的GO对象，在最新的实现中其实是浏览器添加的全局对象，并且 一直保持了window和var之间值的相等性</p></li></ul><h3 id="块级作用域">块级作用域</h3><h4 id="var-没有块级作用域">var 没有块级作用域</h4><ul><li><p>ES5中，JS只会形成两个作用域：<strong>全局作用域</strong>和<strong>函数作用域</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff3d4f044c04d0784db93893047e23d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li><li><p>var 没有块级作用域</p><p>ES5中放到一个代码中定义的变量，外面是可以访问的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="let-const-的块级作用域">let / const 的块级作用域</h4><p>ES6中新增了块级作用域，通过let、const、function、class 声明的标识符是具备块级作用域的限制的</p><p>注意函数，某些引擎会对函数的声明进行特殊处理，允许像var那样提升</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;demo function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(foo); // ReferenceError: foo is not defined\</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于函数,不同的浏览器有不同实现,(大部分浏览器为了兼容以前的代码.让function没有块级作用域) 所以这里可以访问demo</span></span><br><span class="line"><span class="comment">// demo() // demo function 可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// ReferenceError: Person is not defined</span></span><br></pre></td></tr></table></figure><ul><li>if/switch/for 语句的代码就是块级作用域</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if语句的代码就是块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">switch</span> (color) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>: </span><br><span class="line">    <span class="keyword">let</span> bar = <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环执行结束, 全局中 i 是 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 6 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用let</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束后, 全局中并不能访问j</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// j is not defined</span></span><br></pre></td></tr></table></figure><h4 id="块级作用域的应用场景">块级作用域的应用场景</h4><p>一个循环打印的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意setTimeout是宏任务,循环结束后才执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 打印 6 个 6,打印的是全局的 i</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种解决方法，立即执行函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="comment">// 打印的时候往上层作用域查找,找这里的i</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用let,一次循环一个块,互不影响</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// 0 1 2 3 4 5 </span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const注意的地方</strong></p><p>因为有 i++，第二次循环需要用到第一次循环的i去++，const定义的是常量，是不可以改变的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>但是ES6新增的 for…of可以</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> names) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都会有一个新的const item，在不同的块级作用域中</p><h4 id="暂时性死区">暂时性死区</h4><p>在一个代码中，使用let、const声明的变量，在声明之前都是不可以访问的</p><p>这种现象称之为暂时性死区</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 不可访问</span></span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><h3 id="关于字符串">关于字符串</h3><h4 id="模板字符串">模板字符串</h4><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;sfa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// my name is sfa, age is 18</span></span><br></pre></td></tr></table></figure><p>${}里面也可以是表达式，也可以是函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`age is <span class="subst">$&#123;age * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">`double age is <span class="subst">$&#123;doubleAge()&#125;</span>`</span></span><br></pre></td></tr></table></figure><h4 id="标签字符串">标签字符串</h4><blockquote><p>应该很少用到</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是模块字符串中的整个字符串，但是被切成多块放到一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m, n, x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n, x);</span><br><span class="line">  <span class="comment">// [ &#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;aaa&#x27; ] yuzi 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这样去调用一个函数</span></span><br><span class="line"><span class="comment">// foo``</span></span><br><span class="line"><span class="comment">// 当然也可以传参</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;yuzi&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line">foo<span class="string">`Hello<span class="subst">$&#123;name&#125;</span>World<span class="subst">$&#123;age&#125;</span>aaa`</span></span><br></pre></td></tr></table></figure><h3 id="关于函数">关于函数</h3><h4 id="函数的默认参数">函数的默认参数</h4><p>如果没有传参，就会用默认参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m = <span class="string">&#x27;aaa&#x27;</span>, n = <span class="string">&#x27;bbb&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数也可以是对象，并且可以对对象解构，有两种解构方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;name, age&#125; = &#123;name: <span class="string">&#x27;asd&#x27;</span>, age: <span class="number">18</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">&#123;name = <span class="string">&#x27;asd&#x27;</span>, age = <span class="number">18</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外注意：默认形参最好放到最后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">x, y, z = <span class="number">30</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 获取 函数的length值的时候，只获取默认形参之前的参数个数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="函数的剩余参数">函数的剩余参数</h4><p>剩余参数必须放到最后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, args); <span class="comment">// 1 2 [ 3, 4, 5, 6 ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="箭头函数的补充">箭头函数的补充</h4><p>没有自己的this，没有arguments</p><p>没有显式原型，所以不能作为构造函数，不能使用new创建对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">bar</span>() <span class="comment">// TypeError: bar is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="展开语法…">展开语法…</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> name2 = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 函数调用时使用</span></span><br><span class="line"><span class="title function_">foo</span>(...names) <span class="comment">// aaa bbb ccc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构造数组时</span></span><br><span class="line"><span class="keyword">const</span> newNames = [...names, ...name2]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames);</span><br><span class="line"><span class="comment">// [ &#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;k&#x27;, &#x27;k&#x27;, &#x27;k&#x27; ]</span></span><br><span class="line"><span class="comment">// 注意这里把字符串展开了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.构建对象字面量时 ES2018(ES9)</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;<span class="attr">name</span>: <span class="string">&#x27;ggg&#x27;</span>, <span class="attr">height</span>: <span class="number">1.88</span>&#125;</span><br><span class="line"><span class="comment">// 拷贝info的属性，并且可以添加新的属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;...info, <span class="attr">address</span>: <span class="string">&#x27;广州市&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// &#123; name: &#x27;ggg&#x27;, height: 1.88, address: &#x27;广州市&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>注意：展开运算符其实是一种浅拷贝</p><blockquote><p>简单来说就是，拷贝的地址，指向的是同一个对象</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;fff&#x27;</span>,</span><br><span class="line">  <span class="attr">hobby</span>: &#123;</span><br><span class="line">    <span class="attr">h1</span>: <span class="string">&#x27;study&#x27;</span>,</span><br><span class="line">    <span class="attr">h2</span>: <span class="string">&#x27;swim&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newInfo = &#123;...info&#125;</span><br><span class="line">newInfo.<span class="property">hobby</span>.<span class="property">h1</span> = <span class="string">&#x27;sss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">hobby</span>.<span class="property">h1</span>); <span class="comment">// sss 原来的info也改了</span></span><br></pre></td></tr></table></figure><h3 id="表示数值的方法-进制">表示数值的方法(进制)</h3><p>ob开头(binary)：二进制，0o开头(octonary)：八进制，0x开头(hexadecimal)：十六进制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">100</span> <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">0b100</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">const</span> num3 = <span class="number">0o100</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">const</span> num4 = <span class="number">0x100</span> <span class="comment">// 十六进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4); <span class="comment">// 100 4 64 256</span></span><br></pre></td></tr></table></figure><p>另外，大的数值有一个连接符，便于阅读(ES2021 ES12)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10_000_000_000_000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 10000000000000</span></span><br></pre></td></tr></table></figure><h3 id="Symbol的使用">Symbol的使用</h3><blockquote><p>主要是用来创建独一无二的key值，注意使用的时候不要用new</p></blockquote><p>创建Symbol</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>() <span class="comment">// s1,s2是不一样的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2019(ES10)中, Symbol还有一个描述(description)</span></span><br><span class="line"><span class="comment">// 便于标记是哪个symbol，就像是标签</span></span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3); <span class="comment">// Symbol(aaa)</span></span><br><span class="line"><span class="comment">// 可以拿到这个描述</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">description</span>); <span class="comment">// &#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure><p>在对象中作为key使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;yyy&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;mmm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[s1]); <span class="comment">// &#x27;yyy&#x27;</span></span><br><span class="line"><span class="comment">// 新增属性值</span></span><br><span class="line">obj[s3] = <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line"><span class="comment">// 也可以Object.defineProperty()方法添加属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, s4, &#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：获取属性值的时候不能通过 . 语法获取，因为 . 后面的是会被当做字符串</p><p>obj.s1，那么就会去找obj上key为’s1’这个属性值</p></blockquote><p>使用Symbol作为key的属性名，在遍历的时候是获取不到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果想要获取的话可以使用 Object.getOwnPropertySymbols()方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sKeys); <span class="comment">// [ Symbol(), Symbol(), Symbol(aaa) ]</span></span><br></pre></td></tr></table></figure><p>怎么让两个Symbol相等？</p><blockquote><p><code>Symbol.for(key)</code> 方法会根据给定的键 <code>key</code>，来从运行时的 symbol 注册表中找到对应的 symbol</p><p>注意这跟 Symbol(‘aaa’) 标签是不一样的哦</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也就是给symbol一个key</span></span><br><span class="line"><span class="keyword">const</span> sa = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> sb = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sa === sb); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据 symbol值获取key</p><blockquote><p><code>Symbol.keyFor(sym)</code> 方法用来获取全局symbol 注册表中与某个 symbol 关联的键</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sa)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure><h3 id="Set">Set</h3><blockquote><p>新增的一种数据结构（存储数据的方式）</p><p>是集合，里面的元素不重复</p></blockquote><ul><li>创建set和添加元素</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">10</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">20</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">30</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set(3) &#123; 10, 20, 30 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不重复</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set);<span class="comment">// Set(3) &#123; 10, 20, 30 &#125;</span></span><br></pre></td></tr></table></figure><p>注意添加对象时候的一种情况，因为添加的对象的地址是不一样的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">set.<span class="title function_">add</span>(&#123;&#125;)</span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// &#123; &#123;&#125;, &#123;&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下添加的才是同一个对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">set.<span class="title function_">add</span>(obj)</span><br><span class="line">set.<span class="title function_">add</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// &#123; &#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>最常见的应用：对数组去重</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去重(把数组放进集合)</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">const</span> arrSet = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet); <span class="comment">// Set(4) &#123; 10, 20, 30, 40 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>Set的属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">set.<span class="property">size</span> 返回元素个数</span><br></pre></td></tr></table></figure><ul><li>Set的方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">add</span>() 添加元素</span><br><span class="line"><span class="title function_">clear</span>() 清空集合元素</span><br><span class="line"><span class="title function_">delete</span>(x) 删除某元素</span><br><span class="line"><span class="title function_">has</span>(x) 是否包含x元素</span><br><span class="line"></span><br><span class="line">遍历：forEach</span><br><span class="line">arrSet.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arrSet) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WeakSet">WeakSet</h4><blockquote><p>用的很少，对于WeakSet的应用我就不纠结了</p></blockquote><p>WeakSet跟set的区别：WeakSet只能存放对象类型</p><p>WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收</p><p>另外，WeakSet不能遍历，因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素那么有可能造成对象不能正常销毁，所以存储到WeakSet中的对象是没办法获取的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"></span><br><span class="line">weakSet.<span class="title function_">add</span>(<span class="params">&#123;name: <span class="string">&#x27;asd&#x27;</span>&#125;, &#123;&#125;</span>)  &#123; 地址<span class="number">1</span>, 地址<span class="number">2</span> &#125;  弱引用</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet); <span class="comment">// WeakSet &#123; &lt;items unknown&gt; &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>我对弱引用的理解</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18a83978d3d642d1b3d403b13968fb58~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /></blockquote><blockquote><p>关于强引用弱引用的一篇文章：<a href="https://juejin.cn/post/6993101968545677319#heading-21">https://juejin.cn/post/6993101968545677319#heading-21</a></p></blockquote><h3 id="Map">Map</h3><blockquote><p>一种数据结构，键值对的形式，并且键可以是对象</p></blockquote><p>普通对象的键不能是对象？不能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [obj1]: <span class="string">&#x27;qqq&#x27;</span>,</span><br><span class="line">  [obj2]: <span class="string">&#x27;kkk&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info);</span><br><span class="line"><span class="comment">// &#123; &#x27;[object Object]&#x27;: &#x27;kkk&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 这下懂了吧，这个键会被转成字符串&#x27;[object Object]&#x27;,key重复了，值覆盖了</span></span><br></pre></td></tr></table></figure><p>怎么使用Map？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="comment">// 添加键值</span></span><br><span class="line">map.<span class="title function_">set</span>(obj1, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(obj2, <span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map);</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// Map(3) &#123;</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;aaa&#x27; &#125; =&gt; &#x27;aaa&#x27;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;bbb&#x27; &#125; =&gt; &#x27;bbb&#x27;,</span></span><br><span class="line"><span class="comment">//   1 =&gt; &#x27;ccc&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种添加,把键值对放到数组</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[obj1, <span class="string">&#x27;aaa&#x27;</span>], [obj2, <span class="string">&#x27;bbb&#x27;</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2);</span><br><span class="line"><span class="comment">// Map(2) &#123; &#123; name: &#x27;aaa&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;bbb&#x27; &#125; =&gt; &#x27;bbb&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>有什么属性和方法？</p><p>属性：size：返回map对象的成员数量</p><p>方法：</p><ul><li><p>set(key, value) ：添加，设置键值，返回整个Map对象</p></li><li><p>get(key)：根据key获取值</p></li><li><p>has(key)：是否存在某一个key，返回布尔值</p></li><li><p>delete(key)：删除一个键值对，返回布尔值</p></li><li><p>clear()：清空元素</p></li><li><p>遍历 forEach()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item, key);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for..of遍历注意</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// console.log(item); // 这里把一个键值对放到一个数组了</span></span><br><span class="line">  <span class="comment">// [ &#123; name: &#x27;bbb&#x27; &#125;, &#x27;bbb&#x27; ]</span></span><br><span class="line">  <span class="comment">// 所以可以根据索引值分别拿 key, value</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者进行解构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="WeakMap">WeakMap</h4><p>和Map有什么区别呢？</p><ul><li>WeakMap的key只能使用对象</li><li>WeakMap的key对对象的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收</li></ul><p>常见方法：</p><ul><li>set(key, value)：添加键值，返回整个对象</li><li>get(key)：根据key获取值</li><li>has(key)：是否包含某个key，返回布尔值</li><li>delete(key)：根据key删除键值对，返回布尔值</li></ul><p>WeakMap不能遍历</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakMap); <span class="comment">// WeakMap &#123; &lt;items unknown&gt; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>响应式原理中的WeakMap使用</strong></p><blockquote><p>可以看看Vue3的响应式原理，之前实现mini-vue的时候实现过响应式系统</p></blockquote><blockquote><p>简单的思想就是：</p><p>创建一个WeakMap, key是obj1，值是一个Map结构,</p><p>这个Map，键是对象的属性，值是有依赖这个属性的函数，</p><p>当这个属性发生什么改变的时候，就执行这个属性所有依赖的函数</p></blockquote><p>一个简单的响应式模拟实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用场景（vue3响应式原理）</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;qwe&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1NameFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1NameFn1被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1NameFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1NameFn2被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1AgeFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1AgeFn1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1AgeFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1AgeFn2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建WeakMap</span></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 2.收集依赖结构</span></span><br><span class="line"><span class="comment">// 2.1.对obj1收集的数据结构</span></span><br><span class="line"><span class="keyword">const</span> obj1Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, [obj1NameFn1, obj1NameFn2])</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, [obj1AgeFn1, obj1AgeFn2])</span><br><span class="line"></span><br><span class="line">weakMap.<span class="title function_">set</span>(obj1, obj1Map)</span><br><span class="line"><span class="comment">// 如果obj1.name发生改变</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;ggg&#x27;</span></span><br><span class="line"><span class="keyword">const</span> targetMap = weakMap.<span class="title function_">get</span>(obj1)</span><br><span class="line"><span class="keyword">const</span> fns = targetMap.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ES7">ES7</h2><h3 id="Array-Includes">Array Includes</h3><p>判断数组中是否包含某个元素</p><p>在之前我们经常使用 indexOf() 判断，该方法返回元素所在的索引值，没有就返回-1</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (names.<span class="title function_">indexOf</span>(<span class="string">&#x27;bbb&#x27;</span>) !== -<span class="number">1</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;包含bbb元素&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES7 新增 Includes 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (names.<span class="title function_">includes</span>(<span class="string">&#x27;bbb&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;包含bbb元素&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 NaN的处理，indexOf()不能判断，includes可以</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>, <span class="title class_">NaN</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names.<span class="title function_">includes</span>(<span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="指数的运算方法">指数的运算方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在之前,指数运算通过 Math.pow()</span></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, <span class="number">3</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// ES7新增：**</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="number">3</span> ** <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1, res2); <span class="comment">// 27 27</span></span><br></pre></td></tr></table></figure><h2 id="ES8">ES8</h2><h3 id="Object-values">Object.values</h3><p>之前我们可以通过 Object.keys()来获取一个对象的所有key，ES8提供Object.values() 获取所有值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)); <span class="comment">// [ &#x27;aaa&#x27;, 18 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用的非常少</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>([<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;asd&#x27;</span>)); <span class="comment">// [ &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries">Object.entries</h3><p>获取到一个数组，数组中存放可枚举属性的键值对数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;asdf&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objEntries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objEntries); <span class="comment">// [ [ &#x27;name&#x27;, &#x27;asdf&#x27; ], [ &#x27;age&#x27;, 20 ] ]</span></span><br><span class="line"><span class="comment">// 然后可以继续遍历这个数组，获得属性,值</span></span><br><span class="line">objEntries.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>([<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]));</span><br><span class="line"><span class="comment">// [ [ &#x27;0&#x27;, &#x27;aaa&#x27; ], [ &#x27;1&#x27;, &#x27;bbb&#x27; ], [ &#x27;2&#x27;, &#x27;ccc&#x27; ] ]  索引值当做key了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="string">&#x27;sdf&#x27;</span>)); <span class="comment">// [ [ &#x27;0&#x27;, &#x27;s&#x27; ], [ &#x27;1&#x27;, &#x27;d&#x27; ], [ &#x27;2&#x27;, &#x27;f&#x27; ] ]</span></span><br></pre></td></tr></table></figure><h3 id="padStart和padEnd">padStart和padEnd</h3><p>根据所给长度,和填充元素来往前或往后填充数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newMessage = message.<span class="title function_">padStart</span>(<span class="number">15</span>, <span class="string">&quot;*&quot;</span>).<span class="title function_">padEnd</span>(<span class="number">20</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage); <span class="comment">// ****hello world-----</span></span><br></pre></td></tr></table></figure><p>小案例：假设要对银行卡号用*隐藏</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="keyword">const</span> cardNumber = <span class="string">&quot;123456781231548564321&quot;</span></span><br><span class="line"><span class="keyword">const</span> lastFourCard = cardNumber.<span class="title function_">slice</span>(-<span class="number">4</span>) </span><br><span class="line"><span class="keyword">const</span> finalCard = lastFourCard.<span class="title function_">padStart</span>(cardNumber.<span class="property">length</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(finalCard); <span class="comment">// *****************4321</span></span><br></pre></td></tr></table></figure><blockquote><p>slice 可以传入负数的哦，-4，倒数4位</p></blockquote><h3 id="Trailing-Commas">Trailing-Commas</h3><p>ES8，允许在函数定义和调用时多加一个逗号</p><blockquote><p>没什么，反正我们平时也不会加。trailing：后面的，commas：逗号</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b,</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>,)</span><br></pre></td></tr></table></figure><h3 id="Object-Descriptors">Object Descriptors</h3><p>ES8中新增对对象的操作，<strong>Object.getOwnPropertyDescriptors()</strong></p><p>获取一个对象的所有<strong>自身属性</strong>的描述符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">age</span>: &#123; <span class="attr">value</span>: <span class="number">18</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,      </span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ES8 新增async await 的函数使用，后面另外记</p></blockquote><h2 id="ES9">ES9</h2><blockquote><p>Async iterators：迭代器，后续另外笔记</p><p>Object spread operators：对象展开运算符 <code>const newObj = &#123;...obj, age:18&#125;</code></p><p>Promise finally：后续Promise统一记</p></blockquote><h2 id="ES10">ES10</h2><h3 id="flat-flatMap">flat flatMap</h3><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flat</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>],[[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>]]]</span><br><span class="line"><span class="keyword">const</span> newNums = nums.<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// 默认深度为1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums); <span class="comment">// [ 10, 20, 30, 40, [ 1, 2 ], [ 3, 4 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newNums2 = nums.<span class="title function_">flat</span>(<span class="number">2</span>) <span class="comment">//</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums2); <span class="comment">// [10, 20, 30, 40,1,  2,  3,  4]</span></span><br></pre></td></tr></table></figure><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组</p><blockquote><p>先进行map，再flat，并且flat的<strong>深度为1</strong></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newNums2 = nums2.<span class="title function_">flatMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums2); <span class="comment">// [ 2, 4, 6, 8, 10 ]</span></span><br></pre></td></tr></table></figure><p>这样看起来跟map没什么区别呀？那flatMap有什么应用场景吗？</p><blockquote><p>处理这样的字符串数组，把字符串分成一个个放到数组</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = [<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;hello kk&quot;</span>, <span class="string">&quot;my name is xxx&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words = message.<span class="title function_">flatMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words);</span><br><span class="line"><span class="comment">// [&#x27;Hello&#x27;, &#x27;World&#x27;,&#x27;hello&#x27;, &#x27;kk&#x27;,&#x27;my&#x27;,&#x27;name&#x27;,&#x27;is&#x27;,&#x27;xxx&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries">Object fromEntries</h3><p>ES8有Object.entries将一个对象转换成entries</p><p>ES10有Object.fromEntries 将entries转换成对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;qws&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES8 entries</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries); <span class="comment">// [ [ &#x27;name&#x27;, &#x27;qws&#x27; ], [ &#x27;age&#x27;, 18 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">// &#123; name: &#x27;qws&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure><p>有什么应用场景吗？</p><p>可以处理query参数，最终转换成对象使用</p><blockquote><p>看到键值对的数组可以想到这个方法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="string">&#x27;name=xxx&amp;age=18&amp;height=1.88&#x27;</span></span><br><span class="line"><span class="keyword">const</span> queryParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(queryString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queryParams);</span><br><span class="line"><span class="comment">// URLSearchParams &#123; &#x27;name&#x27; =&gt; &#x27;xxx&#x27;, &#x27;age&#x27; =&gt; &#x27;18&#x27;, &#x27;height&#x27; =&gt; &#x27;1.88&#x27; &#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> param <span class="keyword">of</span> queryParams) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// [ &#x27;name&#x27;, &#x27;xxx&#x27; ]</span></span><br><span class="line"><span class="comment">// [ &#x27;age&#x27;, &#x27;18&#x27; ]</span></span><br><span class="line"><span class="comment">// [ &#x27;height&#x27;, &#x27;1.88&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就可以利用fromEntries转成对象</span></span><br><span class="line"><span class="keyword">const</span> paramObj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(queryParams)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(paramObj);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;xxx&#x27;, age: &#x27;18&#x27;, height: &#x27;1.88&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="trimStart-trimEnd">trimStart trimEnd</h3><p>单独去除前面或后面的空格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;  hello world   &#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>()); <span class="comment">// 去除前后的空格</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trimStart</span>()); <span class="comment">// 去除前面的空格</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trimEnd</span>()); <span class="comment">// 去除后面的空格</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-description">Symbol description</h3><blockquote><p>s1.description 这个属性可以获取symbol的描述（标签），前面symbol的笔记有写到</p></blockquote><h3 id="Optional-catch-binding">Optional catch binding</h3><blockquote><p>后续在try catch部分笔记</p></blockquote><h2 id="ES11">ES11</h2><h3 id="BigInt">BigInt</h3><p>ES11引入的新的数据类型，用于表示大的整数</p><p>使用：加个n，或者 BigInt(num)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES11前 最大的安全整数</span></span><br><span class="line"><span class="keyword">const</span> maxInt = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxInt); <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="comment">// 超过这个安全整数就可能出现表示错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxInt + <span class="number">1</span>); <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxInt + <span class="number">2</span>); <span class="comment">// 9007199254740992 (错了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES11之后: BigInt</span></span><br><span class="line"><span class="keyword">const</span> bigInt = <span class="number">900719925474099100n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigInt + <span class="number">10n</span>); <span class="comment">// 900719925474099110n</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(<span class="number">100</span>)); <span class="comment">// 100n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigInt + <span class="title class_">BigInt</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以把bigInt类型转Number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(bigInt)); <span class="comment">// 900719925474099100</span></span><br></pre></td></tr></table></figure><h3 id="Nullish-Coalescing-Operator">Nullish Coalescing Operator</h3><p>空值 合并 运算</p><p>新增的操作符：??</p><blockquote><p>处理如果为空，那么使用默认值的判断</p><p>之前的 || 不能很好的处理空字符串，空串转为false，执行后面的语句</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">const</span> res1 = foo || <span class="string">&#x27;default value&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res2 = foo ?? <span class="string">&#x27;default value&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// default value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Optional-Chaining">Optional Chaining</h3><p>可选链：让我们的代码在进行 null 和 undefined 判断时更加清晰和简洁</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="comment">// friend: &#123;</span></span><br><span class="line">  <span class="comment">//   f1: &#123;</span></span><br><span class="line">  <span class="comment">//     name: &#x27;mm&#x27;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在之前，如果获取不存在的属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>.<span class="property">friend</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 我们会做这样的判断</span></span><br><span class="line"><span class="keyword">if</span> (info &amp;&amp; info.<span class="property">friend</span> &amp;&amp; info.<span class="property">friend</span>.<span class="property">f1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>.<span class="property">f1</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES11的可选链</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">f1</span>?.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// info.friend存在吗?存在再继续 .f1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;其他代码逻辑&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Global-This">Global This</h3><p>在之前我们想获取JS环境的全局对象，不同环境获取的方式又不一样</p><p>比如在浏览器中，通过 this，window来获取</p><p>Node中，通过global获取</p><p>所以 ES11 中对获取全局对象进行统一的规范：globalThis</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器下</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node下</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES11 各种环境获取全局对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalThis);</span><br></pre></td></tr></table></figure><h3 id="for…in标准化">for…in标准化</h3><p>在ES11之前，虽然很多浏览器支持 for…in 来遍历对象，但是并没有被ECMA标准化</p><p>ES11中，对其进行标准化，for…in 用于遍历对象的 key</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name // age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dynamic-Import">Dynamic Import</h3><blockquote><p>后续在 ES Module 模块化中笔记</p></blockquote><h3 id="Promise-allSettled">Promise.allSettled</h3><blockquote><p>后续Promise中笔记</p></blockquote><h3 id="import-meta">import meta</h3><blockquote><p>后续在 ES Module 模块化中笔记</p></blockquote><h2 id="ES12">ES12</h2><h3 id="FinalizationRegistry">FinalizationRegistry</h3><p>FinalizationRegistry对象可以让你在对象被垃圾回收时请求一个回调</p><p>当一个在注册表中注册的对象被回收时，可以请求在某个时间点上调用一个清理回调（清理回调有时被称为 finalizer）</p><p>注册：register方法，注册任何想要清理后执行回调的对象，传入该对象，和所含的值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> finalRegistry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;注册在finalRegistry的对象,某个被销毁&quot;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> info = &#123; <span class="attr">age</span>: <span class="number">15</span> &#125;</span><br><span class="line"></span><br><span class="line">finalRegistry.<span class="title function_">register</span>(obj, <span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line">finalRegistry.<span class="title function_">register</span>(info, <span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">info = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 注册在finalRegistry的对象,某个被销毁 val</span></span><br><span class="line"><span class="comment">// 注册在finalRegistry的对象,某个被销毁 obj</span></span><br></pre></td></tr></table></figure><h3 id="WeakRefs">WeakRefs</h3><p>如果我们默认将一个对象赋值给另一个引用，那么这个引用是强引用</p><p>如果我们希望是弱引用，可以使用 WeakRef</p><blockquote><p>注意这里有一个 deref 方法获取弱引用的值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> finalRegistry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;注册在finalRegistry的对象,某个被销毁&quot;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;asd&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> info = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(obj)</span><br><span class="line"></span><br><span class="line">finalRegistry.<span class="title function_">register</span>(obj, <span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj = null</span></span><br><span class="line"><span class="comment">// 注册在finalRegistry的对象,某个被销毁 obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那还能获取info吗？</span></span><br><span class="line"><span class="comment">// 因为回收要时间，所以这里也做一个延迟才获取属性值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>); <span class="comment">// undefined(不能这样获取)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">deref</span>()?.<span class="property">name</span>);</span><br><span class="line">  <span class="comment">// 如果原对象obj没有被销毁, 可以使用deref()来获取</span></span><br><span class="line">  <span class="comment">// 如果被销毁了,获取到的是 undefined</span></span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h3 id="logical-assignment-operators">logical assignment operators</h3><blockquote><p>logical：逻辑的</p><p>几个逻辑赋值运算符 ||=，&amp;&amp;=（很少用），??=</p><p>可读性不是很好</p></blockquote><ul><li>||= 逻辑或赋值运算</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// message = message || &#x27;default value&#x27;</span></span><br><span class="line">message ||= <span class="string">&#x27;default value&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// default value</span></span><br><span class="line"><span class="comment">// 也是不能判断空串的</span></span><br></pre></td></tr></table></figure><ul><li>&amp;&amp;= 逻辑与赋值运算（很少用）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有值取值</span></span><br><span class="line">info = obj &amp;&amp; obj.<span class="property">name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">obj &amp;&amp;= obj.<span class="property">name</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// xxx</span></span><br></pre></td></tr></table></figure><ul><li>??= 逻辑空赋值运算  0 “”</li></ul><blockquote><p>感觉是可以填补 || 不能很好的判断&quot;&quot; 0</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="number">0</span></span><br><span class="line">message ??= <span class="string">&quot;default value&quot;</span></span><br><span class="line">msg ??= <span class="string">&quot;default val&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Numeric-Separator">Numeric Separator</h3><blockquote><p>Numeric 数值的  Separator 分离器</p></blockquote><p>大的数值有一个连接符 _ ，便于阅读</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10_000_000_000_000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 10000000000000</span></span><br></pre></td></tr></table></figure><h3 id="String-replaceAll">String.replaceAll</h3><blockquote><p>字符串替换，替换所有匹配条件的地方</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">// &#x27;aa..cc&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>之前replace只换第一处匹配的地方</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">// aa.bcc</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES6&quot;&gt;ES6&lt;/h2&gt;
&lt;h3 id=&quot;字面量的增强&quot;&gt;字面量的增强&lt;/h3&gt;
&lt;p&gt;属性（Property Shorthand）、方法（Method Shorthand）的简写，计算属性名（Computed Property Names）&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="ES6" scheme="https://hillyee.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>09_class定义类_ES6</title>
    <link href="https://hillyee.github.io/2022/04/08/09_class%E5%AE%9A%E4%B9%89%E7%B1%BB-ES6/"/>
    <id>https://hillyee.github.io/2022/04/08/09_class%E5%AE%9A%E4%B9%89%E7%B1%BB-ES6/</id>
    <published>2022-04-08T06:57:33.000Z</published>
    <updated>2022-04-08T09:45:23.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6中类的使用">ES6中类的使用</h2><h3 id="认识class定义类">认识class定义类</h3><p>按照构造函数的形式创建类，不仅仅和编写普通的函数过于相似，而且代码并不容易理解</p><ul><li>在ES6(ECMAScript2015)新的标准中使用了class关键字来直接定义类</li><li>但是类的本质上只是构造函数，原型链的语法糖</li><li>最终还是会被 babel 工具转换为ES5的代码</li></ul><h3 id="定义类的方式">定义类的方式</h3><p>可以发现类和构造函数的特性是一致的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的表达式(不怎么用)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的特性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>) <span class="comment">// [class Person]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// [class Person]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="类的构造方法">类的构造方法</h3><p>一个类只能有一个构造函数 constructor，如果包含多个会报错</p><p>new 的时候：</p><ol><li>在内存中创建一个对象 moni = { }</li><li>将类的原型prototype赋值给创建出来的对象的[[prototype]]，<code>moni.__ptoto__ = Person.prototype</code></li><li>将对象复制给函数的this：new绑定 this = moni</li><li>执行函数体中的代码</li><li>自动返回创建出来的对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kac&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;awe&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p2);</span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;kac&#x27;, age: 12 &#125; Person &#123; name: &#x27;awe&#x27;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="类中的方法定义">类中的方法定义</h3><p>三种定义方法</p><ol><li><p>普通的实例方法：实际上是放到原型上的，可以被多个实例共享</p></li><li><p>类的访问器方法：setter，getter</p></li><li><p>类的静态方法：直接使用类来调用的方法 <a href="http://Person.xxx">Person.xxx</a>()，不需要借助实例来调用，例如Promise.all()，也是类方法</p><p>使用 static关键字来定义</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_address</span> = <span class="string">&quot;广州市&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.普通的实例方法</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.类的访问器方法（不怎么用）</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">address</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拦截访问操作&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_address</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">address</span>(<span class="params">newAddress</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拦截设置操作&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_address</span> = newAddress</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.类的静态方法（类方法）：直接通过类来访问的方法</span></span><br><span class="line">  <span class="comment">// Person.xxx()</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">randomPerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> nameIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * names.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">var</span> name = names[nameIndex]</span><br><span class="line">    <span class="keyword">var</span> age = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;axf&quot;</span>, <span class="number">18</span>)</span><br><span class="line">p.<span class="title function_">eating</span>() <span class="comment">// axf eating~</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">address</span>);</span><br><span class="line">p.<span class="property">address</span> = <span class="string">&quot;北京市&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">address</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">randomPerson</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的继承extends">类的继承extends</h3><p>ES6中新增了 <strong>extends</strong> 关键字，可以方便的帮助我们实现继承</p><p><strong>super</strong>关键字，三个使用位置：子类的构造函数、实例方法、静态方法</p><ul><li><p>子类的构造函数：JS引擎在解析子类的时候就有要求，如果我们有实现继承，那么子类的构造方法中,在使用this之前,要调用super()</p><p>否则报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReferenceError</span>: <span class="title class_">Must</span> call <span class="variable language_">super</span> constructor <span class="keyword">in</span> derived <span class="keyword">class</span> <span class="title class_">before</span> accessing <span class="string">&#x27;this&#x27;</span> or returning <span class="keyword">from</span> derived constructor</span><br></pre></td></tr></table></figure></li><li><p>子类可以<strong>重写父类的方法</strong>，在重写方法中使用 super 来复用父类中的逻辑</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑1&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑2&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑3&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; running~&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person staticMethod&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, sno</span>) &#123;</span><br><span class="line">    <span class="comment">// 在使用this前，这里必须使用super()</span></span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写方法一般实例方法</span></span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 复用父类中的逻辑</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">running</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑4&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑5&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;逻辑6&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;student &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写父类中的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">staticMethod</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;student staticMethod&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;asx&quot;</span>, <span class="number">12</span>, <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"><span class="comment">// p.running()</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">staticMethod</span>()</span><br></pre></td></tr></table></figure><h3 id="继承内置类">继承内置类</h3><p>让我们的类继承内置类，比如：Array</p><p>这样我们就可以得到Array的方法了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span>&#123;</span><br><span class="line">  <span class="title function_">firstItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">lastItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">firstItem</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>([<span class="number">33</span>])) <span class="comment">// MyArray(4) [ 1, 2, 3, 33 ]</span></span><br></pre></td></tr></table></figure><h3 id="类的混入-少用">类的混入(少用)</h3><p>JavaScript 的类只支持单继承，也就是只能有一个父类</p><p>如果想在一个类中添加更多相似的功能时，可以使用混入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数去继承一些公共方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixinRunner</span>(<span class="params">BaseClass</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">NewClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am running~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewClass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixinEater</span>(<span class="params">BaseClass</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">NewClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am eating~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewClass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var NewStudent = mixinRunner(Student) // 返回一个已经继承了run方法的新的类</span></span><br><span class="line"><span class="comment">// 在继承了run的基础上继续继承eat</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NewStudent</span> = <span class="title function_">mixinEater</span>(<span class="title function_">mixinRunner</span>(<span class="title class_">Student</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">NewStudent</span>()</span><br><span class="line">stu.<span class="title function_">running</span>()</span><br><span class="line">stu.<span class="title function_">eating</span>() </span><br></pre></td></tr></table></figure><h3 id="JavaScript中的多态">JavaScript中的多态</h3><blockquote><p>维基百科：多态（英语：polymorphism）指为不同数据类型的实体提供统一的接口，或使用一 个单一的符号来表示多个不同的类型</p><p>总结：不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现</p><p>所以说，JS也是有多态的，虽然跟别的一些面向对象语言有些区别</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calcArea</span>(<span class="params">foo</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">getArea</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;sfr&quot;</span>,</span><br><span class="line">  <span class="attr">getArea</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">calcArea</span>(obj1)</span><br><span class="line"><span class="title function_">calcArea</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下也是多态的体现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>) <span class="comment">// 不同数据类型，不同形态</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;asf&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="ES6转ES5">ES6转ES5</h3><blockquote><p>可以在 <a href="http://babeljs.io">babeljs.io</a> 中看es6通过babel转es5后的代码</p><p>有点难度，不要浮躁，慢慢看</p><p>可以打 debug 一点点看</p></blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel转换</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_classCallCheck</span>(<span class="params">instance, Constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> <span class="title class_">Constructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target: Person.prototype</span></span><br><span class="line"><span class="comment">// props: [&#123;key, value&#125;]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_defineProperties</span>(<span class="params">target, props</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">    descriptor.<span class="property">enumerable</span> = descriptor.<span class="property">enumerable</span> || <span class="literal">false</span>;</span><br><span class="line">    descriptor.<span class="property">configurable</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> descriptor) descriptor.<span class="property">writable</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, descriptor.<span class="property">key</span>, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor: Person</span></span><br><span class="line"><span class="comment">// protoProps: [&#123;key, value&#125;]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (protoProps) </span><br><span class="line">    <span class="title function_">_defineProperties</span>(<span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>, protoProps);</span><br><span class="line">  <span class="keyword">if</span> (staticProps) </span><br><span class="line">    <span class="title function_">_defineProperties</span>(<span class="title class_">Constructor</span>, staticProps);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Constructor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /*#__PURE__*/ 纯函数</span></span><br><span class="line"><span class="comment">// webpack 压缩 tree-shaking</span></span><br><span class="line"><span class="comment">// 这个函数没副作用</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = <span class="comment">/*#__PURE__*/</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_createClass</span>(<span class="title class_">Person</span>, [&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;eating&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Person</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES6中类的使用&quot;&gt;ES6中类的使用&lt;/h2&gt;
&lt;h3 id=&quot;认识class定义类&quot;&gt;认识class定义类&lt;/h3&gt;
&lt;p&gt;按照构造函数的形式创建类，不仅仅和编写普通的函数过于相似，而且代码并不容易理解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在ES6(ECMAScript2</summary>
      
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="ES6" scheme="https://hillyee.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>学习Vuex</title>
    <link href="https://hillyee.github.io/2022/04/07/%E5%AD%A6%E4%B9%A0Vuex/"/>
    <id>https://hillyee.github.io/2022/04/07/%E5%AD%A6%E4%B9%A0Vuex/</id>
    <published>2022-04-07T03:27:35.000Z</published>
    <updated>2022-04-07T04:34:55.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex的状态管理">Vuex的状态管理</h2><h3 id="vuex介绍">vuex介绍</h3><ul><li><p>什么是状态管理？</p><p>应用程序的各种数据保存到某个位置进行管理</p></li></ul><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a797ec53c22b488b8b169c6c80daab85~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>​ state：数据view：最终模块渲染成DOMactions：修改state的行为事件</p><ul><li><p>复杂的状态管理</p><p>多个组件共享状态</p></li><li><p>Vuex的状态管理</p><p>将组件的内部状态抽离出来</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a54e89c5272448eb9c1850ee729526cb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /></li><li><p>Vuex使用单一状态树</p><p>SSOT：Single Source of Truth，单一数据源</p><p>每个应用仅仅包含一个store实例</p></li></ul><h4 id="安装">安装</h4><p><code>npm install vuex@next</code></p><p>使用vuex4.x，需要添加next指定版本</p><h4 id="使用">使用</h4><h4 id="创建store（仓库）">创建store（仓库）</h4><ul><li><p>Vuex和单纯的全局对象有什么区别呢？</p><p>Vuex的状态存储是响应式的</p></li><li><p>不能直接改变store中的状态</p><p>改变store中的状态的唯一途径就是<strong>提交(commit) mutation</strong></p><p>这样方便我们跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态</p></li><li><p>具体步骤：</p><ol><li>store/index</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的store实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span> <span class="comment">// 数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; <span class="comment">// 方法</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">       state.<span class="property">counter</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">       state.<span class="property">counter</span>--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><ol start="2"><li>在全局将 store 实例作为插件安装</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(store).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件中使用store">组件中使用store</h3><h3 id="state">state</h3><p>使用store中的state数据</p><ul><li><p>在模板中使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在options api 中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">counter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在setup中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">const</span> counter = store.<span class="property">state</span>.<span class="property">counter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="mapState">mapState</h4><p>如果需要拿state中的多个数据，在可以借助辅助函数 mapState，</p><ul><li><p>setup中使用mapState</p><p>默认情况下，Vuex没有提供非常方便的的使用mapState的方式，所以我们进行了一个函数的封装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;sCounter&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;Home: &#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState, useStore &#125; from &quot;vuex&quot;</span><br><span class="line">import &#123; computed &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  // options api使用mapState</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // fullName: function() &#123; return xxx&#125;, </span><br><span class="line">    ...mapState([&quot;counter&quot;, &quot;name&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const store = useStore()</span><br><span class="line">    const sCounter = computed(() =&gt; store.state.counter)</span><br><span class="line"></span><br><span class="line">    // 实际上放入mapState这里拿到的是这样形式的一个个函数</span><br><span class="line">    // &#123;counter: function(), name: function() ...&#125;</span><br><span class="line">    const storeStateFns = mapState([&quot;counter&quot;, &quot;name&quot;, &quot;age&quot;, &quot;height&quot;])</span><br><span class="line">    </span><br><span class="line">    // 封装一个函数转化一下,主要思想是把这一个个的函数放到computed里面</span><br><span class="line">    // 因为computed就是传入一个函数，然后会给我们返回一个ref</span><br><span class="line">    // &#123;counter: ref, age: ref, ...&#125;</span><br><span class="line">    const storeState = &#123;&#125;</span><br><span class="line">    Object.keys(storeStateFns).forEach(fnKey =&gt; &#123;</span><br><span class="line">      // 因为内部的computed取数据的时候是通过this.$store...</span><br><span class="line">      // 但我们这里的fn没有this, undefined.$store 是错的</span><br><span class="line">      // 用bind给每个函数绑定this为一个对象,里面需要有$store这个属性</span><br><span class="line">      // &#123;$store: store&#125;</span><br><span class="line">      const fn = storeStateFns[fnKey].bind(&#123; $store: store&#125;)</span><br><span class="line">      // 然后把函数一个方法computed, 以键值对的方式存储起来</span><br><span class="line">      storeState[fnKey] = computed(fn)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    return &#123;</span><br><span class="line">      sCounter,</span><br><span class="line">      // 最终在这里用展开运算符展开</span><br><span class="line">      ...storeState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>把函数的封装抽离到 hooks/useState.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取到对应的对象的functions: &#123;name: function, age: function&#125;</span></span><br><span class="line">  <span class="keyword">const</span> storeStateFns = <span class="title function_">mapState</span>(mapper)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数据进行转换</span></span><br><span class="line">  <span class="keyword">const</span> storeState = &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(storeStateFns).<span class="title function_">forEach</span>(<span class="function"><span class="params">fnKey</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = storeStateFns[fnKey].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;)</span><br><span class="line">    storeState[fnKey] = <span class="title function_">computed</span>(fn)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> storeState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在组件使用就会简便很多</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;../hooks/useState&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> storeState = <span class="title function_">useState</span>([<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;height&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当然也可以是对象形式(想要重命名的时候使用)</span></span><br><span class="line">    <span class="keyword">const</span> storeState2 = <span class="title function_">useState</span>(&#123;</span><br><span class="line">      <span class="attr">sCounter</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">counter</span>,</span><br><span class="line">      <span class="attr">sName</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">name</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...storeState,</span><br><span class="line">      ...storeState2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters">getters</h3><ul><li><p>getters 的基本使用</p><p>某些属性可能需要经过变化后才使用，（就像store中的计算属性）</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5234df35d8b42a3a105bf9573c66885~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:70%;" /></li><li><p>getters 第二个参数</p><p>getters可以接收第2个参数getters，使用getters本身的属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="title function_">totalPrice</span>(<span class="params">state, getters</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">books</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pre + cur.<span class="property">count</span> * cur.<span class="property">price</span></span><br><span class="line">    &#125;, <span class="number">0</span>) + <span class="string">&quot; &quot;</span> + getters.<span class="property">myName</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">myName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getters 的返回函数</p><p>getters中的函数本身，可以返回一个函数，那么在使用的地方相当于可以调用这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">totalPrice</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> totalPrice = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> book <span class="keyword">of</span> state.<span class="property">books</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (book.<span class="property">price</span> &lt; price) <span class="keyword">continue</span></span><br><span class="line">            totalPrice += book.<span class="property">count</span> * book.<span class="property">price</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalPrice</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="mapGetters">mapGetters</h4><p>与mapState类似</p><ul><li><p>在setup中使用mapGetters</p><p>封装好的 /useGetters</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore, mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useGetters</span>(<span class="params">mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stateFns = <span class="title function_">mapGetters</span>(mapper)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(stateFns).<span class="title function_">forEach</span>(<span class="function"><span class="params">fnKey</span> =&gt;</span> &#123;</span><br><span class="line">    state[fnKey] = <span class="title function_">computed</span>(stateFns[fnKey].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> storeGetters = <span class="title function_">useGetters</span>([<span class="string">&quot;nameInfo&quot;</span>, <span class="string">&quot;ageInfo&quot;</span>, <span class="string">&quot;heightInfo&quot;</span>])</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...storeGetters</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="封装useMapper">封装useMapper</h3><p>我们发现前面 useState，useGetters的逻辑大部分相同，所以我们可以封装一个新的函数，根据使用的时候的 mapState还是mapGetters 来调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mapFn:使用的mapXXX</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMapper</span>(<span class="params">mapper, mapFn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> storeStateFns = <span class="title function_">mapFn</span>(mapper)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> storeState = &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(storeStateFns).<span class="title function_">forEach</span>(<span class="function"><span class="params">fnKey</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = storeStateFns[fnKey].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;)</span><br><span class="line">    storeState[fnKey] = <span class="title function_">computed</span>(fn)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> storeState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f546da191e74eb8928f81fab5c259b7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><h3 id="Mutations">Mutations</h3><p>更改 Vuex 的store中的状态的唯一方法是提交mutation</p><ul><li><p>mutations 基本使用</p><p>在store中定义方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">counter</span>++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">counter</span>--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setup中commit事件，提交的是mutations中的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    store.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>, xxx) <span class="comment">// 可以传参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutation携带数据</p><p>很多时候提交mutation会携带一些数据，在mutation中第二个参数可以接收</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addNumber</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span> += payload</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload也可以是对象类型</p><p>提交的时候：可以用type，指定提交的方法名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.<span class="title function_">commit</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;addNumber&quot;</span>,</span><br><span class="line">    <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addNumber</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span> += payload.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutation 常量类型</p><p>主要是预防粗心的时候，commit的方法名字和mutation定义的方法名不一致</p><ul><li><p>定义常量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INCREMENT_N</span> = <span class="string">&quot;INCREMENT_N&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>store中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">INCREMENT_N</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/mutation-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;...&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    [<span class="variable constant_">INCREMENT_N</span>](state, payload) &#123;</span><br><span class="line">      state.<span class="property">counter</span> += payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>组件中提交事件的时候使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">INCREMENT_N</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/mutation-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      store.<span class="title function_">commit</span>(<span class="variable constant_">INCREMENT_N</span>, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>mutation重要原则</p><p>mutation 必须是同步函数</p><ul><li>这是因为devtool工具会记录mutation的日记</li><li>每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照</li><li>但是在mutation中执行异步操作，就无法追踪到数据的变化</li><li>所以Vuex的重要原则中要求 mutation必须是同步函数；</li></ul></li></ul><h4 id="mapMutations">mapMutations</h4><p>我们也可以借助于辅助函数，帮助我们快速映射到对应的方法中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = <span class="title function_">mapMutations</span>([<span class="string">&quot;increment&quot;</span>, <span class="string">&quot;decrement&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> mutations2 = <span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">    <span class="attr">addNumber</span>: <span class="variable constant_">ADD_NUMBER</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="actions">actions</h3><ul><li><p>action提交mutation</p><ul><li><p>actions 类似于mutations，但是action提交的是mutation，而不是直接变更状态</p></li><li><p>actions 可以包含任意<strong>异步操作</strong></p></li><li><p>actions有一个很重要的参数 <strong>context</strong>，里面有很多属性，我们用的时候除了context.xxx使用，也可以解构出来使用</p></li><li><p>从context获取<strong>commit</strong>方法来提交一个mutation</p></li></ul></li><li><p>actions的分发操作（触发actions中的方法）</p><p>在组件中使用store上的<strong>dispatch</strong>进行分发，并且可以传递参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 1. 可以接收参数</span></span><br><span class="line">    <span class="title function_">incrementAction</span>(<span class="params">context, payload</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(payload)  <span class="comment">// payload为接收到的参数</span></span><br><span class="line">        <span class="comment">// 模拟异步：1s之后再提交事件</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>) <span class="comment">// 提交mutation</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">        <span class="comment">// 2. context 的属性</span></span><br><span class="line">    <span class="title function_">decrementAction</span>(<span class="params">&#123; commit, dispatch, state, rootState, getters, rootGetters &#125;</span>) &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&quot;decrement&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件的setup中</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 分发actions，并携带参数</span></span><br><span class="line">   store.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementAction&quot;</span>, &#123;<span class="attr">count</span>: <span class="number">100</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，也可以以对象的形式进行分发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件的setup中</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="string">&quot;incrementAction&quot;</span>,</span><br><span class="line">     <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="mapActions">mapActions</h4><p>actions 也有对应的辅助函数 mapActions</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样用不行..</span></span><br><span class="line"><span class="keyword">const</span> actions = mapActions[<span class="string">&quot;incrementAction&quot;</span>, <span class="string">&quot;decrementAction&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象写法(重命名)</span></span><br><span class="line"><span class="keyword">const</span> actions2 = <span class="title function_">mapActions</span>(&#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="string">&quot;incrementAction&quot;</span>,</span><br><span class="line">  <span class="attr">sub</span>: <span class="string">&quot;decrementAction&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="actions的异步操作">actions的异步操作</h4><p>actions很多时候是异步的，那么当我们组件派发actions的时候，我们也想收到结果，是请求成功了还是失败了，这时候我们可以在actions对应方法中返回 Promise，并对成功失败做处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">   <span class="title function_">getHomeMultidata</span>(<span class="params">context</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">          context.<span class="title function_">commit</span>(<span class="string">&quot;addBannerData&quot;</span>, res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span>)</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&quot;okok&quot;</span>)</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = store.<span class="title function_">dispatch</span>(<span class="string">&quot;getHomeMultidata&quot;</span>)</span><br><span class="line">    promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="module">module</h3><h4 id="module的基本使用">module的基本使用</h4><p>什么是module？</p><ul><li>由于使用单一状态树，应用的所有状态都集中到一个比较大的对象，当应用变得复杂时，store对象就变得相当臃肿，不利于管理</li><li>所以Vuex允许我们将store分模块</li><li>每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块</li></ul><p>使用：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c755defa77b4c7fa9c8bd2d4a36217c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><ul><li>模块内部的mutation和getter的第一个参数state是模块的局部状态对象</li></ul><h4 id="module的命名空间">module的命名空间</h4><p>默认情况下，模块内部的action，mutation仍然是注册在全局的命名空间中的</p><p>如果希望模块具有更高的封装度和复用性，可以在模块中添加<code>namespaced: true</code></p><p>使模块更独立</p><p>之后，当模块被注册后它的所有getter、action及mutation都会自动根据模块注册的路径调整命名</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/827e0697e09d426699b684bf4bbdc59e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="module修改或派发根组件">module修改或派发根组件</h4><p>{root: true}</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementAction</span>(<span class="params">&#123;commit, dispatch,state&#125;</span>) &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&quot;rootIncrement&quot;</span>, <span class="literal">null</span>, &#123;<span class="attr">root</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="string">&quot;rootIncrementAction&quot;</span>, <span class="literal">null</span>, &#123;<span class="attr">root</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="module的辅助函数">module的辅助函数</h4><p>写法一：通过完整的模块空间名来查找(不是很推荐使用)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="attr">homeCounter</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">home</span>.<span class="property">homeCounter</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...<span class="title function_">mapGetters</span>(&#123;</span><br><span class="line">    <span class="attr">doubleHomeCounter</span>: <span class="string">&quot;home/doubleHomeCounter&quot;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>写法二：第一个参数写模块名，第二个参数写属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">   ...<span class="title function_">mapState</span>(<span class="string">&quot;home&quot;</span>, [<span class="string">&quot;homeCounter&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法三：<code>createNamespacedHelpers</code>辅助函数</p><p>创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapGetters&#125; = <span class="title function_">createNamespacedHelpers</span>(<span class="string">&quot;home&quot;</span>)</span><br><span class="line"></span><br><span class="line">...<span class="title function_">mapState</span>([<span class="string">&quot;homeCounter&quot;</span>])</span><br></pre></td></tr></table></figure><p><strong>setup中使用</strong></p><p>修改之前的 hooks，<strong>useState</strong>，<strong>useGetters</strong>，考虑模块的情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useMapper &#125; <span class="keyword">from</span> <span class="string">&#x27;./useMapper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">moduleName, mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mapperFn = mapState</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> moduleName === <span class="string">&#x27;string&#x27;</span> &amp;&amp; moduleName.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    mapperFn = <span class="title function_">createNamespacedHelpers</span>(moduleName).<span class="property">mapState</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mapper = moduleName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMapper</span>(mapper, mapperFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// useGetters同理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useMapper &#125; <span class="keyword">from</span> <span class="string">&quot;./useMapper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useGetters</span>(<span class="params">moduleName, mapper</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mapperFn = mapGetters</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> moduleName === <span class="string">&#x27;string&#x27;</span> &amp;&amp; moduleName.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    mapperFn = <span class="title function_">createNamespacedHelpers</span>(moduleName).<span class="property">mapGetters</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mapper = moduleName</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMapper</span>(mapper, mapperFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">useState</span>([<span class="string">&quot;rootCounter&quot;</span>])</span><br><span class="line">  <span class="keyword">const</span> rootGetters = <span class="title function_">useGetters</span>([<span class="string">&quot;doubleRootCounter&quot;</span>])</span><br><span class="line">  <span class="keyword">const</span> getters = <span class="title function_">useGetters</span>(<span class="string">&quot;home&quot;</span>, [<span class="string">&quot;doubleHomeCounter&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vuex的状态管理&quot;&gt;Vuex的状态管理&lt;/h2&gt;
&lt;h3 id=&quot;vuex介绍&quot;&gt;vuex介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;什么是状态管理？&lt;/p&gt;
&lt;p&gt;应用程序的各种数据保存到某个位置进行管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;ht</summary>
      
    
    
    
    <category term="深入Vue3+Typescript学习⚡" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"/>
    
    
    <category term="vue3" scheme="https://hillyee.github.io/tags/vue3/"/>
    
    <category term="vuex" scheme="https://hillyee.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>前端人的数据结构与算法之路</title>
    <link href="https://hillyee.github.io/2022/04/04/%E5%89%8D%E7%AB%AF%E4%BA%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF/"/>
    <id>https://hillyee.github.io/2022/04/04/%E5%89%8D%E7%AB%AF%E4%BA%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF/</id>
    <published>2022-04-04T09:25:17.000Z</published>
    <updated>2022-04-04T16:02:01.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习资料">学习资料</h3><blockquote><ol><li><p>[前端算法与数据结构面试：底层逻辑解读与大厂真题训练]</p><p>链接：<a href="https://juejin.cn/book/6844733800300150797">https://juejin.cn/book/6844733800300150797</a></p><p>大纲：</p></li></ol><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/24/171ac6e4faf30ecf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:67%;" /></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;学习资料&quot;&gt;学习资料&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;[前端算法与数据结构面试：底层逻辑解读与大厂真题训练]&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://juejin.cn/book/6844733800300150797&quot;</summary>
      
    
    
    
    <category term="数据结构与算法😥" scheme="https://hillyee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%F0%9F%98%A5/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://hillyee.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VueRouter</title>
    <link href="https://hillyee.github.io/2022/04/04/VueRouter/"/>
    <id>https://hillyee.github.io/2022/04/04/VueRouter/</id>
    <published>2022-04-04T09:12:34.000Z</published>
    <updated>2022-04-14T06:44:41.752Z</updated>
    
    <content type="html"><![CDATA[<p>VueRouter路由使用</p><h3 id="简单的介绍😏">简单的介绍😏</h3><blockquote><p>这一部分了解、理解一下，知道有就行</p></blockquote><p>后端路由阶段：</p><ul><li>服务器渲染好整个页面，并且将页面返回给客户端</li><li>不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化</li><li>不利于维护</li></ul><p>前后端分离阶段：</p><ul><li>后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中</li><li>前后端责任清晰，后端专注于数据上，前端专注于交互和可视化上</li></ul><p>前端路由是如何做到URL和内容进行映射呢？监听URL的改变</p><h4 id="URL的hash">URL的hash</h4><p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性</p><p>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p><p>(页面一旦刷新，又会向服务器发请求)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> contentEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.content&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">switch</span>(location.<span class="property">hash</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">case</span> <span class="string">&quot;#/home&quot;</span>: </span></span><br><span class="line"><span class="language-javascript">                contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;Home&quot;</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">case</span> <span class="string">&quot;#/about&quot;</span>: </span></span><br><span class="line"><span class="language-javascript">                contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;About&quot;</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br></pre></td></tr></table></figure><p>hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2338dd9e294d475d98d18814fc6a9759~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:50%;" /><h4 id="HTML5的History">HTML5的History</h4><p>history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面：</p><p>replaceState：替换原来的路径</p><p>pushState：使用新的路径（压栈）</p><p>popState：路径的回退（弹栈）</p><p>go：向前或向后改变路径 go(1)前进1步，go(2)，前进两步，go(-1)，后退一步</p><p>forward：向前一步</p><p>back：后退一步</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> contentEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.content&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">changeContent</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">switch</span>(location.<span class="property">pathname</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">case</span> <span class="string">&quot;/home&quot;</span>:</span></span><br><span class="line"><span class="language-javascript">        contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;Home&quot;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">case</span> <span class="string">&quot;/about&quot;</span>:</span></span><br><span class="line"><span class="language-javascript">        contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;About&quot;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: </span></span><br><span class="line"><span class="language-javascript">        contentEl.<span class="property">innerHTML</span> = <span class="string">&quot;Default&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> aEls = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> aEl <span class="keyword">of</span> aEls) &#123;</span></span><br><span class="line"><span class="language-javascript">    aEl.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      e.<span class="title function_">preventDefault</span>() <span class="comment">// 阻止默认行为</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> href = aEl.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// history.replaceState(&#123;&#125;, &quot;&quot;, href)</span></span></span><br><span class="line"><span class="language-javascript">      history.<span class="title function_">pushState</span>(&#123;&#125;, <span class="string">&quot;&quot;</span>, href)</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">changeContent</span>()</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, changeContent)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce1fff5aaeb47de851682528df97530~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:50%;" /><h3 id="vue-router📱">vue-router📱</h3><p>Vue Router 是 Vue.js 的官方路由，便于构建单页面应用</p><h4 id="使用vue-router">使用vue-router</h4><ul><li>安装 Vue Router</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><ul><li>路由的使用步骤</li></ul><ol><li><p>创建路由组件</p></li><li><p>配置路由映射、创建路由对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../pages/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个路由对象router</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 使用路由的模式，hash / history</span></span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>在全局main.js中注册路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">vue.<span class="title function_">use</span>(router)</span><br></pre></td></tr></table></figure></li><li><p>使用路由：<code>&lt;router-link&gt;</code> <code>&lt;router-view&gt;</code></p><p>这种<code>&lt;router-link to&gt;</code>叫 <strong>声明式导航</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="路由重定向">路由重定向</h4><p>对 ‘/’ 这个路径，重定向到’/home’</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">  <span class="comment">// 重定向</span></span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>路由还有其他属性</p><ul><li>name：给某个路由起独一无二的名字</li><li>meta：配置一些参数，被一起带到router对象中</li></ul><h4 id="路由懒加载">路由懒加载</h4><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件</p><p>好处：提高首屏的渲染效率</p><p>实际就是webpack的分包，而Vue Router默认就支持动态来导入组件</p><ul><li>这是因为component可以传入一个组件，也可以接收一个函数，该函数需要返回一个Promise</li><li>而import函数就是返回一个Promise</li></ul><p>不采用直接<code>import Home from '../pages/Home.vue'</code>的方式</p><p>另外还可以对分包命名：<code>/*webpackChunkName: &quot;xxx&quot;*/</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="comment">// 还可以对分包命名</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="comment">/*webpackChunkName: &quot;ahout-chunk&quot; */</span><span class="string">&quot;../pages/About.vue&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>打包后的效果</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd0fdef2422c405388ab51b6a851eabc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="router-link的属性">router-link的属性</h4><ul><li><p>to：字符串（‘/home’）或者对象（配置路径+参数）</p></li><li><p>replace：替代</p><p>设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()</p></li><li><p>active-class属性：可以在这个class加样式啥的</p><p>设置激活a元素后应用的class，默认是router-link-active(一般 不去修改)</p></li><li><p>exact-active-class属性</p><p>链接精准激活时，应用于渲染的  的 class，默认是router-link-exact-active</p><p>在嵌套路由中，例如有一个嵌套路由是：/home/message 那么这个class只会在message那个子路由中</p></li></ul><h4 id="动态路由">动态路由</h4><p>动态，即这个路由的路径是动态改变的</p><p>在Vue Router中，我们可以在路径中使用一个动态字段来实现，我们称之为路径参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:username/id/:id&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/User.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:username? 加？表示可有可无，否则必须有</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82dd5687c9ad49d7932878f443e5319d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" /><p>如何获取动态路由的值？</p><p>在template中：<code>$route.params</code></p><p>在created中：<code>this.$route.params</code></p><p>在setup中：要使用 vue-router库给我们提供的一个hook <strong>useRoute</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 直接调用useRoute()，会返回一个路由对象</span></span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(route);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="NotFound">NotFound</h4><p>对于那些没有匹配到的路由，我们通常会匹配到固定的某个页面</p><p>可编写一个动态路由用于匹配所有的页面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/:pathMath(.*)&#x27;</span>, <span class="comment">// 用到正则 .*匹配任意字符0或多个</span></span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/NotFound.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>$route.params.pathMath</code>获取传入的参数</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ad95ddeb9fd4b9fbf2cf6d647adb023~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>还有一种写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/:pathMath(.*)*&#x27;</span> <span class="comment">// 这里多加一个*</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/NotFound.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别在于解析的时候，是否解析 /：</p><p>把路径中的/…/ 分成一个个的</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7701324e163b43c9a42c24b89deefe4f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h4 id="路由的嵌套">路由的嵌套</h4><p>某个路由页面本身也存在路由的来回切换</p><p>配置子路由，同样在home中使用router-link,router-view</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>),</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>, <span class="comment">// 这里不需要/</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Message.vue&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;goods&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Goods.vue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编程式路由">编程式路由</h4><p>不通过router-link的方式实现跳转，比如点击的是一个按钮等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取router对象</span></span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">gotoMessage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/home/message&#x27;</span>) <span class="comment">// 可以直接传字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">gotoGoods</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home/goods&#x27;</span> <span class="comment">// 也可以是对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有 router.replace、router.go、back、forward</p><p>vue2中：<code>this.$router.push</code></p><h4 id="query-查询-方式的参数">query(查询)方式的参数</h4><p>传递query参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home/goods&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在对应页面中获取query参数：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;---&#123;&#123;$route.query.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="router-link的v-slot">router-link的v-slot</h4><blockquote><p>用到查文档就好</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-slot可以拿到router-link给我们传递过来的属性(可以自己命名 props)</span></span><br><span class="line"><span class="comment">custom:表示自定义router-link，外部不会给我们包裹a元素了</span></span><br><span class="line"><span class="comment">props.navigate：所以当我们想点击某个元素跳转的时候可以使用navigate(当然用编程式导航也是可以的)</span></span><br><span class="line"><span class="comment">props.route：路由对象</span></span><br><span class="line"><span class="comment">props.href: 解析后的url</span></span><br><span class="line"><span class="comment">props: isActive 是否当前处于活跃的状态 (true,false)</span></span><br><span class="line"><span class="comment">props: isExactActive 是否当前处于精确的活跃状态 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;props&quot;</span> <span class="attr">custom</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>href: &#123;&#123;props.href&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;props.navigate&quot;</span>&gt;</span>跳转home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;props.route&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: props.isActive&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: props.isActive&#125;&quot;</span>&gt;</span>&#123;&#123;props.isExactActive&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="router-view的v-slot">router-view的v-slot</h4><p>router-view也提供给我们一个插槽，可以用于<code>&lt;transition&gt;</code>和<code>&lt;keep-alive&gt;</code>组件来包裹你的路由组件（用于加动画，缓存）</p><p>Component：要渲染的组件</p><p>route：解析出的标准化路由对象</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以拿到router-view给我们传过来的组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;props.Component&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="动态添加路由">动态添加路由</h4><p>比如说我们要根据不同的权限来决定是否添加路由</p><p>路由对象router上有方法：addRoute()动态添加路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义要添加的动态路由（可以先定义</span></span><br><span class="line"><span class="keyword">const</span> momentRoute = &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/moment&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/HomeMoment.vue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">router.<span class="title function_">addRoute</span>(momentRoute)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以添加的时候作为addRoute的第二个参数）</span></span><br><span class="line"><span class="comment">// 给home动态添加子路由cart 路径:/home/cart</span></span><br><span class="line">router.<span class="title function_">addRoute</span>(<span class="string">&#x27;home&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;cart&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&quot;../pages/Cart.vue&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="动态删除路由">动态删除路由</h4><p>三种方式：</p><ul><li>添加一个同名路由，相当于覆盖</li><li>通过removeRoute方法，传入路由的名称</li><li>通过addRoute方法的返回值回调</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span>&#125;)</span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">router.<span class="title function_">addRoute</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/other&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Other</span>&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">router.<span class="title function_">removeRoute</span>(<span class="string">&#x27;about&#x27;</span>)</span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line"><span class="keyword">const</span> removeRoute = router.<span class="title function_">addRoute</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span>&#125;)</span><br><span class="line"><span class="title function_">removeRoute</span>()</span><br></pre></td></tr></table></figure><p><strong>路由其他方法补充</strong></p><ul><li>router.hasRoute()：检查路由是否存在。</li><li>router.getRoutes()：获取一个包含所有路由记录的数组</li></ul><h3 id="路由导航守卫👮">路由导航守卫👮</h3><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p><h4 id="全局前置守卫beforeEach">全局前置守卫beforeEach</h4><p>在导航触发时会被回调</p><p>它有两个参数：</p><ul><li>to：即将进入的路由对象</li><li>from：即将离开的Route对象</li></ul><p>返回值：</p><ul><li>false：取消当前导航</li><li>不返回或者返回undefined：进行默认导航</li><li>返回一个路由地址：<ul><li>路径字符串：‘/home’</li><li>对象：类似于 router.push({path: “/login”, query: …})</li></ul></li></ul><p>小案例：如果没登录就跳转到登录页面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> !== <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(!token) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><blockquote><p>更多导航守卫看官网</p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p></blockquote><p><strong>完整的导航解析流程</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1054c2d5ce484b73bb273502b22db54b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="其他补充-2">其他补充</h3><h4 id="historyApiFallback">historyApiFallback</h4><p>开发中一个非常常见的属性，主要作用是解决SPA页面在路由跳转之后，进行页面刷新时，返回404的错误</p><p>如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容</p><blockquote><p>因为我们使用的是前端路由，刷新页面时访问的资源在服务端找不到，因为vue-router设置的路径不是真实存在的路径。</p></blockquote><blockquote><p>注：我们使用 vue-cli的时候，默认已经帮我们设置为true了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback">https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;VueRouter路由使用&lt;/p&gt;
&lt;h3 id=&quot;简单的介绍😏&quot;&gt;简单的介绍😏&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这一部分了解、理解一下，知道有就行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后端路由阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器渲染好整个页面，并且</summary>
      
    
    
    
    <category term="深入Vue3+Typescript学习⚡" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"/>
    
    
    <category term="vue路由" scheme="https://hillyee.github.io/tags/vue%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>随笔✍</title>
    <link href="https://hillyee.github.io/2022/04/03/%E9%9A%8F%E7%AC%94/"/>
    <id>https://hillyee.github.io/2022/04/03/%E9%9A%8F%E7%AC%94/</id>
    <published>2022-04-03T04:57:12.000Z</published>
    <updated>2022-04-04T16:06:41.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>待完善…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;待完善…&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="其他" scheme="https://hillyee.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>关于JS数据类型</title>
    <link href="https://hillyee.github.io/2022/04/03/%E5%85%B3%E4%BA%8EJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://hillyee.github.io/2022/04/03/%E5%85%B3%E4%BA%8EJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-04-03T03:09:28.000Z</published>
    <updated>2022-04-03T04:32:34.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS-数据类型转换">JS 数据类型转换</h3><p>类型转换可以分为两种：<strong>隐式类型转换</strong> 和 <strong>显式类型转换</strong></p><p><strong>显式</strong>：比如 Number(value) String(value) …</p><p><strong>隐式</strong>：对不同类型的值使用运算符时，值可以自动转换，比如 1 == null</p><p>我们需要知道：在 JS 中只有3中类型的转换：转换为 Number，String，Boolean类型</p><p>所以我们只需要弄清楚在什么场景下应该转成哪种类型就可以了</p><h4 id="转换为boolean"><strong>转换为boolean</strong></h4><p><strong>显式</strong>：<code>Boolean() </code>方法可以直接用来将值转换成布尔型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>隐式</strong>：通常在逻辑判断或者有逻辑运算符时被触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">2</span>) &#123;&#125; <span class="comment">// 逻辑判断</span></span><br><span class="line">!!<span class="number">2</span> <span class="comment">// 逻辑运算</span></span><br><span class="line"><span class="number">2</span> || <span class="string">&#x27;hello&#x27;</span> <span class="comment">// 逻辑运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="string">&#x27;hello&#x27;</span> &amp;&amp; <span class="number">123</span> <span class="comment">// x === 123</span></span><br><span class="line"><span class="comment">// 逻辑运算符（比如 || 和 &amp;&amp;）是在内部做了 boolean 类型转换，但实际上返回的是原始操作数的值</span></span><br></pre></td></tr></table></figure><p>boolean类型转换只有 true，false两种结果。</p><p>除了 <strong>0、NaN、空字符串、null、undefined</strong>五个值是false，其余都是true</p><blockquote><p>额外补充：</p><p>逻辑或 ||：一真为真，a || b，只要a为真就返回a的执行结果，b不执行；a为假则执行b，并返回b执行后的结果</p><p>逻辑与 &amp;&amp;：一假为假，a &amp;&amp; b，只要a为假就返回a的执行结果，b不执行；a为真则执行b，并返回b执行后的结果</p></blockquote><h4 id="转换为为string">转换为为string</h4><ul><li>显式：<code>String() </code>方法可以用来显式将值转为字符串。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"><span class="title class_">String</span>(&#123;&#125;) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>隐式：隐式转换通常在有 <code>+</code> 运算符并且只是至少有一个操作数是 string 类型时被触发，即字符串拼接</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;123&#x27;</span>  <span class="comment">//&quot;1123&quot; </span></span><br><span class="line"><span class="number">1</span> + &#123;&#125; <span class="comment">// &#x27;1[object Object]&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">null</span> <span class="comment">// &#x27;1null&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型]</p></li><li><p>null 与字符串拼接时null直接转为 ‘null’ (内部的实现)</p></li></ul></blockquote><h4 id="转换为number">转换为number</h4><p><strong>显式</strong>：<code>Number()</code>方法可以用来显式将值转换成数字类型</p><ul><li>字符串转换为数字：空字符串变为0，如果出现任何一个非有效数字字符，结果都是NaN</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)           <span class="comment">//0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;10px&quot;</span>)       <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;10&quot;</span>)         <span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>布尔转换为数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>null 和 undefined 转换成数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><ul><li>Symbol无法转换为数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="title class_">Symbol</span>()) <span class="comment">// Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><ul><li>BigInt</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="title class_">BigInt</span>(<span class="number">10</span>)) <span class="comment">// 10</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="number">10n</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p><strong><code>BigInt</code></strong> 是一种内置对象，它提供了一种方法来表示大于 <code>2^53 - 1</code> 的整数。<strong><code>BigInt</code></strong> 可以表示任意大的整数。</p><p>可以用在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>BigInt</code> ，如：<code>10n</code>，或者调用函数 <code>BigInt()</code>（但不包含 <code>new</code> 运算符）并传递一个整数值或字符串值,如<code>BigInt(10)</code></p></blockquote><ul><li>对象转换为数字，会按照下面的步骤执行</li></ul><ol><li><p>先调用对象的 <code>Symbol.toPrimitive</code> 这个方法，如果不存在这个方法</p><blockquote><p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive</a></p></blockquote></li><li><p>再调用对象的 <code>valueOf()</code> 获取原始值，如果获取的值依然不是数字</p><blockquote><p><code>valueOf()</code> 方法返回指定对象的原始值。</p></blockquote></li><li><p>再调用对象的 <code>toString()</code> 把其变为字符串</p><blockquote><p>把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型]</p></blockquote></li><li><p>最后再把字符串基于<code>Number()</code>方法转换为数字</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj-<span class="number">10</span>) <span class="comment">// 数学运算：先把obj隐式转换为数字，再进行运算</span></span><br><span class="line"><span class="comment">//运行机制</span></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] <span class="comment">//undifined </span></span><br><span class="line">obj.<span class="title function_">valueof</span>() <span class="comment">// &#123;name:xxx&#125;</span></span><br><span class="line">obj.<span class="title function_">toString</span>() <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">Number</span> (<span class="string">&quot;[object object]&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span>-<span class="number">10</span> <span class="comment">// NaN </span></span><br></pre></td></tr></table></figure><p><strong>隐式</strong></p><p>number 的隐式类型转换是比较复杂的，因为它可以在下面多种情况下被触发</p><ul><li><p>比较操作（&gt;, &lt;, &lt;=, &gt;=）</p></li><li><p>按位操作（| &amp; ^ ~）</p></li><li><p>算数操作（- + * / %），</p><p><strong>注意</strong>：当 <code>+</code>存在任意的操作数是 string 类型时，转换到string类型为止，不会触发 number 类型的隐式转换</p></li><li><p>一元 + 操作</p><blockquote><p>一元就是只有一个操作数，+5    +[]</p><p>+[]  --&gt; 0 相当于Number([])</p><p>+{} --&gt; NaN  相当于String({})=‘[object,Object]’；Number(‘[object,Object]’) --&gt;NaN</p></blockquote></li></ul><p><strong>需要注意的情况</strong></p><blockquote><p>javascript中加法会触发3种类型转换，即将值转换为原始值，转换为字符串，转换为数字。这刚好对应了javascript引擎内部的转换操作：ToPrimitive(),toString(),toNumber()</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + [] === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">[] + &#123;&#125; === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125; + []，对于编译器来说,&#123;&#125;在开头，被解析成代码块，不会返回任何值</span></span><br><span class="line"><span class="comment">// 所以&#123;&#125; + []实际上就是 +[]</span></span><br><span class="line"><span class="comment">// []通过ToPrimitive(),toString() 变成 &quot;&quot;</span></span><br><span class="line"><span class="comment">// 最后 toNumber() --&gt; 0</span></span><br><span class="line"></span><br><span class="line">[] + &#123;&#125; <span class="comment">// 这里&#123;&#125;就是一个对象</span></span><br><span class="line"><span class="comment">// String([])=&#x27;&#x27; String(&#123;&#125;)=&#x27;[object Object]&#x27; </span></span><br><span class="line"><span class="comment">// 有string类型不会触发number转换了,两边都是string直接拼接</span></span><br><span class="line"><span class="comment">// 所以 &#x27;&#x27; + &#x27;[object Object]&#x27; --&gt; &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>操作符 == 两边的隐式转换</strong></p><p>如果两边的数据类型不同，需要先转为相同类型再进行比较</p><ul><li>对象 == 字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] == <span class="string">&#x27;1,2,3&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 转为字符串</span></span><br><span class="line"><span class="comment">// [1,2,3].toString() --&gt; &#x27;1,2,3&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;helo&#x27;</span>&#125; == <span class="string">&quot;&#123;name:&#x27;helo&#x27;&#125;&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// &#123;name:&#x27;helo&#x27;&#125;.valueOf().toString() --&gt; &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>null/ undefined</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">//null/undefined和其他任何值都不相等</span></span><br></pre></td></tr></table></figure><ul><li>对象 == 对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == &#123;&#125; <span class="comment">// false 比较的是堆内存地址，地址相同才相等</span></span><br></pre></td></tr></table></figure><ul><li>NaN</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> == xxx  都是<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>除了以上的四种情况，只要两边类型不一致，都是转换为数字再进行比较</p><p>最后，看题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">100</span> + <span class="literal">true</span> + <span class="number">21.2</span> + <span class="literal">null</span> + <span class="literal">undefined</span> + <span class="string">&quot;Tencent&quot;</span> + [] + <span class="literal">null</span> + <span class="number">9</span> + <span class="literal">false</span></span><br></pre></td></tr></table></figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd196b1f2e24fae861c5137e543c817~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>参考资料：</p><blockquote><p><a href="https://juejin.cn/post/6956170676327677966">https://juejin.cn/post/6956170676327677966</a></p></blockquote><h3 id="数据类型的判断-2">数据类型的判断</h3><blockquote><p><a href="https://juejin.cn/post/7061588533214969892#heading-29">https://juejin.cn/post/7061588533214969892#heading-29</a></p><p>把引用类型转换为String时就会调用Object.prototype.toString(), 输出的格式是[object 对象的类型]</p><p>Object.prototype.toString.call() 有显式绑定，</p><p>因此 Object.prototype.toString.call(xxx)就是 找到xxx中的toString方法，输出的对象的类型就是根据xxx来的</p></blockquote><h3 id="神奇的加法">神奇的加法</h3><blockquote><p><a href="https://blog.csdn.net/dk2290/article/details/86534595">https://blog.csdn.net/dk2290/article/details/86534595</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JS-数据类型转换&quot;&gt;JS 数据类型转换&lt;/h3&gt;
&lt;p&gt;类型转换可以分为两种：&lt;strong&gt;隐式类型转换&lt;/strong&gt; 和 &lt;strong&gt;显式类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式&lt;/strong&gt;：比如 Number(value</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://hillyee.github.io/categories/JavaScript/"/>
    
    
    <category term="面试" scheme="https://hillyee.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>08_JS面向对象</title>
    <link href="https://hillyee.github.io/2022/04/02/08-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hillyee.github.io/2022/04/02/08-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-04-02T08:37:13.000Z</published>
    <updated>2022-04-10T05:51:04.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入JS面向对象">深入JS面向对象</h2><h2 id="面向对象初识">面向对象初识</h2><h2 id="创建对象的方式">创建对象的方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：通过new Object()创建</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;hill&quot;</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">obj.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：字面量形式</span></span><br><span class="line"><span class="keyword">var</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hill&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">eating</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对属性的操作">对属性的操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yuzi&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.获取属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// yuzi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给属性赋值</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;jackson&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// jackson</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除属性</span></span><br><span class="line"><span class="comment">// delete obj.name</span></span><br><span class="line"><span class="comment">// console.log(obj); // &#123;age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.遍历属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种直接定义在对象内部或者直接添加到对象内部的属性，我们不能对其做出限制：比如这个属性是否可以通过delete删除，是否可以在for-in遍历的时候被遍历出来</p><h2 id="Object-defineProperty">Object.defineProperty()</h2><ul><li><p>如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符</p><ul><li><p>通过属性描述符可以精准的添加或修改对象的属性</p></li><li><p>属性描述符需要使用 Object.defineProperty 来对属性进行添加或修改</p></li></ul></li><li><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p></li><li><p>接收三个参数</p><ul><li>obj:要定义属性的对象</li><li>prop: 要定义或修改的属性的名称或Symbol</li><li>descriptor：要定义或修改的属性描述符</li></ul></li><li><p>第三个参数的属性描述符分为两类：</p><ul><li>数据属性描述符<br>configurable，enumerable，writable，value</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接在一个对象上定义某个属性时，描述符的默认值为</span></span><br><span class="line"><span class="comment">// value: 赋值的value</span></span><br><span class="line"><span class="comment">// configurable: true</span></span><br><span class="line"><span class="comment">// enumerable: true</span></span><br><span class="line"><span class="comment">// writable: true</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;height&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1.88</span>, <span class="comment">// 属性值(默认为 undefined)</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,  <span class="comment">// 对应属性是否可以枚举(默认为false)</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以修改属性值(默认为false)</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 属性能否被删除(默认为false),属性的描述符能否被改变</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name age height 可枚举</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;height&#x27; ] 可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性值</span></span><br><span class="line">obj.<span class="property">height</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">height</span>); <span class="comment">// 2 可修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">height</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">height</span>); <span class="comment">// undefined 删除成功</span></span><br></pre></td></tr></table></figure><ul><li><p>存取属性描述符<br>enumerable，configurable，get，set</p><p>不用value,writable，而是用 get,set</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">_address</span>: <span class="string">&quot;广东&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有属性，js里面是没有严格意义的私有属性的，所以我们实际上也能直接访问，但是在社区人们约定 下划线_开头的属性定义为私有属性</span></span><br><span class="line"><span class="comment">// 1.隐藏某一个私有属性(address)不希望直接被外界使用和赋值</span></span><br><span class="line"><span class="comment">// 2.如果我们希望截获某个属性被访问和设置值的过程时，也会使用存储属性描述符</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;address&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可删除，可修改描述符</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取了一次address的值&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_address</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;设置了address的值&quot;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_address</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">address</span>); <span class="comment">// 广东</span></span><br></pre></td></tr></table></figure></li></ul><p>可枚举属性的补充</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;address&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;北京市&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="comment">// address属性默认是不可枚举的，但是我们在浏览器上面是可以看到的（稍微浅色一点），这是浏览器为了方便我们调试做的处理</span></span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fca538eddaf4ec39491455e819979ef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h2 id="Object-defineProperties">Object.defineProperties()</h2><p><strong>Object.defineProperties()</strong> 方法可以直接在一个对象上定义多个新的属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">_age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;jackson&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对象方法补充(了解)</p><ul><li>获取对象的属性描述符<ul><li>getOwnPropertyDescriptor</li><li>getOwnPropertyDescriptors</li></ul></li><li>禁止对象扩展新属性<ul><li>preventExtensions：给一个对象添加新的属性会失败(在严格模式下会报错)</li></ul></li><li>密封对象，不允许配置和删除属性：seal<ul><li>实际是调用preventExtensions</li><li>并且将现有属性的configurable:false</li></ul></li><li>冻结对象，不允许修改现有属性：freeze<ul><li>实际上是调用seal</li><li>并且将现有属性的writable: false</li></ul></li></ul><h2 id="创建多个对象的方式">创建多个对象的方式</h2><blockquote><p>通过想要创建多个对象的目的，来引出后面的构造函数</p></blockquote><p>前面我们通过 new Object，字面量的方式创建对象，但是这两种方式有一个很大的弊端：</p><p>创建同样的对象时，需要编写重复代码</p><p>比如说字面量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = &#123;<span class="attr">name</span>: , <span class="attr">age</span>: &#125;</span><br><span class="line"><span class="keyword">var</span> p2 = &#123;<span class="attr">name</span>: , <span class="attr">age</span>: &#125;</span><br><span class="line"><span class="keyword">var</span> p3 = &#123;<span class="attr">name</span>: , <span class="attr">age</span>: &#125; <span class="comment">// 它们有同样的属性或者方法</span></span><br></pre></td></tr></table></figure><h3 id="创建对象的方式-工厂模式">创建对象的方式 - 工厂模式</h3><ul><li>工厂模式其实是一种常见的设计模式</li><li>通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象</li><li>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</li><li>但是从某些角度来说，这些对象应该有一个他们共同的类型</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = &#123;&#125; <span class="comment">// 定义一个对象</span></span><br><span class="line">  p.<span class="property">name</span> = name</span><br><span class="line">  p.<span class="property">age</span> = age</span><br><span class="line">  p.<span class="property">height</span> = height</span><br><span class="line"></span><br><span class="line">  p.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p <span class="comment">// 把对象返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">createPerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>, <span class="number">1.98</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="title function_">createPerson</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>, <span class="number">1.78</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式的缺点：获取不到对象最真实的类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p2, p3); <span class="comment">// 我只知道你是一个对象，但我不知道你是person类型</span></span><br></pre></td></tr></table></figure><h3 id="认识构造函数">认识构造函数</h3><h4 id="什么是构造函数？">什么是构造函数？</h4><ul><li>构造函数也称之为构造器（constructor），通常我们在创建对象时会调用的函数</li><li>JavaScript 中，如果一个普通的函数被使用 new 操作符来调用了，那么这个函数就称之为是一个构造函数</li></ul><blockquote><p>所以说构造函数也是一个普通函数，只不过用 new 去调用，就称为构造函数</p><p>new也是可以调用函数的喔</p></blockquote><h4 id="new操作符">new操作符</h4><p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p><ol><li>在内存中创建一个新的对象（空对象）</li><li>这个对象内部的 **[[prototype]]**属性会被赋值为该构造函数的 <strong>prototype</strong>属性</li><li>构造函数的 this ，会指向创建出来的新对象</li><li>执行函数的内部代码</li><li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li></ol><h4 id="构造函数创建对象">构造函数创建对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规范：构造函数的首字母一般是大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, height, address</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">address</span> = address</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is running&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>, <span class="string">&#x27;广州&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>, <span class="number">1.78</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// Person &#123;...&#125; 是可以看见类型的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure><ul><li>这个构造函数可以确保我们的对象是有Person的类型的</li><li>但是也有缺点：我们需要给每个对象的函数去创建一个函数对象实例（开辟新的内存空间）</li></ul><h3 id="对象的原型-prototype">对象的原型 [[prototype]]</h3><ul><li><p>JavaScript 中，每个对象都有一个特殊的内置属性 <strong>[[prototype]]</strong>，这个属性称之为对象的原型（隐式原型）（只要是对象，就会有这个内置属性）</p></li><li><p>[[prototype]] 指向一个对象（也就是说它也是一个对象）</p></li><li><p>那么这个对象有什么用呢？</p><ul><li>当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作</li><li>这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它</li><li>如果对象中没有该属性， 那么会沿着它的原型去查找 [[prototype]]</li></ul></li><li><p>如果通过字面量直接创建一个对象，那么这个对象也有[[prototype]]这个属性</p><p>如何查看这个属性呢</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> info = &#123;&#125;</span><br><span class="line"><span class="comment">// 创建出来的对象上都有 [[prototype]]属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何查看这个属性？</span></span><br><span class="line"><span class="comment">// 早期的ECMA是没有规范如何去查看 [[prototype]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象中提供了一个属性 __proto__, 可以让我们查看一下这个原型对象(浏览器提供)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);<span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于(伪代码)</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>, <span class="attr">__proto__</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5之后提供的Object.getPrototypeOf()查看</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如找 age 这个属性，该对象本身没有，沿着原型查找</span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数的原型-prototype">函数的原型 prototype</h3><ul><li>所有的函数都有一个 prototype 属性（显式原型）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数也是一个对象，所以它也是有[[prototype]]隐式属性</span></span><br><span class="line"><span class="comment">// 另外，函数还会多出来一个显式原型属性：prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br></pre></td></tr></table></figure><ul><li><p>再看回new操作符其中的一个步骤：</p><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性</p></li><li><p>也就意味着我们通过 Foo 构造函数创建出的所有对象的 [[prototype]] 都指向 Foo.prototype</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>创建对象的内存表现</strong></p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70022f5ae6854d12aad1feb4059f06af~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>可以看到：</p><ul><li>构造函数的 prototype 属性指向该函数的原型对象</li><li>原型对象身上有一个 constructor 属性指回构造函数本身</li><li>new出来的实例对象 p1，p2 对象身上有<code> __proto__</code>属性也指向构造函数的原型对象</li></ul><h3 id="函数原型上的属性constructor">函数原型上的属性constructor</h3><ul><li>默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. constructor属性</span></span><br><span class="line"><span class="comment">// Foo.prototype这个对象中有一个constructor属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123;&#125; 为什么没看到constructor？</span></span><br><span class="line"><span class="comment">// 那换一种方式看</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>));</span><br><span class="line"><span class="comment">//打印 </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: &#123;</span></span><br><span class="line"><span class="comment">//     value: [Function: Foo],</span></span><br><span class="line"><span class="comment">//     writable: true,        </span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 可以看到enumerable为false，所以第一种方式不能看到constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然这样，我们能不能重写这个对象的属性constructor呢？肯定可以呀</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//可枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可删除，描述符可修改</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 可写</span></span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hahahha&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这个时候我们再来直接打印，就可以看到constructor了(被我们改成可枚举了)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// &#123; constructor: &#x27;hahahha&#x27; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>我们也可以在prototype上添加自己的属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;jackson&quot;</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再new对象的时候，这些属性都可以通过实例的原型__proto__找到</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">name</span>); <span class="comment">// jackson</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: &#x27;hahahha&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;jackson&#x27;,</span></span><br><span class="line"><span class="comment">//   age: 18,</span></span><br><span class="line"><span class="comment">//   eating: [Function (anonymous)]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bf25777e8f4d79acf69ac0f18ee3ef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><ul><li>直接修改整个prototype对象（赋值，新开内存空间）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Foo</span>, <span class="comment">// 让它指回本身(但这样它默认是可枚举的)</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="property">name</span>); <span class="comment">// &quot;jackson&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了可以自定属性描述符,真实开发中我们可以通过Object.defineProperty添加constructor</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Foo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af35cbd1ec241cdba0a2f6059dfc55d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>原来的foo函数的原型对象因为没有对它的引用，会被回收的</p><h3 id="创建对象的方式-—-构造函数和原型组合">创建对象的方式 — 构造函数和原型组合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, address</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">address</span> = address</span><br><span class="line">  <span class="comment">// this.fn = function()</span></span><br><span class="line">  <span class="comment">// 为了不给每个实例都新开内存空间保存相同的方法，我们不把共同的方法定义在这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以把一些公共的方法直接通过原型对象添加</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is eating&#x27;</span>);</span><br><span class="line">  <span class="comment">// 这里的this怎么找到实例对象的？</span></span><br><span class="line">  <span class="comment">// 调用函数的时候隐式绑定啊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;is running&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jackson&quot;</span>, <span class="number">18</span>, <span class="string">&quot;guangdong&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yuzi&quot;</span>, <span class="number">18</span>, <span class="string">&quot;beijing&quot;</span>)</span><br><span class="line">p1.<span class="title function_">eating</span>()</span><br><span class="line">p2.<span class="title function_">eating</span>()</span><br></pre></td></tr></table></figure><p><strong>JavaScript中的类和对象</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>在 JS 中，Person应该被称之为是一个构造函数</p><p>但是从很多面向对象语言的开发者习惯称之为类，因为类可以帮我们创建出来实例对象，也是可以的</p><h2 id="面向对象的特性-继承">面向对象的特性 - 继承</h2><p>面向对象有三大特性：封装、继承、多态</p><ul><li>封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程</li><li>继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中）</li><li>多态：不同的对象在执行时表现出不同的形态</li></ul><h3 id="JavaScript原型链">JavaScript原型链</h3><p><strong>原型链的理解</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们&quot;.&quot;的时候就是[[get]]操作</span></span><br><span class="line"><span class="comment">// 1.在当前的对象中查找属性</span></span><br><span class="line"><span class="comment">// 2.如果没有找到，这个时候会去原型链(__proto__)对象上查找</span></span><br><span class="line">obj.<span class="property">__proto__</span> = &#123;</span><br><span class="line">  <span class="comment">// address: &quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>= &#123;</span><br><span class="line">  <span class="comment">// address: &quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>= &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">address</span>); <span class="comment">// &quot;广州市&quot;</span></span><br><span class="line"><span class="comment">// 只要在原型链上都可以找到的</span></span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c063bcc6504441389d9b3c70db077d8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" /><p>这样一直向上找的话，那么<strong>顶层原型</strong>究竟是什么呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;Jackson&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到那一层对象之后会停止继续查找呢？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// 可以看到字面量obj的原型是 [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们继续往上看看</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 所以我们可以说 [Object: null prototype] &#123;&#125; 就是顶层的原型</span></span><br></pre></td></tr></table></figure><p>顶层对象有什么特别吗？该对象上有很多默认的属性和方法</p><p>顶层原型又来自哪里呢？下面我们创建Object对象看看</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象(这种方式相当于下面一种方式的语法糖，本质都是创建一个对象)</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125; </span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 创建了一个对象</span></span><br><span class="line"><span class="comment">// 创建对象的话，其中有一步是：将Object函数的显式原型prototype赋值给实例的隐式原型</span></span><br><span class="line"><span class="comment">// 相当于这里</span></span><br><span class="line"><span class="comment">// Object.prototype = obj2.__proto__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此（我们知道这里obj1/2.__proto__已经是到顶层了）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === obj1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === obj2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype也是一个对象，那么它应该也有 __proto__</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 因此Object.prototype指向的已经是顶层原型了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)) </span><br><span class="line"><span class="comment">// 有constructor,toString等属性和方法</span></span><br></pre></td></tr></table></figure><p>因此，<strong>原型链最顶层的原型对象就是Object的原型对象</strong></p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b10008bf8e7c4bdbab8263ac50ea0ead~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>也就是说，<strong>Object是所有类的父类</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看构造函数Person的原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// &#123;&#125; 看不到！应该是不可枚举吧</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>));</span><br><span class="line"><span class="comment">//输出 &#123;constructor: &#123;...&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);<span class="comment">//[Object: null prototype] &#123;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cab7b21f72df4098af70a97cb23b19a9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><h3 id="通过原型链实现继承">通过原型链实现继承</h3><p><strong>为什么需要有继承？</strong></p><p>如果没有继承，我们想创建多个类，类里面的属性和方法很多是一样的，那么我们就会写很多重复的代码，所以主要是为了代码的复用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, sno</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// Teacher</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params">name, age, title</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>原型链的继承方案</strong></p><blockquote><p>自己画画图更好理解</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：公共属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Jackson&quot;</span>,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = []</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：特有属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = <span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new一个person</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="comment">// console.log(stu.sno); // 111</span></span><br><span class="line"><span class="comment">// console.log(stu.name);// Jackson</span></span><br><span class="line"><span class="comment">// stu.eating()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链实现继承的弊端：</span></span><br><span class="line"><span class="comment">// 1.打印stu对象，继承的属性是不能直观看到的</span></span><br><span class="line"><span class="comment">// console.log(stu); // Person &#123; sno: 111 &#125;</span></span><br><span class="line"><span class="comment">// 前面显示的 Person 类型,实际上是实例的name属性，显然这里应该是Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建出来两个stu对象</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取引用，修改引用中的值，会相互影响</span></span><br><span class="line"><span class="comment">// 因为这个fre1被加到p对象，而stu1,stu2的__proto__都指向p</span></span><br><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;fre1&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">friends</span>); <span class="comment">// [ &#x27;fre1&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>); <span class="comment">// [ &#x27;fre1&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在前面实现类的过程中都没有传递参数</span></span><br><span class="line"><span class="keyword">var</span> stu3 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jeccy&quot;</span>, <span class="number">112</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接在function Student(name,age)&#123;this.name = name this.age = age&#125;？</span></span><br><span class="line"><span class="comment">// 肯定不行啊，我们是想要把name的处理放在Person的</span></span><br></pre></td></tr></table></figure><h3 id="借用构造函数实现继承">借用构造函数实现继承</h3><blockquote><p>使用call调用构造函数，</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：公共属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, friends</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = friends</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;is eating&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：特有属性和方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, friends, sno</span>) &#123;</span><br><span class="line">  <span class="comment">// 我们在这里调用Person,并把需要Person处理的参数传过去</span></span><br><span class="line">  <span class="comment">// this 就是Student的实例 </span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, friends) <span class="comment">// 这里可以获得父类的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new一个person</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 依然需要这里来获得方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p </span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决弊端3</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>, [<span class="string">&#x27;fred1&#x27;</span>], <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1); </span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;aaa&#x27;, age: 18, friends: [ &#x27;fred1&#x27; ], sno: 111 &#125; 解决弊端1</span></span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;vvv&quot;</span>, <span class="number">20</span>, [<span class="string">&#x27;fred2&#x27;</span>], <span class="number">112</span>)</span><br><span class="line">stu1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;hahaha&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">friends</span>); <span class="comment">// [ &#x27;fred2&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>); <span class="comment">// [ &#x27;fred1&#x27;, &#x27;hahaha&#x27; ]</span></span><br><span class="line"><span class="comment">// 解决弊端2</span></span><br></pre></td></tr></table></figure><p>但是这种方法依然存在弊端：</p><ol><li>Person 至少被调用两次（一开始new Person一次，后面Person.call又会调用Person）</li><li>stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要（new Person的时候的）</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a1097b7c69f4850b9e4d5f245de611e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><p>注意：</p><p>那么我们换一种获得父类方法的方法，直接<strong>将父类原型赋值给子类</strong>？</p><p>肯定是不行的，因为以后给某个子类添加方法的时候，会使所有的子类都有该方法，显然是不行的</p><p>因为所有子类的prototype都指向同一个父类的原型</p><h3 id="原型式继承函数-对象">原型式继承函数 - 对象</h3><blockquote><p>我们先实现对象的继承，后面再扩展到类</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jackson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型式继承函数</span></span><br><span class="line"><span class="comment">// 这个函数要做到的是，你给我传入的对象，作为新对象的原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 这个方法是把o设置为newObj的原型</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(newObj, o)</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Douglas 的实现(当时还没有setPrototypeOf这个方法)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject2</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">  <span class="comment">// 因此 newObj.__proto__ = Fn.prototype = o</span></span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们想要新建的对象info的原型指向obj（后面扩展到类）</span></span><br><span class="line"><span class="comment">// var info = createObject(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 新的ECMA 给我们提供了新的方法：Object.create(obj)</span></span><br><span class="line"><span class="comment">// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span></span><br><span class="line"><span class="comment">// 实际上这个方法跟我们上面的两种实现方法实现的功能是一样的</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info);</span><br><span class="line"><span class="comment">// 已经实现了我们的目的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">__proto__</span>); <span class="comment">// &#123; name: &#x27;Jackson&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Object.create() ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p></blockquote><h3 id="寄生式继承函数（了解）">寄生式继承函数（了解）</h3><ul><li><p>寄生式继承的思路是结合原型类继承和工厂模式的一种方式</p></li><li><p>即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> personObj = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目的：继承 personObj里面的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> stu = <span class="title class_">Object</span>.<span class="title function_">create</span>(personObj)</span><br><span class="line">  stu.<span class="property">name</span> = name</span><br><span class="line">  stu.<span class="property">studying</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stuObj = <span class="title function_">createStudent</span>(<span class="string">&quot;why&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="寄生组合式继承-最终方案">寄生组合式继承(最终方案)</h3><p>利用寄生式继承将组合式继承的两个问题解决</p><ul><li>首先我们需要明确，当我们在子类的构造函数中调用父类.call(this，参数)的时候，就会将父类的属性和方法复制一份到子类中，所以父类本身里面的内容我们是不需要的</li><li>然后，我们还需要获取到一份父类的原型对象中的属性和方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不想使用Object.create这个方法的话，我们可以定义前面说过的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">SubType, SuperType</span>) &#123;</span><br><span class="line">  <span class="comment">// SubType.prototype = Object.create(SuperType.prototype)</span></span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">createObject</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="comment">// 当然子类的prototype还需要有constructor指向子构造函数本身</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">SubType</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, friends</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = friends</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, friends, sno</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, friends) <span class="comment">// 获取一份Person中的属性和方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student类还需要获取一份父类的prototype的属性和方法</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, [<span class="string">&quot;kobe&quot;</span>], <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br><span class="line"> <span class="comment">// 打印  Student &#123; name: &#x27;why&#x27;,age: 18,friends: [ &#x27;kobe&#x27; ],sno: 111,&#125;</span></span><br></pre></td></tr></table></figure><h3 id="JS原型的补充">JS原型的补充</h3><h4 id="hasOwnProperty">hasOwnProperty</h4><ul><li>判断对象是否有某个属于自己的属性，不包括在原型上的</li></ul><h4 id="in-for-in-操作符">in/ for in 操作符</h4><ul><li>判断某个属性是否在某个对象或者对象的原型上</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jackson&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数是info添加属于自己的属性</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj, &#123;</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// hasOwnProperty</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;address&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">//  false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in 操作符: 不管在当前对象还是原型中返回的都是true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;address&quot;</span> <span class="keyword">in</span> info); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> info); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for in (包括原型上的属性都可以遍历到)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> info) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// address name age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof">instanceof</h4><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 使用前面的寄生组合式继承</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="comment">// stu是否出现在构造函数 Student 的原型链上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="isPrototypeOf-了解">isPrototypeOf(了解)</h4><p>用于检测某个对象，是否出现在某个实例对象的原型链上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj)</span><br><span class="line"><span class="comment">// obj是否出现在info的原型链上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">isPrototypeOf</span>(info))</span><br></pre></td></tr></table></figure><h2 id="对象-函数-原型之间的关系">对象-函数-原型之间的关系</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jackson&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要是对象，里面就会有一个__proto__对象（隐式原型对象）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);<span class="comment">// [Object: null prototype] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 所有的 function xx() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 我们都可以认为 xx 是 new Function 创建出来的</span></span><br><span class="line"><span class="comment">// 相当于 var xxx = new Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要是函数，那么它就会有一个显式原型对象：Foo.prototype</span></span><br><span class="line"><span class="comment">// 那 Foo.prototype 这个对象又来自哪里呢？</span></span><br><span class="line"><span class="comment">// 创建函数的时候，JS内部就会创建一个对象,并添加到函数的prototype属性中：Foo.prototype = &#123;constructor: Foo&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo也是一个对象，只要是对象，就会有隐式原型对象 Foo.__proto__</span></span><br><span class="line"><span class="comment">// Foo.__proto__来自哪里？</span></span><br><span class="line"><span class="comment">// var Foo = new Function() </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 而 Function.prototype对象是我们创建Function函数的时候创建出来的</span></span><br><span class="line"><span class="comment">// Function.prototype = &#123;constructor: Function&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Function函数</span></span><br><span class="line"><span class="comment">// function Function() &#123;&#125;</span></span><br><span class="line"><span class="comment">// Function.prototype</span></span><br><span class="line"><span class="comment">// Function 又是一个对象</span></span><br><span class="line"><span class="comment">// Function.__proto__</span></span><br><span class="line"><span class="comment">// 唯一一个比较特殊的东西</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外还有 function Object() &#123;&#125;</span></span><br><span class="line"><span class="comment">// Object作为函数, 就会有Object.prototype</span></span><br><span class="line"><span class="comment">// Object作为对象, 就会有Object.__proto__</span></span><br><span class="line"><span class="comment">// Object函数是Function创建出来的，所以</span></span><br><span class="line"><span class="comment">// Objcet.__proto__ === Function.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后就是每个函数的原型prototype都会有一个constructor指回函数本身</span></span><br></pre></td></tr></table></figure><p>最后 上图！</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98247be221ed4805a65a68e7f0d8fffd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4465e678da8240028f973262ac63399d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深入JS面向对象&quot;&gt;深入JS面向对象&lt;/h2&gt;
&lt;h2 id=&quot;面向对象初识&quot;&gt;面向对象初识&lt;/h2&gt;
&lt;h2 id=&quot;创建对象的方式&quot;&gt;创建对象的方式&lt;/h2&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>07_严格模式</title>
    <link href="https://hillyee.github.io/2022/04/02/07_%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hillyee.github.io/2022/04/02/07_%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-01T16:47:09.000Z</published>
    <updated>2022-04-17T15:26:42.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="严格模式">严格模式</h3><h4 id="如何开启严格模式？">如何开启严格模式？</h4><p>在文件或者函数开头使用 “use strict”</p><h4 id="严格模式常见的限制">严格模式常见的限制</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="comment">// 1.禁止意外创建全局变量</span></span><br><span class="line"><span class="comment">// 在全局中不使用关键字直接定义变量</span></span><br><span class="line">message = <span class="string">&quot;hello&quot;</span></span><br><span class="line">message is not defined</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不允许函数有相同的参数名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y, x</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// Duplicate parameter name not allowed in this context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使静默错误(不报错但也没有任何效果)的赋值操作抛出异常</span></span><br><span class="line"><span class="literal">true</span>.<span class="property">name</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="title class_">NaN</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不可写</span></span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;hillyee&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;jenny&quot;</span></span><br><span class="line"><span class="comment">// 试图删除不可删除的属性，报错</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span></span><br><span class="line"><span class="comment">// Cannot delete property &#x27;name&#x27; of #&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.不允许使用原先的八进制格式</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0o123</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0x123</span> <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">0b100</span> <span class="comment">// 二进制</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="严格模式下的this">严格模式下的this</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格模式下，独立函数调用this默认绑定不是window，而是undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hill&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span></span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout的this</span></span><br><span class="line"><span class="comment">// 内部 fn.apply(this=window)</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;严格模式&quot;&gt;严格模式&lt;/h3&gt;
&lt;h4 id=&quot;如何开启严格模式？&quot;&gt;如何开启严格模式？&lt;/h4&gt;
&lt;p&gt;在文件或者函数开头使用 “use strict”&lt;/p&gt;
&lt;h4 id=&quot;严格模式常见的限制&quot;&gt;严格模式常见的限制&lt;/h4&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>06_纯函数-柯里化-组合</title>
    <link href="https://hillyee.github.io/2022/04/02/06_%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88/"/>
    <id>https://hillyee.github.io/2022/04/02/06_%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E7%BB%84%E5%90%88/</id>
    <published>2022-04-01T16:44:34.000Z</published>
    <updated>2022-04-14T02:11:10.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纯函数-柯里化-组合">纯函数 - 柯里化 - 组合</h3><h4 id="纯函数">纯函数</h4><ul><li><p>什么是纯函数？</p><ul><li><p>确定的输入，一定会产生确定的输出</p></li><li><p>函数在执行过程中，不能产生副作用</p></li></ul></li><li><p>什么是副作用？</p><ul><li>在执行一个函数时，除了返回值函数之外，还对调用函数产生了附加的影响，比如说修改了全局变量，修改参数或者改变外部的存储</li></ul></li><li><p>纯函数例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>, <span class="string">&quot;dna&quot;</span>]</span><br><span class="line"><span class="comment">// slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值</span></span><br><span class="line"><span class="comment">// slice函数本身它是不会修改原来的数组</span></span><br><span class="line"><span class="comment">// 所以slice函数本身就是一个纯函数</span></span><br><span class="line"><span class="keyword">var</span> newNames1 = names.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice不是一个纯函数</span></span><br><span class="line"><span class="keyword">var</span> newNames2 = names.<span class="title function_">splice</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names) <span class="comment">// [ &#x27;abc&#x27;, &#x27;cba&#x27; ] 改变了原数组</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="JavaScript柯里化">JavaScript柯里化</h4><ul><li><p>什么是柯里化？</p><ul><li>把接收多个参数的函数变成接收一个单一参数的函数</li><li>“如果你固定某些参数，你将得到接受余下参数的一个函数”</li><li>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数，这个过程称之为柯里化</li></ul></li><li><p>柯里化的结构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum1</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">z</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="title function_">sum1</span>(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>) <span class="comment">// 60</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum2</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z</span><br></pre></td></tr></table></figure></li><li><p>柯里化让函数的职责单一</p><p>每次接收的一个参数，都做它自己的逻辑</p></li><li><p>可以更好的复用参数逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">count</span>) &#123;</span><br><span class="line">  count = count * count</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> count + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如说我们想要每次的count都是5</span></span><br><span class="line"><span class="keyword">var</span> adder5 = <span class="title function_">makeAdder</span>(<span class="number">5</span>)</span><br><span class="line"><span class="title function_">adder5</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">adder5</span>(<span class="number">13</span>) </span><br></pre></td></tr></table></figure></li><li><p>柯里化函数的实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurrying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 当已经传入的参数 大于等于 需要的参数时, 就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// fn()</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有达到个数时, 需要返回一个新的函数,继续来接收参数</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">curried2</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收到参数后, 需要递归调用curried来检查函数的个数是否达到</span></span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args, ...args2])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> curried2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个柯里化的函数</span></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryAdd = <span class="title function_">myCurrying</span>(add1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryAdd</span>(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>));</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合函数">组合函数</h4><ul><li><p>什么是组合函数？</p><ul><li>组合函数是在 JavaScript 开发过程中一种对函数的使用技巧、模式</li></ul></li><li><p>组合函数的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num ** <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">square</span>((<span class="title function_">double</span>(count)))</span><br></pre></td></tr></table></figure></li><li><p>实现组合函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hyCompose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是函数,直接报错</span></span><br><span class="line">  <span class="keyword">let</span> length = fns.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fns[i] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Expected a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出所有的函数一次调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = length ? fns[index].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args) : args</span><br><span class="line">    <span class="keyword">while</span>(++index &lt; length) &#123;</span><br><span class="line">      result = fns[index].<span class="title function_">call</span>(<span class="variable language_">this</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFn = <span class="title function_">hyCompose</span>(double, square)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newFn</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;纯函数-柯里化-组合&quot;&gt;纯函数 - 柯里化 - 组合&lt;/h3&gt;
&lt;h4 id=&quot;纯函数&quot;&gt;纯函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;什么是纯函数？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确定的输入，一定会产生确定的输出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数在执行</summary>
      
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>05_认识arguments</title>
    <link href="https://hillyee.github.io/2022/04/02/05_%E8%AE%A4%E8%AF%86arguments/"/>
    <id>https://hillyee.github.io/2022/04/02/05_%E8%AE%A4%E8%AF%86arguments/</id>
    <published>2022-04-01T16:43:02.000Z</published>
    <updated>2022-04-17T15:26:35.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识-arguments">认识 arguments</h3><h4 id="什么是-arguments">什么是 arguments</h4><p><strong><code>arguments</code></strong> 是一个对应于传递给函数的参数的类数组对象。(MDN)</p><ul><li><p>类数组对象，就说明它本质上是一个对象类型</p></li><li><p>类数组表示它长得像数组，并且拥有数组的一些特性，比如说 length，可以通过 index 访问</p><p>但是却没有数组的一些方法，比如说 forEach，map 等</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 会帮你接收所有传递给函数的参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 10, &#x27;1&#x27;: 20, &#x27;2&#x27;: 30 &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取参数的长度</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// 根据索引值获取某一个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]); <span class="comment">// 20</span></span><br><span class="line">  <span class="comment">// 获取当前 arguments 所在的函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>); <span class="comment">// [Function: foo]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// arguments.forEach() 是不可以的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><h4 id="arguments-转成数组">arguments 转成数组</h4><p>如果我们需要遍历里面的参数呢？或者说使用一些数组的方法呢？</p><p>所以在开发中，我们经常会把 arguments 转成数组</p><h5 id="第一种方法-自己遍历">第一种方法: 自己遍历</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 我们可以通过索引值拿到 arguments 的每一个值</span></span><br><span class="line">  <span class="comment">// 然后添加到新的数组</span></span><br><span class="line">  <span class="keyword">let</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    newArr.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [ 10, 20, 30, 40, 50 ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>) </span><br></pre></td></tr></table></figure><h5 id="第二种方法：Array-prototype-slice">第二种方法：Array.prototype.slice</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>Array.prototype.slice.call(arguments) ？什么意思呀？</p><p>首先，我们一般使用 slice 的时候，是 <code>arr.slice(start, end)</code>，那如果没有这个arr呢？我们怎么才能拿到 slice 这个方法</p><p>是不是可以在 Array 的原型上面找这个方法，所以 Array.prototype.slice()</p><p>那为什么要用 call 来调用？</p><p>我们先来模拟一下 Array 中的 slice 是怎么实现的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myslice</span> = <span class="keyword">function</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果我们直接 Array.prototype.myslice() 这样调用的话, this 指向的就是prototype了</span></span><br><span class="line">  <span class="comment">// 而我们希望的是, 这里的 this 是指向调用 slice 这个方法的数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="variable language_">this</span></span><br><span class="line">  start = start || <span class="number">0</span></span><br><span class="line">  end = end || arr.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newArray = []</span><br><span class="line">  <span class="comment">// 从start到end(不包括end),把元素添加到数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    newArray.<span class="title function_">push</span>(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们要使用 call 来显式绑定这个 this，让this指向数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myslice</span>.<span class="title function_">call</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然可以传递参数</span></span><br><span class="line"><span class="keyword">let</span> newArr2 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myslice</span>.<span class="title function_">call</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr2); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><p>那跟我们 arguments 有什么关系？</p><p>Array内部 slice 的实现只不过是对 this，也就是需要使用 slice 的数组进行遍历，然后把需要的部分加入到新数组</p><p>那遍历 arguments 也可以啊，把元素一个个加入到一个数组里面，再把这个数组返回，最后不就实现了 arguments 转数组了吗</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 同样道理的还有一种方法, 我们目的就是拿到 slice 这个方法,并且让 this 绑定 arguments,让内部遍历arguments</span></span><br><span class="line">  <span class="keyword">let</span> newArr2 = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>再看回这个，应该理解了吧</p><h5 id="Array-from-ES6"><strong>Array</strong>.from (ES6)</h5><p><strong>Array.from()</strong> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例（MDN）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h5 id="展开运算符-ES6">展开运算符 (ES6)</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 因为展开运算符实际上也是遍历，把遍历的元素一个个放到数组</span></span><br><span class="line">  <span class="keyword">let</span> newArr = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="箭头函数没有-arguments">箭头函数没有 arguments</h4><p>箭头函数是不绑定 arguments 的，如果在箭头函数中使用 arguments，会去找上层作用域中的arguments</p><p>注意，全局作用域是没有 arguments 的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 找上层作用域，找到 window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// arguments is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// arguments 有 123</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// Arguments [123]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// Arguments [123]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">foo</span>(<span class="number">123</span>)</span><br><span class="line"><span class="title function_">fn</span>() </span><br></pre></td></tr></table></figure><p>那如果想传递多个参数呢？用 ES6 的剩余参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params">a, b, ...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 1 2 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args); <span class="comment">// [3,4,5,6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;认识-arguments&quot;&gt;认识 arguments&lt;/h3&gt;
&lt;h4 id=&quot;什么是-arguments&quot;&gt;什么是 arguments&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/strong&gt; 是一个对应于传递给函数的参数的</summary>
      
    
    
    
    <category term="🔫深入JS高级语法" scheme="https://hillyee.github.io/categories/%F0%9F%94%AB%E6%B7%B1%E5%85%A5JS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3源码学习</title>
    <link href="https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://hillyee.github.io/2022/03/31/Vue3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-31T11:42:30.000Z</published>
    <updated>2022-04-09T11:06:58.213Z</updated>
    
    <content type="html"><![CDATA[<h1>Vue3源码学习</h1><blockquote><p>第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭</p></blockquote><h2 id="1-真实的DOM渲染">1. 真实的DOM渲染</h2><p>传统的前端开发中，我们是编写自己的HTML，最终被渲染到浏览器上的，这个过程大概是：</p><p>解析 html 转化成 DOM 树，然后渲染到页面</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06870cfbd95e41b6b19f557735a82565~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="2-虚拟DOM">2. 虚拟DOM</h2><h3 id="2-1-渲染过程">2.1 渲染过程</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5da766b840443a082d46dea3ef61179~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="3-Vue-源码的三大核心系统">3. Vue 源码的三大核心系统</h2><ul><li><p>Complier模块：编译模板系统</p></li><li><p>Runtime模块：也可以称之为 Renderer模块，真正渲染的模块</p></li><li><p>Reactivity模块：响应式系统</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2570e47944e340d09d20b337494d597a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li>三大系统协同工作</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917ae20ad154485f86dc308eb3841d69~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="4-实现-Mini-Vue">4. 实现 Mini-Vue</h2><blockquote><p>mini-vue的实现也是，后面有时间得回来重新看看</p></blockquote><p>包括三部分：</p><ul><li>渲染系统模块</li><li>可响应式系统模块</li><li>应用程序入口模块</li></ul><h3 id="4-1-渲染系统实现">4.1 渲染系统实现</h3><p>包含三个功能：</p><ul><li>h 函数，返回一个 VNode 对象</li><li>mount 函数，用于将 VNode 挂载到 DOM 上</li><li>patch 函数，用于对比两个 VNode，决定如何处理新的VNode（diff）</li></ul><h4 id="h函数生成-VNode">h函数生成 VNode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 VNode</span></span><br><span class="line"><span class="comment">// 直接返回一个 VNode对象即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">h</span> = (<span class="params">tag, props, children</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mount函数挂载-vnode">mount函数挂载 vnode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mount函数, 挂载VNode</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mount</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1.根据tag创建HTML元素,并且存储到vnode的el中</span></span><br><span class="line">  <span class="keyword">const</span> el = vnode.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>)</span><br><span class="line">  <span class="comment">// 2.处理props属性</span></span><br><span class="line">  <span class="comment">// 2.1 如果以on开头,那么监听事件</span></span><br><span class="line">  <span class="comment">// 2.2 普通属性直接通过 setAttribute 添加</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">props</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnode.<span class="property">props</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.<span class="property">props</span>[key]</span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.处理children</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      el.<span class="property">textContent</span> = vnode.<span class="property">children</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">mount</span>(item, el)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.将 el挂载到container上</span></span><br><span class="line">  container.<span class="title function_">appendChild</span>(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="patch函数-对比两个VNode">patch函数 - 对比两个VNode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patch,对比两个 VNode</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. tag不同,直接加入新的节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1.<span class="property">tag</span> !== n2.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1Elparent = n1.<span class="property">el</span>.<span class="property">parentElement</span></span><br><span class="line">    n1Elparent.<span class="title function_">removeChild</span>(n1.<span class="property">el</span>)</span><br><span class="line">    <span class="title function_">mount</span>(n2, n1Elparent)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 取出element对象,并且在n2中进行保存</span></span><br><span class="line">    <span class="keyword">const</span> el = n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line">    <span class="comment">// 2. 处理props</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.1 获取所有的newProps添加到el</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key]</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123; <span class="comment">// 对事件监听的判断</span></span><br><span class="line">          el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), </span><br><span class="line">          newValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          el.<span class="title function_">setAttribute</span>(key, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2删除旧的props</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = oldProps[key]</span><br><span class="line">        el.<span class="title function_">removeEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.<span class="title function_">removeAttribute</span>(key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.处理children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span> || []</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.<span class="property">children</span> || []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&quot;string&quot;</span>) &#123; <span class="comment">// 3.1newChildren本身是一个string</span></span><br><span class="line">      <span class="comment">// 边界情况 如果oldChildren也是一个字符串</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newChildren !== oldChildren) &#123;</span><br><span class="line">          el.<span class="property">textContent</span> = newChildren</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="property">innerHTML</span> = newChildren</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3.2 newChildren本身是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        el.<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        newChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">mount</span>(item, el)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// oldChildren 也是数组</span></span><br><span class="line">        <span class="comment">// 1. 前面有相同节点的</span></span><br><span class="line">        <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldChildren.<span class="property">length</span>, newChildren.<span class="property">length</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">          <span class="title function_">patch</span>(oldChildren[i], newChildren[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果新节点的length更长，那么剩余的新节点进行挂载操作</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &gt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          newChildren.<span class="title function_">slice</span>(oldChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">mount</span>(item, el)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果旧节点的length更长，那么移除剩余的旧节点进行</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &lt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          oldChildren.<span class="title function_">slice</span>(newChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            el.<span class="title function_">removeChild</span>(item.<span class="property">el</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-响应式系统">4.2 响应式系统</h3><h4 id="依赖收集系统-vue2响应式系统">依赖收集系统 + vue2响应式系统</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="comment">// 只要new Dep,就会给你添加subscribes属性 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 创建集合(里面放某属性依赖的函数)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  <span class="title function_">effect</span>() <span class="comment">// 原始数据先执行一次</span></span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDep</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据对象(target)取出对应的Map对象</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.取出具体的dep对象</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据对象拿到所有key,组成数组</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(raw).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取key对应的依赖</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(raw, key)</span><br><span class="line">    <span class="keyword">let</span> value = raw[key]</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(raw, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="comment">// 用到了某个key,调用get,所以可以在这里收集依赖</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; <span class="comment">// 当属性被重新赋值的时候,会调用set,所以在这里执行这个属性依赖的函数</span></span><br><span class="line">        <span class="comment">// raw[key] = newValue 不能这样设置,否则递归了(又对raw操作,又劫持,又来到set这里了)</span></span><br><span class="line">        <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">          value = newValue</span><br><span class="line">          dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hillyee&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect1</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">counter</span> * <span class="number">2</span>, info.<span class="property">name</span>, <span class="string">&#x27;w1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect2</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">counter</span> * info.<span class="property">counter</span>, <span class="string">&#x27;w2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// info.counter++ // 修改数据的时候,所有对这个数据有依赖的函数都应该被执行一次</span></span><br><span class="line"><span class="comment">// info.name = &quot;hahahhahah&quot;</span></span><br></pre></td></tr></table></figure><h4 id="响应式系统-vue3-proxy实现">响应式系统 vue3-proxy实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="comment">// Proxy(原对象,代理对象)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(raw, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(target, key) <span class="comment">// 获取该属性的依赖</span></span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(target, key)</span><br><span class="line">      target[key] = newValue</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么-Vue3-选择-Proxy-呢？">为什么 Vue3 选择 Proxy 呢？</h4><ul><li><p>Object.definedProperty 是劫持对象的属性时，如果新增元素，</p><p>那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理</p></li><li><p>修改对象的不同： 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截；</p><p>而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截；</p></li></ul><h3 id="4-3-框架外层-API-设计">4.3 框架外层 API 设计</h3><h4 id="createApp">createApp()</h4><p>用于创建一个app对象，该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">rootComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">mount</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector)</span><br><span class="line">      <span class="keyword">let</span> isMounted = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">let</span> oldVNode = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">watchEffect</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">          <span class="comment">// rootComponent.render() 返回根组件的vnode</span></span><br><span class="line">          oldVNode = rootComponent.<span class="title function_">render</span>()</span><br><span class="line">          <span class="title function_">mount</span>(oldVNode, container)</span><br><span class="line">          isMounted = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> newVNode = rootComponent.<span class="title function_">render</span>()</span><br><span class="line">          <span class="title function_">patch</span>(oldVNode, newVNode)</span><br><span class="line">          oldVNode = newVNode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用案例–计数">使用案例–计数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../mini_vue/renderer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../mini_vue/reactive.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.创建根组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">counter</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;),</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">h</span>(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">`当前计数:<span class="subst">$&#123;<span class="variable language_">this</span>.data.counter&#125;</span>`</span>),</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">h</span>(<span class="string">&quot;button&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">counter</span>++</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">counter</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;, <span class="string">&quot;+1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        ])</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2.挂载根组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span></span><br><span class="line"><span class="language-javascript">    app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>Vue3源码阅读</h1><blockquote><p>根据图的流程，加上源码，多看看叭，第一次看源码确实有点吃力了</p><p>先看熟悉流程，然后可以 debugger 在浏览器上简单过一下整个流程</p></blockquote><h2 id="createApp-2">createApp</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941441a206f545c488351612ee7f0a96~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="源码阅读之挂载根组件">源码阅读之挂载根组件</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e27cf0afe14494e963576c217bff7ab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;<span class="attr">props</span>: &#123;<span class="attr">message</span>: <span class="title class_">String</span>&#125;</span><br><span class="line">instance</span><br><span class="line"><span class="comment">// 1.处理props和attrs</span></span><br><span class="line">instance.<span class="property">props</span></span><br><span class="line">instance.<span class="property">attrs</span></span><br><span class="line"><span class="comment">// 2.处理slots</span></span><br><span class="line">instance.<span class="property">slots</span></span><br><span class="line"><span class="comment">// 3.执行setup</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">setup</span>()</span><br><span class="line">instance.<span class="property">setupState</span> = <span class="title function_">proxyRefs</span>(result);</span><br><span class="line"><span class="comment">// 4.编译template -&gt; compile</span></span><br><span class="line">&lt;template&gt; -&gt; render函数</span><br><span class="line">instance.<span class="property">render</span> = <span class="title class_">Component</span>.<span class="property">render</span> = render函数</span><br><span class="line"><span class="comment">// 5.对vue2的options api进行知识</span></span><br><span class="line">data/methods/computed/生命周期</span><br></pre></td></tr></table></figure><h2 id="组件化的初始化">组件化的初始化</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40e10ca0c2b044d78ba221099f6d9eef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="Compile过程">Compile过程</h2><p>对于不会改变的静态节点进行作用于提升</p><blockquote><p>我都没找到这部分函数。。。</p></blockquote><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd404365f8f946d89e99ccc604ffa235~tplv-k3u1fbpfcp-watermark.image?" alt="image.png " style="zoom:67%;" /><h2 id="Block-Tree-分析">Block Tree 分析</h2><p>vue3的一个优化：对于不会改变的静态节点进行作用域提升，仅对新的vnode进行创建</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c78021a3a241ca8ef00958116b4445~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="生命周期回调">生命周期回调</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8269743b1fb949219a2216950b8b1fb6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="template中数据的使用顺序">template中数据的使用顺序</h2><blockquote><p>如果setup跟data中有同一个属性,首先选择setup的,内部做了一个判断吧</p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6505298f6148e69434be3079bb168c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Vue3源码学习&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;第一次这样学习源码还是挺有难度的，希望后面可以慢慢提升，有自己阅读源码的能力叭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-真实的DOM渲染&quot;&gt;1. 真实的DOM渲染&lt;/h2&gt;
&lt;p&gt;传统的前端开发中</summary>
      
    
    
    
    <category term="深入Vue3+Typescript学习⚡" scheme="https://hillyee.github.io/categories/%E6%B7%B1%E5%85%A5Vue3-Typescript%E5%AD%A6%E4%B9%A0%E2%9A%A1/"/>
    
    
    <category term="vue3" scheme="https://hillyee.github.io/tags/vue3/"/>
    
  </entry>
  
</feed>
